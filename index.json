[{"categories":["makefile"],"content":"示例 树形结构： ubuntu@VM-12-11-ubuntu:~/c++/makefile$ tree . ├── factorial.cpp ├── functions.h ├── main.cpp ├── Makefile └── printHello.cpp 0 directories, 5 files functions.h #ifndef FUNCTIONS_H #define FUNCTIONS_H #include \u003ciostream\u003e void printHello(); int factorial(int n); #endif factorial.cpp #include \"functions.h\" int factorial(int n) { if (n == 1) { return 1; } else { return n * factorial(n - 1); } } main.cpp #include \"functions.h\" using namespace std; int main() { printHello(); cout \u003c\u003c \"This is main：\" \u003c\u003c endl; cout \u003c\u003c \"The factorial of 5 is：\" \u003c\u003c factorial(5) \u003c\u003c endl; } printHello.cpp #include \"functions.h\" using namespace std; void printHello() { int i; cout \u003c\u003c \"Hello World!\" \u003c\u003c endl; } ","date":"2022-12-29","objectID":"/posts/makefile/:1:0","tags":["makefile"],"title":"makefile的简单例子","uri":"/posts/makefile/"},{"categories":["makefile"],"content":"版本 1 ## VERSION 1 hello: main.cpp printHello.cpp factorial.cpp g++ -o hello main.cpp printHello.cpp factorial.cpp 第一个版本比较简单： hello的生成依赖于：main.cpp printHello.cpp factorial.cpp 通过：g++ -o hello main.cpp printHello.cpp factorial.cpp 来生成hello这个目标 ","date":"2022-12-29","objectID":"/posts/makefile/:2:0","tags":["makefile"],"title":"makefile的简单例子","uri":"/posts/makefile/"},{"categories":["makefile"],"content":"版本 2 CXX = g++ TARGET = hello OBJ = main.o printHello.o factorial.o $(TARGET) : $(OBJ) $(CXX) -o $(TARGET) $(OBJ) main.o : main.cpp $(CXX) -c main.cpp printHello.o : printHello.cpp $(CXX) -c printHello.cpp factorial.o : factorial.cpp $(CXX) -c factorial.cpp 首先定义了3个变量，CXX、TARGET、OBJ；然后再说明定义的TARGET变量依赖于OBJ这个变量，如果OBJ变量更新的化，使用命令($(CXX) -o $(TARGET) $(OBJ))重新生成CXX。而OBJ变量依赖于main.o printHello.o factorial.o这三个文件，然后make会根据后面的解释生成这三个文件。 make生成： ubuntu@VM-12-11-ubuntu:~/c++/makefile$ make g++ -c main.cpp g++ -c printHello.cpp g++ -c factorial.cpp g++ -o hello main.o printHello.o factorial.o ","date":"2022-12-29","objectID":"/posts/makefile/:3:0","tags":["makefile"],"title":"makefile的简单例子","uri":"/posts/makefile/"},{"categories":["makefile"],"content":"版本 3 CXX = g++ TARGET = hello OBJ = main.o printHello.o factorial.o # 增加了一条编译选项 CXXFLAGS = -c -Wall $(TARGET) : ${OBJ} ${CXX} -o $@ $^ %.o : %.cpp $(CXX) $(CXXFLAGS) $\u003c -o $@ .PHONY : clear clear : rm -f *.o $(TARGET) 其中，$@ 代表的就是 $(TARGET)，$^ 代表的就是 ${OBJ} $(TARGET) : ${OBJ} ${CXX} -o $@ $^ 如下的命令是将所以的.cpp文件生成对应的.o文件，以$(CXX) $(CXXFLAGS) $\u003c -o $@命令的方式生成。 %.o : %.cpp $(CXX) $(CXXFLAGS) $\u003c -o $@ 这条命令是删除对应*.o文件和$(TARGET)文件 .PHONY : clear clear : rm -f *.o $(TARGET) 其中.PHONY : clear用来避免歧义 可以通过 make clear来执行： ubuntu@VM-12-11-ubuntu:~/c++/makefile$ make clear rm -f *.o hello ","date":"2022-12-29","objectID":"/posts/makefile/:4:0","tags":["makefile"],"title":"makefile的简单例子","uri":"/posts/makefile/"},{"categories":["makefile"],"content":"版本 4 CXX = g++ TARGET = hello SRC = $(wildcard *.cpp) OBJ = $(patsubst %.cpp, %.o, ${SRC}) CXXFLAGS = -c -Wall $(TARGET) : ${OBJ} ${CXX} -o $@ $^ %.o : %.cpp $(CXX) $(CXXFLAGS) $\u003c -o $@ .PHONY : clear clear : rm -f *.o $(TARGET) SRC = $(wildcard *.cpp)，将所有当前目录的.cpp 都放到SRC变量中。 OBJ = $(patsubst %.cpp, %.o, ${SRC})，将SRC所有的.cpp文件 替换为.o文件 ","date":"2022-12-29","objectID":"/posts/makefile/:5:0","tags":["makefile"],"title":"makefile的简单例子","uri":"/posts/makefile/"},{"categories":["Linux"],"content":"1. 路径相关 ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"1.1 pwd 显示当前路径 在终端中输入pwd命令，显示当前我们所在的位置： ubuntu@VM-12-11-ubuntu:~$ pwd /home/ubuntu ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:1","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"1.2 ls 查看当前目录 ubuntu@VM-12-11-ubuntu:~$ ls build c++ muduo my-website recipes snap 可以使用如下命令让这些文件列表输出，并且显示文件相关的信息： ubuntu@VM-12-11-ubuntu:~$ ls -l total 24 drwxrwxr-x 4 ubuntu ubuntu 4096 Oct 31 14:07 build drwxrwxr-x 9 ubuntu ubuntu 4096 Dec 2 14:34 c++ drwxrwxr-x 9 ubuntu ubuntu 4096 Nov 3 15:17 muduo drwxrwxr-x 17 ubuntu ubuntu 4096 Dec 8 19:33 my-website drwxrwxr-x 26 ubuntu ubuntu 4096 Oct 28 14:21 recipes drwx------ 3 ubuntu ubuntu 4096 Dec 8 16:14 snap 使用ls -al列出所有的文件和文件夹，这里包含隐藏目录和文件： ubuntu@VM-12-11-ubuntu:~$ ls -al total 96 drwxr-xr-x 14 ubuntu ubuntu 4096 Dec 8 19:16 . drwxr-xr-x 4 root root 4096 Oct 28 13:48 .. -rw------- 1 ubuntu ubuntu 12973 Dec 9 14:50 .bash_history -rw-r--r-- 1 ubuntu ubuntu 220 Sep 21 16:16 .bash_logout -rw-r--r-- 1 ubuntu ubuntu 3771 Sep 21 16:16 .bashrc drwxrwxr-x 4 ubuntu ubuntu 4096 Oct 31 14:07 build drwxrwxr-x 9 ubuntu ubuntu 4096 Dec 2 14:34 c++ drwx------ 3 ubuntu ubuntu 4096 Oct 28 14:37 .cache -rw-rw-r-- 1 ubuntu ubuntu 61 Oct 28 15:11 .gitconfig drwxrwxr-x 3 ubuntu ubuntu 4096 Oct 28 14:37 .local drwxrwxr-x 9 ubuntu ubuntu 4096 Nov 3 15:17 muduo drwxrwxr-x 17 ubuntu ubuntu 4096 Dec 8 19:33 my-website drwxrwxr-x 2 ubuntu ubuntu 4096 Sep 21 16:22 .pip -rw-r--r-- 1 ubuntu ubuntu 807 Sep 21 16:16 .profile -rw-rw-r-- 1 ubuntu ubuntu 73 Oct 28 13:48 .pydistutils.cfg drwxrwxr-x 26 ubuntu ubuntu 4096 Oct 28 14:21 recipes drwx------ 3 ubuntu ubuntu 4096 Dec 8 16:14 snap drwx------ 2 ubuntu ubuntu 4096 Oct 28 15:09 .ssh -rw-r--r-- 1 ubuntu ubuntu 0 Oct 28 14:00 .sudo_as_admin_successful -rw------- 1 ubuntu ubuntu 0 Oct 28 13:48 .viminfo drwxrwxr-x 2 ubuntu ubuntu 4096 Oct 30 19:37 .vscode drwxrwxr-x 5 ubuntu ubuntu 4096 Dec 9 09:19 .vscode-server -rw-rw-r-- 1 ubuntu ubuntu 183 Dec 8 20:32 .wget-hsts 其中包含.和..目录，也就是当前路径和上级目录，以.开始的文件就是隐藏文件。 ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:2","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"1.3 cd 进入某个目录 1.3.1 cd dir 在命令行终端中可以使用cd进入某个目录 ubuntu@VM-12-11-ubuntu:~$ cd my-website/ ubuntu@VM-12-11-ubuntu:~/my-website$ 这里还有个技巧，你可以只输入文件/文件夹名字的前几个字母，然后点击tab键，让linux自动补全。 1.3.2 cd .. 返回上一级目录，这时可以使用cd ..返回上级目录，例如： ubuntu@VM-12-11-ubuntu:~/my-website$ cd .. ubuntu@VM-12-11-ubuntu:~$ 1.3.3 cd / 与 cd ~ 可以使用cd /命令切换到操作系统根目录，cd、cd ~命令返回到用户目录。 cd - 使用cd -命令可以回到上一个打开的目录 ubuntu@VM-12-11-ubuntu:~$ cd my-website/content/ ubuntu@VM-12-11-ubuntu:~/my-website/content$ cd - /home/ubuntu ubuntu@VM-12-11-ubuntu:~$ ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:3","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"2. 文件相关 ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"2.1 mkdir 创建目录 使用mkdir命令创建一个文件夹 mkdir workspace ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:1","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"2.2 touch 创建文件 ubuntu@VM-12-11-ubuntu:~$ touch workspace/test.txt ubuntu@VM-12-11-ubuntu:~$ tree workspace/ workspace/ └── test.txt 0 directories, 1 file ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:2","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"2.3 mv 命令 2.3.1 文件重命名 ubuntu@VM-12-11-ubuntu:~$ mv workspace/test.txt workspace/newFile.txt ubuntu@VM-12-11-ubuntu:~$ tree workspace/ workspace/ └── newFile.txt 0 directories, 1 file 2.3.2 移动文件 ubuntu@VM-12-11-ubuntu:~/workspace$ mv newFile.txt ~ ubuntu@VM-12-11-ubuntu:~/workspace$ cd ../ ubuntu@VM-12-11-ubuntu:~$ ll -rw-rw-r-- 1 ubuntu ubuntu 0 Dec 9 15:07 newFile.txt 还原： ubuntu@VM-12-11-ubuntu:~/workspace$ mv ../newFile.txt . ubuntu@VM-12-11-ubuntu:~/workspace$ ll total 8 drwxrwxr-x 2 ubuntu ubuntu 4096 Dec 9 15:14 ./ drwxr-xr-x 15 ubuntu ubuntu 4096 Dec 9 15:14 ../ -rw-rw-r-- 1 ubuntu ubuntu 0 Dec 9 15:07 newFile.txt ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:3","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"2.4 cp 拷贝文件/目录 ubuntu@VM-12-11-ubuntu:~/workspace$ cp newFile.txt copy_newFile.txt ubuntu@VM-12-11-ubuntu:~/workspace$ tree . ├── copy_newFile.txt └── newFile.txt 0 directories, 2 files ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:4","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"2.5 rm 删除文件 ubuntu@VM-12-11-ubuntu:~/workspace$ rm copy_newFile.txt ubuntu@VM-12-11-ubuntu:~/workspace$ tree . └── newFile.txt 0 directories, 1 file 需要注意的是，rm可以直接删除一个文件，但是如果你想要删除整个文件夹中所有内容，那么你需要使用-rf选项： ubuntu@VM-12-11-ubuntu:~$ rm -rf workspace/ ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:5","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"2.6 tar 命令 linux中有很多.tar.gz的压缩包文件，解压这些压缩包文件需要用到tar命令 tar xzf VMwareTools-10.3.10-13959562.tar.gz 直接 tar xzf 文件名.tar.gz就可以解压出文件。 ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:6","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"3. 查找 ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"3.1 find 文件查找 命令格式：find (目录) [-type d | f] (文件夹 | 文件) -name （名称，可使用正则表达式） 当前my-website目录结构： ubuntu@VM-12-11-ubuntu:~/my-website$ ls -l total 104 -rw-rw-r-- 1 ubuntu ubuntu 6661 Oct 28 15:13 404.html drwxrwxr-x 2 ubuntu ubuntu 4096 Oct 28 15:13 archetypes drwxrwxr-x 2 ubuntu ubuntu 4096 Dec 8 14:56 categories -rw-rw-r-- 1 ubuntu ubuntu 4962 Dec 9 09:33 config.toml drwxrwxr-x 4 ubuntu ubuntu 4096 Oct 28 15:13 content drwxrwxr-x 2 ubuntu ubuntu 4096 Oct 28 15:13 css drwxrwxr-x 4 ubuntu ubuntu 4096 Oct 28 15:13 imgs -rw-rw-r-- 1 ubuntu ubuntu 16845 Oct 28 15:13 index.html -rw-rw-r-- 1 ubuntu ubuntu 5845 Oct 28 15:13 index.xml drwxrwxr-x 2 ubuntu ubuntu 4096 Oct 28 15:13 js drwxrwxr-x 6 ubuntu ubuntu 4096 Oct 28 15:13 lib drwxrwxr-x 3 ubuntu ubuntu 4096 Oct 28 15:13 page drwxrwxr-x 12 ubuntu ubuntu 4096 Oct 28 15:13 posts drwxrwxr-x 12 ubuntu ubuntu 4096 Dec 8 21:12 public drwxrwxr-x 3 ubuntu ubuntu 4096 Oct 28 15:13 resources -rw-rw-r-- 1 ubuntu ubuntu 3650 Oct 28 15:13 sitemap.xml drwxrwxr-x 2 ubuntu ubuntu 4096 Oct 28 15:13 svg drwxrwxr-x 10 ubuntu ubuntu 4096 Oct 28 15:13 tags drwxrwxr-x 3 ubuntu ubuntu 4096 Dec 8 14:55 themes 3.1.1 根据名字查找文件 ubuntu@VM-12-11-ubuntu:~/my-website$ sudo find . -type f -name *.txt ./themes/FixIt/layouts/robots.txt ./themes/FixIt/layouts/index.txt 加sudo的原因是有些文件夹的访问可能需要管理员权限。 3.1.2 根据名字查找目录 ubuntu@VM-12-11-ubuntu:~/my-website$ sudo find . -type d -name imgs ./imgs ./content/imgs ./public/imgs 3.1.3 根据名字查找目录或文件 ubuntu@VM-12-11-ubuntu:~/my-website$ sudo find . -name *.txt ./themes/FixIt/layouts/robots.txt ./themes/FixIt/layouts/index.txt 3.1.4 根据文件大小查找 ubuntu@VM-12-11-ubuntu:~/my-website$ sudo find . -size +1M ./.git/objects/pack/pack-baf6b2db7c80e5a63c106624efaf9c594488c31b.pack ./themes/FixIt/assets/lib/mermaid/mermaid.min.js ./themes/FixIt/assets/lib/lunr/lunr.segmentit.js ./themes/FixIt/.git/objects/pack/pack-cdb6d7f116069d8fc2ef2a77a3b30240576af855.pack ./public/.git/objects/pack/pack-6d1ce01d615acf91d67d8d57ee7c16dff4f27d36.pack ubuntu@VM-12-11-ubuntu:~/my-website$ sudo find . -size +700k ./.git/objects/pack/pack-baf6b2db7c80e5a63c106624efaf9c594488c31b.pack ./themes/FixIt/assets/lib/mermaid/mermaid.min.js ./themes/FixIt/assets/lib/mapbox-gl/mapbox-gl.js ./themes/FixIt/assets/lib/gitalk/gitalk.min.js ./themes/FixIt/assets/lib/lunr/lunr.segmentit.js ./themes/FixIt/assets/lib/echarts/echarts.min.js ./themes/FixIt/.git/objects/pack/pack-cdb6d7f116069d8fc2ef2a77a3b30240576af855.pack ./public/.git/objects/pack/pack-6d1ce01d615acf91d67d8d57ee7c16dff4f27d36.pack 3.1.5 根据名字查找目录文件，忽略大小写 ubuntu@VM-12-11-ubuntu:~/my-website$ sudo find . -type d -iname content ./content ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:1","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"3.2 grep 命令 find是查找文件，那么grep则是查找文件中的内容字段。 grep家族总共有三个：grep，egrep，fgrep，其常用选项有： -E ：开启扩展（Extend）的正则表达式。 -i ：忽略大小写（ignore case）。 -v ：反过来（invert），只打印没有匹配的，而匹配的反而不打印。 -n ：显示行号 -w ：被匹配的文本只能是单词，而不能是单词中的某一部分，如文本中有liker，而我搜寻的只是like，就可以使用-w选项来避免匹配 liker -c ：显示总共有多少行被匹配到了，而不是显示被匹配到的内容，注意如果同时使用-cv选项是显示有多少行没有被匹配到。 -o ：只显示被模式匹配到的字符串。 –color :将匹配到的内容以颜色高亮显示。 -A n：显示匹配到的字符串所在的行及其后n行，after -B n：显示匹配到的字符串所在的行及其前n行，before -C n：显示匹配到的字符串所在的行及其前后各n行，context 以main.cpp为例： #include \u003ciostream\u003e #include \u003cstring\u003e class X { public: explicit X(std::string str) : str_(str) { }; private: std::string str_; }; int main() { X x1(\"hello\"); //X x2(std::string(\"hello\")); return 0; } 3.2.1 查找某字符串 ubuntu@VM-12-11-ubuntu:~/c++/test_demo$ grep \"hello\" ./main.cpp X x1(\"hello\"); //X x2(std::string(\"hello\")); 3.2.2 查找某字符串前后行内容 显示匹配到的字符串所在的行及其后n行： ubuntu@VM-12-11-ubuntu:~/c++/test_demo$ grep -A 2 \"main\" ./main.cpp int main() { X x1(\"hello\"); //X x2(std::string(\"hello\")); 显示匹配到的字符串所在的行及其前n行： ubuntu@VM-12-11-ubuntu:~/c++/test_demo$ grep -B 3 \"main\" ./main.cpp std::string str_; }; int main() { 显示匹配到的字符串所在的行及其前后各n行： ubuntu@VM-12-11-ubuntu:~/c++/test_demo$ grep -C 3 \"main\" ./main.cpp std::string str_; }; int main() { X x1(\"hello\"); //X x2(std::string(\"hello\")); ","date":"2022-12-09","objectID":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:2","tags":["Linux"],"title":"Linux常用命令","uri":"/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["hugo"],"content":"推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将 SCSS 转换为 CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验。 主题参考 ","date":"2022-12-08","objectID":"/posts/hugo%E6%90%AD%E5%BB%BA/:0:0","tags":["hugo"],"title":"Hugo的安装和FixIt 主题","uri":"/posts/hugo%E6%90%AD%E5%BB%BA/"},{"categories":["hugo"],"content":"ubuntu 如何安装snap 也就说你的Ubuntu没有安装snap。 你可能需要自己手动安装它，运行命令 sudo apt update \u0026\u0026 sudo apt install snapd ，apt命令将会更新软件包索引并安装snapd。 ","date":"2022-12-08","objectID":"/posts/hugo%E6%90%AD%E5%BB%BA/:1:0","tags":["hugo"],"title":"Hugo的安装和FixIt 主题","uri":"/posts/hugo%E6%90%AD%E5%BB%BA/"},{"categories":["hugo"],"content":"安装hugo 默认情况下，Hugo 在 Ubuntu 20.04 默认存储库中不可用。 现在使用 Snap 安装 Hugo： sudo snap install hugo ","date":"2022-12-08","objectID":"/posts/hugo%E6%90%AD%E5%BB%BA/:2:0","tags":["hugo"],"title":"Hugo的安装和FixIt 主题","uri":"/posts/hugo%E6%90%AD%E5%BB%BA/"},{"categories":["hugo"],"content":"使用Hugo创建一个站点 由于是用snap安装的Hugo，我们在Hugo相关命令前要加上snap run： snap run hugo new site my_website 这样就在/home下创建了一个my_website的文件夹，里面保存了Hugo生成网站的文件。 ","date":"2022-12-08","objectID":"/posts/hugo%E6%90%AD%E5%BB%BA/:3:0","tags":["hugo"],"title":"Hugo的安装和FixIt 主题","uri":"/posts/hugo%E6%90%AD%E5%BB%BA/"},{"categories":["hugo"],"content":"安装主题 git clone https://github.com/hugo-fixit/FixIt.git themes/FixIt ","date":"2022-12-08","objectID":"/posts/hugo%E6%90%AD%E5%BB%BA/:4:0","tags":["hugo"],"title":"Hugo的安装和FixIt 主题","uri":"/posts/hugo%E6%90%AD%E5%BB%BA/"},{"categories":["hugo"],"content":"测试网站 snap run hugo server -D 在浏览器中输入localhost:1313可以预览网站。 ","date":"2022-12-08","objectID":"/posts/hugo%E6%90%AD%E5%BB%BA/:5:0","tags":["hugo"],"title":"Hugo的安装和FixIt 主题","uri":"/posts/hugo%E6%90%AD%E5%BB%BA/"},{"categories":["hugo"],"content":"生成网站 接下来我们要生成静态页面 snap run hugo ","date":"2022-12-08","objectID":"/posts/hugo%E6%90%AD%E5%BB%BA/:6:0","tags":["hugo"],"title":"Hugo的安装和FixIt 主题","uri":"/posts/hugo%E6%90%AD%E5%BB%BA/"},{"categories":["c/c++"],"content":" 源码参考：Muduo 第二部分：Muduo网络库 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:0:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"10. 初探EventLoop ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:1:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"10.1 什么都不做的EventLoop 一个EventLoop就是一个事件循环，下面将通过一个\"什么都不做的EventLoop\"来大致描述下muduo中EventLoop的功能。 “什么都不做的EventLoop\"有如下几个特点： one loop per thread意思是说每个线程最多只能有一个EventLoop对象。 EventLoop对象构造的时候，会检查当前线程是否已经创建了其他EventLoop对象，如果已创建，终止程序(LOG_FATAL) EventLoop构造函数会记住本对象所属线程(threadId_)。 创建了EventLoop对象的线程称为IO线程，其功能是运行事件循环(EventLoop::loop) ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:1:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"10.2 one loop per thread 这里指的是一个EventLoop只属于一个线程(但一个线程可以拥有多个EventLoop)，在muduo中，如果EventLoop一旦被创建，EventLoop会保持所属线程的一份tid拷贝，作为标识。如果该EventLoop被其他线程调用则会报错，muduo中使用EventLoop::assertInLoopThread()函数来判断该EventLoop对象是否是在所属线程中执行。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:1:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"10.3 事件循环 一个EventLoop里其实是调用了poll/epoll来跟踪所关注的文件描述符的，当有文件描述符上有事件发生时，EventLoop会得到那些发生事件的文件描述符信息。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:1:3","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"11. Channel Channel，可以理解为是一个\"通道”，该\"通道\"中绑定了一个文件描述符及其所关注事件、注册的读写事件等信息。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:2:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"11.1 Channel与文件描述符 一个Channel管理一个文件描述符，在创建Channel时需要指定： Channel::Channel(EventLoop* loop, int fd__) : loop_(loop), fd_(fd__), ... { } 该文件描述符的关注事件可以用如下代码表示： const int Channel::kNoneEvent = 0; //没有事件：0 const int Channel::kReadEvent = POLLIN | POLLPRI; //可读事件：3 const int Channel::kWriteEvent = POLLOUT; //可写事件：4 这些宏定义在poll.h头文件中： /* Event types that can be polled for. These bits may be set in `events' to indicate the interesting event types; they will appear in `revents' to indicate the status of the file descriptor. */ #define POLLIN 0x001 /* There is data to read. */ #define POLLPRI 0x002 /* There is urgent data to read. */ #define POLLOUT 0x004 /* Writing now will not block. */ 在Channel内部也定义了events_和revents_来标记文件描述符所关注的事件以及实际发生的事件，该方法和struct pollfd 结构体类似： int events_; // 关注的事件 int revents_; // poll/epoll返回的事件，即实际监听到发生的事件类型 muduo提供了下面这些函数来设置文件描述符关注事件： void enableReading() { events_ |= kReadEvent; update(); } void enableWriting() { events_ |= kWriteEvent; update(); } void disableWriting() { events_ \u0026= ~kWriteEvent; update(); } void disableAll() { events_ = kNoneEvent; update(); } 其中update函数的作用就是将该Channel及其绑定的文件描述符和EventLoop中的poll/epoll关联起来。 muduo也提供了下面函数来获取和设置文件描述符及其事件的状态，其中需要注意的是set_revents函数，该函数是被poll/epoll类中调用的： int fd() const { return fd_; } int events() const { return events_; } void set_revents(int revt) { revents_ = revt; } // used by pollers // int revents() const { return revents_; } bool isNoneEvent() const { return events_ == kNoneEvent; } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:2:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"11.2 设置监听回调函数 Channel中可以设置读、写、错误和关闭事件的回调函数，通过函数模板的方式： typedef boost::function\u003cvoid()\u003e EventCallback; typedef boost::function\u003cvoid(Timestamp)\u003e ReadEventCallback; ReadEventCallback readCallback_; EventCallback writeCallback_; EventCallback closeCallback_; EventCallback errorCallback_; void setReadCallback(const ReadEventCallback \u0026cb) { readCallback_ = cb; } void setWriteCallback(const EventCallback \u0026cb) { writeCallback_ = cb; } void setCloseCallback(const EventCallback \u0026cb) { closeCallback_ = cb; } void setErrorCallback(const EventCallback \u0026cb) { errorCallback_ = cb; } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:2:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"11.3 Channel与EventLoop关系 一个Channel一定会关联一个EventLoop，和文件描述符一样，在构造函数中需要传入。一旦关联该EventLoop，EventLoop就可对该Channel操作。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:2:3","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"11.4 响应事件 muduo中定义了该函数来响应Channel所绑定的文件描述符发生事件及其回调函数： //处理绑定的事件 void Channel::handleEvent(Timestamp receiveTime) { boost::shared_ptr\u003cvoid\u003e guard; if (tied_) { guard = tie_.lock(); //确定shared_ptr指针还存在 if (guard) { handleEventWithGuard(receiveTime); } } else { handleEventWithGuard(receiveTime); } } /** * poll函数的事件标志符值： * 常量 说明 POLLIN 普通或优先级带数据可读 POLLRDNORM 普通数据可读 POLLRDBAND 优先级带数据可读 POLLPRI 高优先级数据可读 POLLOUT 普通数据可写 POLLWRNORM 普通数据可写 POLLWRBAND 优先级带数据可写 POLLERR 发生错误 POLLHUP 对方描述符挂起 POLLNVAL 描述字不是一个打开的文件 * */ //开始选择性处理Channel对象绑定的事件 void Channel::handleEventWithGuard(Timestamp receiveTime) { eventHandling_ = true; //处于处理事件中 // close if ((revents_ \u0026 POLLHUP) \u0026\u0026 !(revents_ \u0026 POLLIN)) { if (logHup_) { LOG_WARN \u003c\u003c \"Channel::handle_event() POLLHUP\"; } //符合关闭套接字的事件，回调close函数 if (closeCallback_) closeCallback_(); } //Invalid polling request. if (revents_ \u0026 POLLNVAL) { LOG_WARN \u003c\u003c \"Channel::handle_event() POLLNVAL\"; } // error if (revents_ \u0026 (POLLERR | POLLNVAL)) { if (errorCallback_) errorCallback_(); } // read if (revents_ \u0026 (POLLIN | POLLPRI | POLLRDHUP)) { if (readCallback_) readCallback_(receiveTime); } // write if (revents_ \u0026 POLLOUT) { if (writeCallback_) writeCallback_(); } eventHandling_ = false; //事件已处理完成 } 该函数会根据revents_判断该文件描述符上实际发生的事件类型，然后调用相关的注册的回调函数。例如如果是有POLLIN(读事件)产生，那么将调用readCallback_回调函数。 那么什么时候handleEvent函数会执行呢，在poll/epoll返回时，EventLoop对象在loop循环中会拿到有事件发生的Channel集合，并逐一执行它们的handleEvent函数。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:2:4","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"12. Poller ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:3:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"12.1 Poller Poller是一个抽象类，指的是muduo封装的PollPoller、EPollPoller及其父类Poller的总称。在muduo中定义了一个Poller类，该类中定义了一些PollPoller和EPollPoller必须要实现的函数： virtual Timestamp poll(int timeoutMs, ChannelList* activeChannels) = 0; virtual void updateChannel(Channel* channel) = 0; virtual void removeChannel(Channel* channel) = 0; 一个Channel管理一个文件描述符fd的所有信息与操作，但如果要将文件描述符和poll/epoll关联和注册事件监听，Poller也需要关联Channel并提供相关操作的函数。但是由于poll/epoll的poll函数和操作的方法及其数据结构不同，所以这些具体的实现还是要放在PollPoller和EPollPoller中。 muduo提供了两种事件循环的类PollPoller和EPollPoller，同时也提供了该函数来选择使用哪一个： Poller *Poller::newDefaultPoller(EventLoop *loop) { if (::getenv(\"MUDUO_USE_POLL\")) { return new PollPoller(loop); } else { return new EPollPoller(loop); } } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:3:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"12.2 Poller分析 12.2.1 PollPoller和EventLoop关系 一个EventLoop关联一个PollPoller，Channel的update会调用EventLoop的update函数，而EventLoop又调用Poller相关的函数。EventLoop之所以能够\"事件循环\"也是其内部调用Poller的poll函数。 12.2.2 PollPoller和Channel的关系 Channel管理了一个文件描述符，在muduo中，一个Channel可以看作是一个文件描述符的\"代表\"，如果要操作一个文件描述符，则必须是通过该文件描述符对应的Channel。PollPoller需要监听和返回这些文件描述符上注册和实际发生的事件，所以必须提供操作Channel的函数和数据结构。下面这两个数据结构用于保存文件描述符及其Channel： typedef std::vector\u003cstruct pollfd\u003e PollFdList; typedef std::map\u003cint, Channel*\u003e ChannelMap; PollFdList pollfds_; ChannelMap channels_; pollfds_的作用非常明显，因为poll函数需要一个struct pollfd的数组地址，所以该结构是用于poll函数参数。 channels_则是用于管理注册的Channel的，key是Channel对应的文件描述符fd，value就是该Channel的地址，使用map数据结构可以很方便地对Channel进行查找和删除。 12.2.3 update 和 remove Channel 1. updateChannel 函数 由于需要更新一个Channel，所以该函数的参数只有Channel的一份指针： /** * 主要时将Channel负责的文件描述符(fd)注册到Poller对象中, 或更新Poller对象 */ void PollPoller::updateChannel(Channel *channel) { Poller::assertInLoopThread(); LOG_TRACE \u003c\u003c \"fd = \" \u003c\u003c channel-\u003efd() \u003c\u003c \" events = \" \u003c\u003c channel-\u003eevents(); if (channel-\u003eindex() \u003c 0) { // index \u003c 0说明是一个新的通道 // a new one, add to pollfds_ assert(channels_.find(channel-\u003efd()) == channels_.end()); struct pollfd pfd; pfd.fd = channel-\u003efd(); pfd.events = static_cast\u003cshort\u003e(channel-\u003eevents()); pfd.revents = 0; // channel-\u003erevents() pollfds_.push_back(pfd); int idx = static_cast\u003cint\u003e(pollfds_.size()) - 1; channel-\u003eset_index(idx); channels_[pfd.fd] = channel; //通过文件描述符(fd) 映射 Channel } else { // update existing one //已存在的Channel assert(channels_.find(channel-\u003efd()) != channels_.end()); assert(channels_[channel-\u003efd()] == channel); // index的取值必定在channels_.size()内 int idx = channel-\u003eindex(); assert(0 \u003c= idx \u0026\u0026 idx \u003c static_cast\u003cint\u003e(pollfds_.size())); /** * 更新pollfds_容器的信息(struct pollfd) */ struct pollfd \u0026pfd = pollfds_[idx]; // pfd.fd == -1 代表此Chanel不需被Poller::poll检测 assert(pfd.fd == channel-\u003efd() || pfd.fd == -channel-\u003efd() - 1); pfd.events = static_cast\u003cshort\u003e(channel-\u003eevents()); pfd.revents = 0; //如果不再关注该Channel中文件描述符事件，则直接将该文件描述符赋值为其相反数减一。 // 将一个通道暂时更改为不关注事件，但不从Poller中移除该通道 if (channel-\u003eisNoneEvent()) { // ignore this pollfd // 暂时忽略该文件描述符的事件 // 这里pfd.fd 可以直接设置为-1 pfd.fd = -channel-\u003efd() - 1; // 这样子设置是为了removeChannel优化 } } } channel-\u003eindex() \u003c 0分支： 当一个Channel创建后默认设置自身的index_为-1，所以对于新创建的Channel如果被更新，那么一定是走channel-\u003eindex() \u003c 0分支的。既然该Channel是刚创建并且是第一次和PollPoller关联，那么PollPoller中一定不会存在该Channel的信息，所以使用了该断言。 再接下来就是构造一个pollfd结构体并将该结构体的文件信息通过Channel保存起来，供下次poll函数调用。 需要注意的是，上面Channel的index_被设置为当前pollfds_的实际长度减一，这也是为了方便快速获取到pollfds_向量中的对应的文件描述符，有了该文件描述又可以很快从channels_中获取到该Channel，这个过程的代价很小，几乎不需要遍历。 接下来分析channel-\u003eindex() \u003e 0 的情况： 发生这种情况也意味着该Channel之前已经注册到该PollPoller中了，但是由于一些原因需要修改该文件描述符的关注事件，对于这种情况的Channel将调用else分支代码。 代码中两个assert断言该Channel是否已经和PollPoller关联，如果关联则取出该pollfd数组中的该Channel对应的文件描述符及其结构体，更新该结构体中文件描述符监听事件。如果不再关注该Channel中文件描述符事件，则直接将该文件描述符赋值为其相反数减一。 2. removeChannel 函数 使用该函数之前一般需要调用 updateChannel 函数设置不再关注该Channel对应的文件描述符上的事件。 该函数定义如下： void PollPoller::removeChannel(Channel *channel) { Poller::assertInLoopThread(); LOG_TRACE \u003c\u003c \"fd = \" \u003c\u003c channel-\u003efd(); assert(channels_.find(channel-\u003efd()) != channels_.end()); assert(channels_[channel-\u003efd()] == channel); assert(channel-\u003eisNoneEvent()); int idx = channel-\u003eindex(); assert(0 \u003c= idx \u0026\u0026 idx \u003c static_cast\u003cint\u003e(pollfds_.size())); const struct pollfd \u0026pfd = pollfds_[idx]; (void)pfd; assert(pfd.fd == -channel-\u003efd() - 1 \u0026\u0026 pfd.events == channel-\u003eevents()); size_t n = channels_.erase(channel-\u003efd()); assert(n == 1); (void)n; if (implicit_cast\u003csize_t\u003e(idx) == pollfds_.size() - 1) { pollfds_.pop_back(); } else { // 这里移除的算法复杂度是O(1)，将待删除元素与最后一个元素交换再pop_back int channelAtEnd = pollfds_.back().fd; iter_swap(pollfds_.begin() + idx, pollfds_.end() - 1); //不再关注该Channel中文件描述符事件，通过这种方式获取原有的下标(key)位置 if (channelAtEnd \u003c 0) { channelAtEnd = -channelAtEnd - 1; } channels_[channelAtEnd]-\u003eset_index(idx); pollfds_.pop_back(); } } 首先三个断言确认该Channel已经和PollPoller关联而且确认该Channel上的文件描述符事件不再关注，然后找到该Channel文件描述符在pollfds_数组中的位置，将该Channel从Channels_中去除，将该文件描述符对应的pollfd从pollfds_数组中去除。 从pollfs_数组中去除一个pollfd，Muduo使用了一个技巧，如果要","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:3:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"12.3 EPollPoller 分析 12.3.1 EPollPoller和EventLoop关系 一个EventLoop关联一个EPollPoller，Channel的update会调用EventLoop的update函数，而EventLoop又调用Poller相关的函数。EventLoop之所以能够\"事件循环\"也是其内部调用Poller的poll函数。 12.3.2 EPollPoller和Channel的关系 Channel管理了一个文件描述符，在muduo中，一个Channel可以看作是一个文件描述符的\"代表\"，如果要操作一个文件描述符，则必须是通过该文件描述符对应的Channel。EPollPoller需要监听和返回这些文件描述符上注册和实际发生的事件，所以必须提供操作Channel的函数和数据结构。下面这两个数据结构用于保存文件描述符及其Channel： typedef std::vector\u003cstruct epoll_event\u003e EventList; typedef std::map\u003cint, Channel*\u003e ChannelMap; EventList events_; ChannelMap channels_; EventList events_的作用非常明显，因为epoll函数需要一个struct epoll_event的数组地址，所以该结构是用于epoll_wait函数参数。ChannelMap channels_则是用于管理注册的Channel的，key是Channel对应的文件描述符fd，value就是该Channel的地址，使用map数据结构可以很方便的对Channel进行查找和操作。 12.3.3 update 和 remove Channel 1. updateChannel 函数 //将Channel加入epoll中管理，updateChannel方法一定是I/O线程调用的 void EPollPoller::updateChannel(Channel *channel) { Poller::assertInLoopThread(); LOG_TRACE \u003c\u003c \"fd = \" \u003c\u003c channel-\u003efd() \u003c\u003c \" events = \" \u003c\u003c channel-\u003eevents(); const int index = channel-\u003eindex(); if (index == kNew || index == kDeleted) { // a new one, add with EPOLL_CTL_ADD int fd = channel-\u003efd(); if (index == kNew) { assert(channels_.find(fd) == channels_.end()); channels_[fd] = channel; } else // index == kDeleted { //也就是说，当Channel对象的无事件，可以通过index_来标识为删除状态，并不会从channels_容器中移除 assert(channels_.find(fd) != channels_.end()); assert(channels_[fd] == channel); } channel-\u003eset_index(kAdded); //设置Channel对象为添加状态 update(EPOLL_CTL_ADD, channel); //添加到epoll中监视 } else { // update existing one with EPOLL_CTL_MOD/DEL //更新已存在的Channel描述符，修改或删除 int fd = channel-\u003efd(); (void)fd; assert(channels_.find(fd) != channels_.end()); assert(channels_[fd] == channel); assert(index == kAdded); //当Channel对象不绑定事件，那么就从epoll的监视中移除，并设置Channel对象为删除状态 if (channel-\u003eisNoneEvent()) { update(EPOLL_CTL_DEL, channel); channel-\u003eset_index(kDeleted); } else { //更新epoll中监视的Channel对象的信息 update(EPOLL_CTL_MOD, channel); } } } 这个函数的作用和PollPoller函数作用是一样的。当一个Channel的index_为-1时则说明这个Channel并没有和EPollPoller关联，如果index_为2，则说明该通道被取消过关注，如果为1则说明该Channel已经和EPollPoller关联，需要更新相关文件描述符的一些监听事件： namespace { const int kNew = -1; //还没有和EPollPoller关联 const int kAdded = 1; //该Channel已经和EPollPoller关联 const int kDeleted = 2; //该通道被取消关注 } 如果index_是kNew或者kDeleted，则说明需要将该通道和该EPollPoller关联，设置index_为kAdded，然后调用update函数将该通道和EPollPoller关联： //更新Channel对象绑定的事件 void EPollPoller::update(int operation, Channel *channel) { struct epoll_event event; bzero(\u0026event, sizeof event); event.events = channel-\u003eevents(); event.data.ptr = channel; int fd = channel-\u003efd(); if (::epoll_ctl(epollfd_, operation, fd, \u0026event) \u003c 0) { if (operation == EPOLL_CTL_DEL) { LOG_SYSERR \u003c\u003c \"epoll_ctl op=\" \u003c\u003c operation \u003c\u003c \" fd=\" \u003c\u003c fd; } else { LOG_SYSFATAL \u003c\u003c \"epoll_ctl op=\" \u003c\u003c operation \u003c\u003c \" fd=\" \u003c\u003c fd; } } } update函数内部也是调用了epoll_ctl函数。需要注意的是，epoll_event里并没有设置文件描述符，而是用了event.data.ptr指针保存了Channel，毕竟Channel中包含的文件描述符信息更加丰富。 如果index_已经是added状态，那么判断该Channel中文件描述符是否被设置为\"不关注\"，如果是的话，直接调用updata函数将该文件描述符移除epoll事件监听，否则更新该文件描述符结构的events监听事件。 2. removeChannel 函数 // 将Channel对象从channels_容器和epoll监控中移除，此操作必须是I/O线程调用的 void EPollPoller::removeChannel(Channel *channel) { Poller::assertInLoopThread(); int fd = channel-\u003efd(); LOG_TRACE \u003c\u003c \"fd = \" \u003c\u003c fd; assert(channels_.find(fd) != channels_.end()); assert(channels_[fd] == channel); assert(channel-\u003eisNoneEvent()); //要移除的Channel对象本身一定是无事件的 int index = channel-\u003eindex(); // 要移除的Channel对象应该就可能处于关联状态、也可能处于被取消关注状态(kDeleted) assert(index == kAdded || index == kDeleted); size_t n = channels_.erase(fd); (void)n; assert(n == 1); // 处于关联状态，说明epoll还在监视它 if (index == kAdded) { update(EPOLL_CTL_DEL, channel); } // 重新设置Channel为未被管理的初始状态 channel-\u003eset_index(kNew); } 该函数将取消对Channel对应的文件描述的事件监听，然后将该Channel从channels_中删除。 12.3.4 poll poll函数是在EventLoop中调用的，EventLoop希望通过该函数获取到当前的活动Channel(文件描述符上有事件发生)集合，所以会传入一个ChannelList* activeChannels作为poll的参数，该结构是一个vector集合，保存Channel的地址，定义如下： typedef std::vector\u003cChannel*\u003e ChannelList; poll函数定义如下： Timestamp EPollPoller::poll(int timeoutMs, ChannelList *activeChannels) { //活跃的事件数量 int numEvents ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:3:3","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"13. 定时器 muduo的定时器由三个类实现，TimerId、Timer、TimerQueue，用户只能看到第一个类，其它两个都是内部实现细节。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:4:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"13.1 timerfd_*系列定时器 muduo选择了timerfd_*系列作为定时器。 下面这组函数便是操作timerfd的系统调用： #include \u003csys/timerfd.h\u003e int timerfd_create(int clockid, int flags); int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value); int timerfd_gettime(int fd, struct itimerspec *curr_value) timerfd_create，它是用来创建一个定时器描述符timerfd 第一个参数：clockid指定时间类型，有两个值： CLOCK_REALTIME :Systemwide realtime clock. 系统范围内的实时时钟 CLOCK_MONOTONIC:以固定的速率运行，从不进行调整和复位 ,它不受任何系统time-of-day时钟修改的影响 第二个参数：flags可以是0或者O_CLOEXEC/O_NONBLOCK。 返回值：timerfd(文件描述符) timerfd_settime，该函数作用是用来启动或关闭有fd指定的定时器。在讲解该函数前，先理解两个相关结构体： struct timespec { time_t tv_sec; /* Seconds */ long tv_nsec; /* Nanoseconds */ }; struct itimerspec { struct timespec it_interval; /* Interval for periodic timer */ struct timespec it_value; /* Initial expiration */ }; 第二个结构体itimerspec就是timerfd要设置的超时结构体，它的成员it_value表示定时器第一次超时时间，it_interval表示之后的超时时间即每隔多长时间超时 下面正式分析该函数的参数和返回值： 参数： fd：timerfd，有timerfd_create函数返回 flags：1代表设置的是绝对时间；为0代表相对时间 fnew_value：指定新的超时时间，设定new_value.it_value非零则启动定时器，否则关闭定时器，如果new_value.it_interval为0，则定时器只定时一次，即初始那次，否则之后每隔设定时间超时一次 old_value：不为null，则返回定时器这次设置之前的超时时间 timerfd_gettime，此函数用于获得定时器距离下次超时还剩下的时间。如果调用时定时器已经到期，并且该定时器处于循环模式(设置超时时间时struct itimerspec::it_interval不为0)，那么调用此函数之后定时器重新开始计时。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:4:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"13.2 Timer 分析 一个定时器会在某一个时刻执行某个任务，而且有可能是\"定时执行\"，所以，一个Timer里封装了该Timer的超时时间(定时时间)、任务的执行周期等信息： const TimerCallback callback_; //定时执行函数 Timestamp expiration_; // 超时时间 const double interval_; // 执行间隔 const bool repeat_; // 是否重复定时执行任务 const int64_t sequence_; // 序列号，每个Tmier的序列号都不一样 其中sequence_是通过对一个静态变量的原子增加来保证独一无二的： static AtomicInt64 s_numCreated_; 该原子操作会在Timer构造函数初始化列表中完成初始化： Timer(const TimerCallback\u0026 cb, Timestamp when, double interval) : callback_(cb), expiration_(when), interval_(interval), repeat_(interval \u003e 0.0), sequence_(s_numCreated_.incrementAndGet()) { } Timer也提供了一些列函数来操作和获取这些变量值： void run() const { callback_(); } //触发事件的时间戳 Timestamp expiration() const { return expiration_; } bool repeat() const { return repeat_; } int64_t sequence() const { return sequence_; } void restart(Timestamp now); static int64_t numCreated() { return s_numCreated_.get(); } 如果要重新设置该Timer的超时时间，可以通过下面这个函数： /** * 如果是重复的累加的，加入累加的时间重新设置到期时间，否则设置为失效时间 */ void Timer::restart(Timestamp now) { if (repeat_) { // 重新计算下一个超时时刻 expiration_ = addTime(now, interval_); } else { //设置无效的时间 expiration_ = Timestamp::invalid(); } } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:4:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"13.3 TimerId 分析 TimerId 中保存了一个Timer，以及该TimerId的序列号，同时将TimerQueue 设置为友元类： class Timer; /// /// An opaque identifier, for canceling Timer. /// class TimerId : public muduo::copyable { public: TimerId() : timer_(NULL), sequence_(0) {} TimerId(Timer *timer, int64_t seq) : timer_(timer), sequence_(seq) {} // default copy-ctor, dtor and assignment are okay friend class TimerQueue; private: Timer *timer_; int64_t sequence_; }; ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:4:3","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"13.4 TimerQueue 13.4.1 TimerQueue 设计原理 一个TimerQueue 会关联一个EventLoop，一个TimerQueue中会绑定一个文件描述符timerfd以及Channel。该TimerQueue中保存众多的Timer，并且将这些Timer根据其超时时间从小到大放入一个集合中，其中最近超时时间将设置为timerfd的超时时间(也就是说将最近超时时间关联到timerfd上)，到了该时间，timerfd上会有读事件发生，然后定时器会将定时在该超时时间到真正处理该读事件之间的Timer获取到，执行这些Timer的定时函数。 // FIXME: use unique_ptr\u003cTimer\u003e instead of raw pointers. // unique_ptr是C++ 11标准的一个独享所有权的智能指针 // 无法得到指向同一对象的两个unique_ptr指针 // 但可以进行移动构造与移动赋值操作，即所有权可以移动到另一个对象(而非拷贝构造) typedef std::pair\u003cTimestamp, Timer *\u003e Entry; typedef std::set\u003cEntry\u003e TimerList; typedef std::pair\u003cTimer *, int64_t\u003e ActiveTimer; typedef std::set\u003cActiveTimer\u003e ActiveTimerSet; EventLoop *loop_; // 所属EventLoop const int timerfd_; Channel timerfdChannel_; // Timer list sorted by expiration // set中的元素都是排好序的, 用于存储Timer，同时将Timer的到期时间戳作为key TimerList timers_; // timers_是按到期时间排序 // for cancel() // timers_与activeTimers_保存的是相同的数据 =》 利于操作，空间换效率吧？？？ // timers_是按到期时间排序，activeTimers_是按对象地址排序 ActiveTimerSet activeTimers_; bool callingExpiredTimers_; //用来确定是否正在调用回调函数的定时器/* atomic */ ActiveTimerSet cancelingTimers_; // 保存的是被取消的定时器 TimerQueue 的构造函数如下： /** * 一个TimerQueue只对应一个Eventloop和一个内部构造的Channel(构造对象时，默认绑定一个定时器对象timerfd_) * 同时设置Channel的回调函数TimerQueue::handleRead */ TimerQueue::TimerQueue(EventLoop *loop) : loop_(loop), timerfd_(createTimerfd()), timerfdChannel_(loop, timerfd_), timers_(), callingExpiredTimers_(false) { timerfdChannel_.setReadCallback(boost::bind(\u0026TimerQueue::handleRead, this)); // we are always reading the timerfd, we disarm it with timerfd_settime. timerfdChannel_.enableReading(); } 构造函数中使用了createTimerfd来创建一个定时器文件描述符，该函数定义如下： /** * 创建定时器，生成一个定时器对象，返回与之关联的文件描述符timerfd。 */ int createTimerfd() { int timerfd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC); if (timerfd \u003c 0) { LOG_SYSFATAL \u003c\u003c \"Failed in timerfd_create\"; } return timerfd; } 构造函数中Channel绑定的\"读事件\"回调函数是TimerQueue::handleRead，该函数定义如下： /** * I/O线程才可调用 * 用来设置关联的Channel的回调函数 */ void TimerQueue::handleRead() { loop_-\u003eassertInLoopThread(); Timestamp now(Timestamp::now()); // 清除该事件，避免一直触发，并记录触发TimerQueue::handleRead回调函数的时间 readTimerfd(timerfd_, now); // 获取该时刻之前所有的定时器列表(即超时定时器列表) std::vector\u003cEntry\u003e expired = getExpired(now); callingExpiredTimers_ = true; cancelingTimers_.clear(); // safe to callback outside critical section for (std::vector\u003cEntry\u003e::iterator it = expired.begin(); it != expired.end(); ++it) { // 这里回调定时器处理函数 it-\u003esecond-\u003erun(); } callingExpiredTimers_ = false; // 不是一次性定时器，需要重启 reset(expired, now); } 如果定时器超时，那么将执行该回调函数，该回调函数会调用readTimerfd函数先处理文件描述符事件，readTimerfd 函数定义如下： // 清除定时器，避免一直触发，并记录传入的时间戳 void readTimerfd(int timerfd, Timestamp now) { uint64_t howmany; ssize_t n = ::read(timerfd, \u0026howmany, sizeof howmany); LOG_TRACE \u003c\u003c \"TimerQueue::handleRead() \" \u003c\u003c howmany \u003c\u003c \" at \" \u003c\u003c now.toString(); if (n != sizeof howmany) { LOG_ERROR \u003c\u003c \"TimerQueue::handleRead() reads \" \u003c\u003c n \u003c\u003c \" bytes instead of 8\"; } } 在处理完文件描述符读事件后调用getExpired函数获取从文件描述符事件发生到当前时间内超时的Timer，然后遍历该集合，获取到Timer并执行其run函数(run函数中执行的是Timer真正的定时函数)。处理完这些超时的Timer后调用reset函数来重置这些Timer的定时任务，因为有些Timer是设置为循环执行的，所以还要重新设置它们的下一次执行时间。 13.4.2 向TimerQueue 中添加一个Timer TimerQueue使用addTimer函数来向队列中添加一个Timer： /** * 添加一个新Timer，并及时更新； * 如果TimerList中元素只有一个或插入的Timer最快到期，马上重新设置TimerQueue对象绑定的timerfd的超时时间 */ TimerId TimerQueue::addTimer(const TimerCallback \u0026cb, Timestamp when, double interval) { /** * 该对象将存储到TimerList中 * =\u003e std::set\u003cstd::pair\u003cTimestamp, Timer*\u003e\u003e TimerList; */ Timer *timer = new Timer(cb, when, interval); loop_-\u003erunInLoop(boost::bind(\u0026TimerQueue::addTimerInLoop, this, timer)); // addTimerInLoop(timer); return TimerId(timer, timer-\u003esequence()); } 该函数需要传入一个定时回调函数，一个超时时间戳和定时周期，TimerCallback的原型如下所示： typedef boost::function\u003cvoid()\u003e TimerCallback; 创建一个Timer，然后通过EventLoop调用TimerQueue::addTimerInLoop函数，最后TimerQueue::addTimer返回一个TimerId。runInLoop的实现细节在后面章节会解释，addTimerInLoop函数的定义如下： /** * I/O线程才可调用 */ void TimerQueue::addTimerInLoop(Timer *timer) { loop_-\u003eassertInLoopThread(); // 插入一个定时器，有可能会使得最早到期的定时器发生改变 bool earliestChanged = insert(timer); if (earliestChanged) { // 重置定时器","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:4:4","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"14. 深入 EventLoop 已经分析过一个\"什么都不做的EventLoop\"，muduo中的EventLoop有如下几个特点： one loop per thread意思是说每个线程最多只能有一个EventLoop对象。 EventLoop对象构造的时候，会检查当前线程是否已经创建了其他EventLoop对象，如果已创建，终止程序(LOG_FATAL) EventLoop构造函数会记住本对象所属线程(threadId_)。 创建了EventLoop对象的线程称为IO线程，其功能是运行事件循环(EventLoop::loop) 下面将深入具体分析muduo中的EventLoop的实现。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:5:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"14.1 EventLoop 与 Channel “一个Channel会关联一个EventLoop”，当Channel设置了监听文件描述符关注事件类型后会调用update函数，Channel中的update函数也是间接调用EventLoop的updateChannel函数，然后又间接调用Poller的updateChannel函数，该函数将会将该Channel及其相关文件描述符和Poller的事件监听联系起来。 //将Chanel注册到Poller对象的polldfs数组中 void Channel::update() { loop_-\u003eupdateChannel(this); } void EventLoop::updateChannel(Channel *channel) { assert(channel-\u003eownerLoop() == this); assertInLoopThread(); poller_-\u003eupdateChannel(channel); } 同样地，Channel的remove函数也是间接调用EventLoop的removeChannel函数来删除自身，Poller的removeChannel函数会取消该Channel及其文件描述符的事件监听，并不再保存该Channel及其文件描述符任何信息。 // 调用这个函数之前确保调用disableAll void Channel::remove() { assert(isNoneEvent()); loop_-\u003eremoveChannel(this); } void EventLoop::removeChannel(Channel *channel) { assert(channel-\u003eownerLoop() == this); assertInLoopThread(); if (eventHandling_) { assert(currentActiveChannel_ == channel || std::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end()); } poller_-\u003eremoveChannel(channel); } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:5:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"14.2 EventLoop 与 TimerQueue EventLoop中持有一个TimerQueue，并在构造函数中完成了该TimerQueue的初始化： boost::scoped_ptr\u003cTimerQueue\u003e timerQueue_; EventLoop::EventLoop() : looping_(false), ... timerQueue_(new TimerQueue(this)), ... { ... } 接下来是一组定时器操作函数，用于添加定时器任务： EventLoop.h /// /// Runs callback at 'time'. /// Safe to call from other threads. /// //直接回调 TimerId runAt(const Timestamp \u0026time, const TimerCallback \u0026cb); /// /// Runs callback after @c delay seconds. /// Safe to call from other threads. /// //延期回调 TimerId runAfter(double delay, const TimerCallback \u0026cb); /// /// Runs callback every @c interval seconds. /// Safe to call from other threads. /// //以interval的频率回调 TimerId runEvery(double interval, const TimerCallback \u0026cb); /// /// Cancels the timer. /// Safe to call from other threads. /// void cancel(TimerId timerId); EventLoop.cpp TimerId EventLoop::runAt(const Timestamp \u0026time, const TimerCallback \u0026cb) { return timerQueue_-\u003eaddTimer(cb, time, 0.0); } TimerId EventLoop::runAfter(double delay, const TimerCallback \u0026cb) { Timestamp time(addTime(Timestamp::now(), delay)); return runAt(time, cb); } TimerId EventLoop::runEvery(double interval, const TimerCallback \u0026cb) { Timestamp time(addTime(Timestamp::now(), interval)); return timerQueue_-\u003eaddTimer(cb, time, interval); } void EventLoop::cancel(TimerId timerId) { return timerQueue_-\u003ecancel(timerId); } 本质上这些函数也是调用了TimerQueue的addTimer和cancel函数，需要关注的是addTimer和cancel函数内部都是通过EventLoop::runInLoop函数调用的： /** * 添加一个新Timer，并及时更新； * 如果TimerList中元素只有一个或插入的Timer最快到期，马上重新设置TimerQueue对象绑定的timerfd的超时时间 */ TimerId TimerQueue::addTimer(const TimerCallback \u0026cb, Timestamp when, double interval) { /** * 该对象将存储到TimerList中 * std::set\u003cstd::pair\u003cTimestamp, std::unique_ptr\u003cTimer\u003e\u003e\u003e */ Timer *timer = new Timer(cb, when, interval); loop_-\u003erunInLoop(boost::bind(\u0026TimerQueue::addTimerInLoop, this, timer)); // addTimerInLoop(timer); return TimerId(timer, timer-\u003esequence()); } void TimerQueue::cancel(TimerId timerId) { loop_-\u003erunInLoop(boost::bind(\u0026TimerQueue::cancelInLoop, this, timerId)); // cancelInLoop(timerId); } 使用EventLoop::runInLoop能够保证该bind函数是在EventLoop所在线程内执行的，哪怕这个函数是在别的线程里被调用，关于EventLoop::runInLoop函数，后面的章节再分析它是如何实现跨线程安全调用的。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:5:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"14.3 EventLoop 与 Poller 一个EventLoop持有一个poller： boost::scoped_ptr\u003cPoller\u003e poller_; EventLoop::EventLoop() : looping_(false), ... poller_(Poller::newDefaultPoller(this)), ... { ... } Poller::newDefaultPoller会根据系统环境来选择是使用PollPoller还是EPollPoller： Poller *Poller::newDefaultPoller(EventLoop *loop) { if (::getenv(\"MUDUO_USE_POLL\")) { return new PollPoller(loop); } else { return new EPollPoller(loop); } } EventLoop的核心函数loop便是调用了Poller的loop函数： // 事件循环，该函数不能跨线程调用 // 只能在创建该对象的线程中调用 void EventLoop::loop() { assert(!looping_); // 断言当前处于创建该对象的线程中 assertInLoopThread(); looping_ = true; quit_ = false; LOG_TRACE \u003c\u003c \"EventLoop \" \u003c\u003c this \u003c\u003c \" start looping\"; //::poll(NULL, 0, 5*1000); while (!quit_) { activeChannels_.clear(); //执行完Poller::poll()的时间 pollReturnTime_ = poller_-\u003epoll(kPollTimeMs, \u0026activeChannels_); //++iteration_; if (Logger::logLevel() \u003c= Logger::TRACE) { printActiveChannels(); } // TODO sort channel by priority eventHandling_ = true; //标识事件正在处理 for (ChannelList::iterator it = activeChannels_.begin(); it != activeChannels_.end(); ++it) { currentActiveChannel_ = *it; currentActiveChannel_-\u003ehandleEvent(pollReturnTime_); //事件处理 } currentActiveChannel_ = NULL; eventHandling_ = false; //标识事件已处理完成 // 让IO线程也能执行一些计算任务，IO不忙的时候，处于阻塞状态 doPendingFunctors(); // 执行其他线程或者本线程添加的一些回调任务 } LOG_TRACE \u003c\u003c \"EventLoop \" \u003c\u003c this \u003c\u003c \" stop looping\"; looping_ = false; } 该函数通过调用Poller的poll函数，将活跃Channel保存到activeChannels_中，然后遍历这些Channel，执行它们的handleEvent函数，最后执行doPendingFunctors函数，该函数将在下一节介绍。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:5:3","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"14.4 跨线程执行函数 为了实现跨线程调用函数，muduo使用了如下数据结构： bool callingPendingFunctors_; //判断是否IO线程处理一些回调任务中=\u003ependingFunctors_ int wakeupFd_; // 用于eventfd // unlike in TimerQueue, which is an internal class, // we don't expose Channel to client. boost::scoped_ptr\u003cChannel\u003e wakeupChannel_; // 该通道将会纳入poller_来管理 std::vector\u003cFunctor\u003e pendingFunctors_; // @BuardedBy mutex_ 即将发生的回调，即在IO线程中执行需要执行回调函数集合 TimerQueue的更新和删除Timer会用到EventLoop::runInLoop函数，该函数的实现如下： // 在I/O线程中执行某个回调函数，该函数可以跨线程调用 void EventLoop::runInLoop(const Functor \u0026cb) { if (isInLoopThread()) { // 如果是当前IO线程调用runInLoop，则同步调用cb cb(); } else { // 如果是其它线程调用runInLoop，则异步地将cb添加到队列，以便让EventLoop所在的线程执行这个回调函数 queueInLoop(cb); } } 以更新Timer为例： loop_-\u003erunInLoop(boost::bind(\u0026TimerQueue::addTimerInLoop, this, timer)); 如果该代码时是在EventLoop所在线程中执行，那么TimerQueue::addTimerInLoop会立刻执行，否则TimerQueue::addTimerInLoop将通过queueInLoop函数送入到待执行函数队列中，queueInLoop定义如下： void EventLoop::queueInLoop(const Functor \u0026cb) { { MutexLockGuard lock(mutex_); pendingFunctors_.push_back(cb); } /** * 1. 调用queueInLoop的线程不是IO线程需要唤醒 * 2. 或者调用queueInLoop的线程是IO线程，并且此时正在调用任务队列(pendingFunctors_)，需要唤醒。 * =》 因为I/O处于callingPendingFunctors_状态，任务队列(pendingFunctors_)中的任务执行完可能会处于阻塞状态(poll没事件发生)，新加入的任务无法执行。 * * 只有I/O线程的事件回调中调用queueInLoop才不需要唤醒 */ if (!isInLoopThread() || callingPendingFunctors_) { wakeup(); } } 该函数会判断是否是在EventLoop所处线程中执行，如果不是的话则调用wakeup()函数。 先解释下跨线程调用的原理：一个EventLoop中有一个wakeupFd_文件描述符(eventfd 是一个比 pipe 更高效的线程间事件通知机制，一方面它比 pipe 少用一个 file descripor，节省了资源；另一方面，eventfd 的缓冲区管理也简单得多，全部\"buffer\" 只有定长8 bytes，不像 pipe 那样可能有不定长的真正 buffer)，该文件描述符在构造函数初始化列表中完成初始化： int createEventfd() { int evtfd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC); if (evtfd \u003c 0) { LOG_SYSERR \u003c\u003c \"Failed in eventfd\"; abort(); } return evtfd; } EventLoop::EventLoop() : looping_(false), ... wakeupFd_(createEventfd()), ... { ... } 而且EventLoop也为该wakeuFd_文件描述符提供了一个Channel，该Channel的生命周期由EventLoop对象负责： boost::scoped_ptr\u003cChannel\u003e wakeupChannel_; 该Channel也在构造函数中完成了初始化工作： EventLoop::EventLoop() : looping_(false), ... wakeupFd_(createEventfd()), wakeupChannel_(new Channel(this, wakeupFd_)), ... { ... wakeupChannel_-\u003esetReadCallback( boost::bind(\u0026EventLoop::handleRead, this)); // we are always reading the wakeupfd //这里设置会将wakeupChannel_注册到Poller对象中，实现事件循环 wakeupChannel_-\u003eenableReading(); } 该Channel也加入到了Poller事件监听中，并且设置了\"读事件\"回调函数为EventLoop::handleRead： // eventfd 事件处理函数 void EventLoop::handleRead() { uint64_t one = 1; ssize_t n = sockets::read(wakeupFd_, \u0026one, sizeof one); if (n != sizeof one) { LOG_ERROR \u003c\u003c \"EventLoop::handleRead() reads \" \u003c\u003c n \u003c\u003c \" bytes instead of 8\"; } } 现在回到queueInLoop函数中，可以正式介绍wake()函数了，wakeup函数功能就是向wakeupFd_写入东西，然后促使Poller的poll函数返回： // 唤醒，写uint64_t类型的字节就可产生可读事件，达到唤醒的目的 void EventLoop::wakeup() { uint64_t one = 1; // ssize_t n = sockets::write(wakeupFd_, \u0026one, sizeof one); ssize_t n = ::write(wakeupFd_, \u0026one, sizeof one); if (n != sizeof one) { LOG_ERROR \u003c\u003c \"EventLoop::wakeup() writes \" \u003c\u003c n \u003c\u003c \" bytes instead of 8\"; } } void EventLoop::loop() { ... while (!quit_) { activeChannels_.clear(); pollReturnTime_ = poller_-\u003epoll(kPollTimeMs, \u0026activeChannels_); ... doPendingFunctors(); } ... } 然后进而调用doPendingFunctors函数，在该函数中执行这些跨线程调用的\"未决函数\"： //在IO线程中执行一些回调任务 void EventLoop::doPendingFunctors() { std::vector\u003cFunctor\u003e functors; callingPendingFunctors_ = true; { MutexLockGuard lock(mutex_); //可以减小临界区的长度(意味着不会阻塞其它线程的queueInLoop())，另一方面，也避免了死锁(因为Functor可能再次调用queueInLoop()) functors.swap(pendingFunctors_); } for (size_t i = 0; i \u003c functors.size(); ++i) { functors[i](); } callingPendingFunctors_ = false; } 这样即使是跨线程调用某些函数，这些函数也不会立刻执行，而是存入该pendingFunctors_集合中等待wake，然后在EventLoop线程中\"打包\"执行。 需要注意的是： 不是简单地在临界区内依次调用Functor，而是把回调列表swap到functors中，这样一方面减小了临界区的长度(意味着不会阻塞其它线程的queueInLoop())，另一方面，也避免了死锁(因为Functor可能再次调用queueInLoop()) 由于doPendingFunctors()调用的Functor可能再次调用queueInLoop(cb)，这时，queueInLoop()就必须wakeup()，否则新增的cb可能就不能及时调用了 muduo没有反复执行doPendingFunctors()直到pendingFunctors为空，这是有意的，否则IO线程可能陷入死循环，无法处理IO事件。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:5:4","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"14.5 析构函数与资源销毁 整个EventLoop中创建了如下资源： EventLoop::EventLoop() : looping_(false), ... poller_(Poller::newDefaultPoller(this)), timerQueue_(new TimerQueue(this)), wakeupFd_(createEventfd()), wakeupChannel_(new Channel(this, wakeupFd_)), ... { ... } 然而这些资源除了wakeupFd_以外都是使用智能指针来管理的： boost::scoped_ptr\u003cPoller\u003e poller_; boost::scoped_ptr\u003cTimerQueue\u003e timerQueue_; int wakeupFd_; // 用于eventfd // unlike in TimerQueue, which is an internal class, // we don't expose Channel to client. boost::scoped_ptr\u003cChannel\u003e wakeupChannel_; // 该通道将会纳入poller_来管理 所以析构函数只需要释放wakeupFd_文件描述符即可： EventLoop::~EventLoop() { //析构，EventLoop对象一定不会是looping状态 assert(!looping_); ::close(wakeupFd_); t_loopInThisThread = nullptr; } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:5:5","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"15. muduo 事件监听总结 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:6:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"15.1 Channel及其文件描述符如何加入到Poller中 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:6:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"15.2 EventLoop如何获取活跃的Channel并处理相关事件 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:6:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"15.3 EventLoop如何处理定时器 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:6:3","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"15.4 EventLoop与跨线程调用函数 调用queueInLoop的线程不是当前IO线程需要唤醒 或者调用queueInLoop的线程是当前IO线程，并且此时正在调用pending functor，需要唤醒 只有IO线程的事件回调中调用queueInLoop才不需要唤醒 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:6:4","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"16. EventLoopThread 任何一个线程，只要创建并运行了EventLoop，都称之为IO线程，所以IO线程不一定是主线程。 muduo并发模型one loop per thread + threadpool，为了方便今后使用，定义了EventLoopThread类，该类封装了IO线程。EventLoopThread创建了一个线程，然后在线程函数中创建了一个EvenLoop对象并调用EventLoop::loop。 由于该EventLoopThread类会在一个线程中启动一个EventLoop，所以持有如下变量： EventLoop* loop_; Thread thread_; 构造函数： EventLoopThread::EventLoopThread(const ThreadInitCallback\u0026 cb) : loop_(NULL), exiting_(false), thread_(boost::bind(\u0026EventLoopThread::threadFunc, this)), mutex_(), cond_(mutex_), callback_(cb) { } 从构造函数中可以看出，该EventLoop默认是没有初始化的，线程绑定的执行函数是EventLoopThread::threadFunc。除此之外，构造函数中还初始化了互斥锁和条件变量，它们作用会在后面分析。 构造函数中还传入了一个ThreadInitCallback类型的函数对象： typedef boost::function\u003cvoid(EventLoop*)\u003e ThreadInitCallback; ThreadInitCallback callback_; 这是用作线程启动初始化执行的用户函数，如果用户想在线程初始化时执行一些函数，那么就可以在EventLoopThread构造函数中传入该函数，默认情况下EventLoopThread会创建一个空函数作为线程初始化函数： EventLoopThread(const ThreadInitCallback \u0026cb = ThreadInitCallback()); 那么，如何启动一个IO线程呢？使用EventLoopThread::startLoop便可以\"启动\"一个IO线程，这里的\"启动\"指的是启动IO线程，而不是线程，因为构造函数在已经初始化一个线程了，光启动该线程还不能称为\"IO线程\"，因为EventLoop还没有初始化，EventLoopThread::startLoop会通过条件变量一直等待，直到EventLoop被初始化，条件满足时才返回该EventLoop地址： EventLoop *EventLoopThread::startLoop() { assert(!thread_.started()); thread_.start(); { MutexLockGuard lock(mutex_); while (loop_ == NULL) { cond_.wait(); } } return loop_; } 那么EventLoop在哪里初始化，条件变量又如何被通知呢？这些问题都在线程执行函数中完成： void EventLoopThread::threadFunc() { EventLoop loop; // 线程初始化函数 if (callback_) { callback_(\u0026loop); } { MutexLockGuard lock(mutex_); // loop_指针指向了一个栈上的对象，threadFunc函数退出之后，这个指针就失效了 // threadFunc函数退出，就意味着线程退出了，EventLoopThread对象也就没有存在的价值了。 // 因而不会有什么大的问题 loop_ = \u0026loop; cond_.notify(); } loop.loop(); // assert(exiting_); } 当EventLoopThread类创建后，会在构造函数阶段创建一个线程，而该线程便执行threadFunc函数，如果用户传入了\"线程初始化函数\"，那么在这里便会优先执行该函数，然后初始化所持有的EventLoop，并发让条件满足(loop_!=NULL)，然后启动EventLoop的事件循环(loop.loop())。 这一过程下来，当一个EventLoopThread 被创建后，该EventLoopThread 对象内部也创建并启动了一个EventLoop对象，用户代码需要startLoop函数来获取该EventLoop对象，然后让该EventLoop中的Poller对象和一些Channel绑定，让Channel中的文件描述符加入事件监听中。所以该EventLoop可以在其他线程里被调用，这就是为什么EventLoop中还提供了runInLoop函数的原因，也为后续的EventLoopThreadPool做出铺垫。 调用startLoop函数一定会发生在两个线程中，例如：main线程调用startLoop函数，那么startLoop内部会创建一个线程(可以理解为I/O线程)，startLoop函数返回EventLoop对象到调用线程main，该EventLoop对象一定是I/O线程创建的对象。 最后的析构函数则做了些收尾工作： EventLoopThread::~EventLoopThread() { exiting_ = true; loop_-\u003equit(); // 退出IO线程，让IO线程的loop循环退出，从而退出了IO线程 thread_.join(); } 下面是一个简单的使用案例，可以帮助理解EventLoopThread的使用： #include \"EventLoop.h\" #include \"EventLoopThread.h\" #include \u003cstdio.h\u003e using namespace muduo; using namespace muduo::net; void runInThread() { printf(\"runInThread(): pid = %d, tid = %d\\n\", getpid(), CurrentThread::tid()); } void threadInitFC(EventLoop *loop) { printf(\"threadInitFC(): pid = %d, tid = %d\\n\", getpid(), CurrentThread::tid()); } int main() { printf(\"main(): pid = %d, tid = %d\\n\", getpid(), CurrentThread::tid()); EventLoopThread loopThread(threadInitFC); EventLoop *loop = loopThread.startLoop(); // 异步调用runInThread，即将runInThread添加到loop对象所在IO线程，让该IO线程执行 loop-\u003erunInLoop(runInThread); sleep(1); // runAfter内部也调用了runInLoop，所以这里也是异步调用 loop-\u003erunAfter(2, runInThread); sleep(3); loop-\u003equit(); printf(\"exit main().\\n\"); return 0; } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:7:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"17. EventLoopThreadPool 该类的作用就是\"事先缓存多个EventLoopThread\"，所以该类中需要有保存这些EventLoopThread及其EventLoop的数据结构： boost::ptr_vector\u003cEventLoopThread\u003e threads_; // IO线程列表 std::vector\u003cEventLoop *\u003e loops_; // EventLoop列表 通过setThreadNum函数来设置需要创建多少个IO线程(创建后的调整)： void setThreadNum(int numThreads) { numThreads_ = numThreads; } 如果用户传入数量为0(默认构造函数中设置为0)，那么该EventLoopThreadPool就会作为IO线程，EventLoopThreadPool内的baseLoop_持有这个EventLoop对象： EventLoopThreadPool::EventLoopThreadPool(EventLoop* baseLoop) : baseLoop_(baseLoop), started_(false), numThreads_(0), next_(0) { } 调用EventLoopThreadPool::start函数创建numThreads_个EventLoopThread。如果numThreads_为0且有线程初始化函数需要执行，那么就在EventLoopThreadPool所处线程中执行该函数。 void EventLoopThreadPool::start(const ThreadInitCallback \u0026cb) { assert(!started_); baseLoop_-\u003eassertInLoopThread(); started_ = true; for (int i = 0; i \u003c numThreads_; ++i) { EventLoopThread *t = new EventLoopThread(cb); threads_.push_back(t); loops_.push_back( t-\u003estartLoop()); // 启动EventLoopThread线程，在进入事件循环之前，会调用cb } if (numThreads_ == 0 \u0026\u0026 cb) { // 只有一个EventLoop，在这个EventLoop进入事件循环之前，调用cb cb(baseLoop_); } } 考虑到负载均衡，该类还实现了一个基于轮询方法来选择要使用的EventLoop(IO线程)： EventLoop *EventLoopThreadPool::getNextLoop() { baseLoop_-\u003eassertInLoopThread(); EventLoop *loop = baseLoop_; // 如果loops_为空(即numThreads_为0)，则loop指向baseLoop_ // 如果不为空，按照round-robin(RR，轮叫)的调度方式选择一个EventLoop if (!loops_.empty()) { // round-robin loop = loops_[next_]; ++next_; if (implicit_cast\u003csize_t\u003e(next_) \u003e= loops_.size()) { next_ = 0; } } return loop; } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:8:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"18. 网络套接字相关 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:9:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"18.1 Endian Endian.h头文件封装了字节序转换函数(全局函数，位于muduo::net::sockets名称空间中)。 #ifndef MUDUO_NET_ENDIAN_H #define MUDUO_NET_ENDIAN_H #include \u003cendian.h\u003e #include \u003cstdint.h\u003e namespace muduo { namespace net { namespace sockets { // the inline assembler code makes type blur, // so we disable warnings for a while. #if __GNUC_MINOR__ \u003e= 6 #pragma GCC diagnostic push #endif #pragma GCC diagnostic ignored \"-Wconversion\" #pragma GCC diagnostic ignored \"-Wold-style-cast\" // posix标准 // 主机字节序转换成网络字节序 inline uint64_t hostToNetwork64(uint64_t host64) { return htobe64(host64); } inline uint32_t hostToNetwork32(uint32_t host32) { return htobe32(host32); } inline uint16_t hostToNetwork16(uint16_t host16) { return htobe16(host16); } // 网络字节序转换成主机字节序 inline uint64_t networkToHost64(uint64_t net64) { return be64toh(net64); } inline uint32_t networkToHost32(uint32_t net32) { return be32toh(net32); } inline uint16_t networkToHost16(uint16_t net16) { return be16toh(net16); } #if __GNUC_MINOR__ \u003e= 6 #pragma GCC diagnostic pop #else #pragma GCC diagnostic error \"-Wconversion\" #pragma GCC diagnostic error \"-Wold-style-cast\" #endif } // namespace sockets } // namespace net } // namespace muduo #endif // MUDUO_NET_ENDIAN_H ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:9:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"18.2 SocketsOps 18.2.1 补充知识 下面是几个被封装的函数原型： #include \u003carpe/inet.h\u003e //将点分十进制的ip地址转化为用于网络传输的数值格式 返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1 int inet_pton(int family, const char *strptr, void *addrptr); //将数值格式转化为点分十进制的ip地址格式返回值：若成功则为指向结构的指针，若出错则为NULL const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len); 这两个函数的family参数既可以是AF_INET(ipv4)也可以是AF_INET6(ipv6)。如果，以不被支持的地址族作为family参数，这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT. 第一个函数尝试转换由strptr指针所指向的字符串，并通过addrptr指针存放二进制结果，若成功则返回值为1，否则如果所指定的family而言输入字符串不是有效的表达式格式，那么返回值为0. inet_ntop进行相反的转换，从数值格式(addrptr)转换到表达式(strptr)。inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。如果len太小，不足以容纳表达式结果，那么返回一个空指针，并置为errno为ENOSPC。 #include\u003csys/socket.h\u003e int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen); //用于获取与某个套接字关联的本地协议地址 int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen); //用于获取与某个套接字关联的外地协议地址 对于这两个函数，如果函数调用成功，则返回0，如果调用出错，则返回-1。使用这两个函数，我们可以通过套接字描述符来获取自己的IP地址和连接对端的IP地址，如在未调用bind函数的TCP客户端程序上，可以通过调用getsockname()函数获取由内核赋予该连接的本地IP地址和本地端口号，还可以在TCP的服务器端accept成功后，通过getpeername()函数来获取当前连接的客户端的IP地址和端口号。 18.2.2 源码分析 该类封装了socket相关系统调用(全局函数，位于muduo::net::sockets名称空间中)。它提供了众多对socket套接字操作的函数，各个函数之间也很少互相调用，基本就是将网络套接字API封装了一遍： #ifndef MUDUO_NET_SOCKETSOPS_H #define MUDUO_NET_SOCKETSOPS_H #include \u003carpa/inet.h\u003e namespace muduo { namespace net { namespace sockets { /// /// Creates a non-blocking socket file descriptor, /// abort if any error. // 创建一个非阻塞套接字，如果创建失败就终止程序abort int createNonblockingOrDie(); int connect(int sockfd, const struct sockaddr_in \u0026addr); void bindOrDie(int sockfd, const struct sockaddr_in \u0026addr); void listenOrDie(int sockfd); int accept(int sockfd, struct sockaddr_in *addr); ssize_t read(int sockfd, void *buf, size_t count); ssize_t readv(int sockfd, const struct iovec *iov, int iovcnt); ssize_t write(int sockfd, const void *buf, size_t count); void close(int sockfd); void shutdownWrite(int sockfd); void toIpPort(char *buf, size_t size, const struct sockaddr_in \u0026addr); void toIp(char *buf, size_t size, const struct sockaddr_in \u0026addr); void fromIpPort(const char *ip, uint16_t port, struct sockaddr_in *addr); int getSocketError(int sockfd); struct sockaddr_in getLocalAddr(int sockfd); struct sockaddr_in getPeerAddr(int sockfd); bool isSelfConnect(int sockfd); } // namespace sockets } // namespace net } // namespace muduo #endif // MUDUO_NET_SOCKETSOPS_H 接下来分析这些定义的函数源码，首先将sockaddr定义为了SA类型： typedef struct sockaddr SA; //通用地址 下面这两个函数将sockaddr_in类型转换为sockaddr类型： // 网际地址转换通用地址 const SA *sockaddr_cast(const struct sockaddr_in *addr) { return static_cast\u003cconst SA *\u003e(implicit_cast\u003cconst void *\u003e(addr)); } SA *sockaddr_cast(struct sockaddr_in *addr) { return static_cast\u003cSA *\u003e(implicit_cast\u003cvoid *\u003e(addr)); } 下面这个函数设置套接字文件描述符为非阻塞close-on-exec，意思是调用套接字的进程如果创建了子进程，那么子进程将自动关闭这个拷贝的文件描述符，该文件的状态就不会带到子进程中。 void setNonBlockAndCloseOnExec(int sockfd) { // non-block int flags = ::fcntl(sockfd, F_GETFL, 0); flags |= O_NONBLOCK; int ret = ::fcntl(sockfd, F_SETFL, flags); // FIXME check // close-on-exec flags = ::fcntl(sockfd, F_GETFD, 0); flags |= FD_CLOEXEC; ret = ::fcntl(sockfd, F_SETFD, flags); // FIXME check (void)ret; } 浅析open函数O_CLOEXEC模式和fcntl函数FD_CLOEXEC选项 接下来这个函数只是调用了socket函数返回一个文件描述符，同时也做了错误判断： int sockets::createNonblockingOrDie() { // socket #if VALGRIND // 内存泄露检测工具，还能够检测文件描述符的打开状态 int sockfd = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (sockfd \u003c 0) { LOG_SYSFATAL \u003c\u003c \"sockets::createNonblockingOrDie\"; } setNonBlockAndCloseOnExec(sockfd); #else // Linux 2.6.27以上的内核支持SOCK_NONBLOCK与SOCK_CLOEXEC int sockfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP); if (sockfd \u003c 0) { LOG_SYSFATAL \u003c\u003c \"sockets::createNonblockingOrDie\"; } #endif return sockfd; } 下面这两个函数分别绑定和监听了一个套接字： void sockets::bindOrDie(int sockfd, const struct sockaddr_in \u0026addr) { int ret = ::bind(sockfd, sockaddr_cast(\u0026addr), sizeof addr); if (ret \u003c 0) { LOG_SYSFATAL \u003c\u003c \"sockets::bindOrDie\"; } } void sockets::list","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:9:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"18.3 InetAddress 该类主要提供了一些地址转换的函数(例如从网络字节序到本地字节序)，调用了SocketsOps里的地址函数。 #ifndef MUDUO_NET_INETADDRESS_H #define MUDUO_NET_INETADDRESS_H #include \"StringPiece.h\" #include \"copyable.h\" #include \u003cnetinet/in.h\u003e namespace muduo { namespace net { /// /// Wrapper of sockaddr_in. /// /// This is an POD interface class. class InetAddress : public muduo::copyable { public: /// Constructs an endpoint with given port number. /// Mostly used in TcpServer listening. // 仅仅指定port，不指定ip，则ip为INADDR_ANY(即0.0.0.0) explicit InetAddress(uint16_t port); /// Constructs an endpoint with given ip and port. /// @c ip should be \"1.2.3.4\" InetAddress(const StringPiece \u0026ip, uint16_t port); /// Constructs an endpoint with given struct @c sockaddr_in /// Mostly used when accepting new connections InetAddress(const struct sockaddr_in \u0026addr) : addr_(addr) {} string toIp() const; string toIpPort() const; // __attribute__ ((deprecated)) 表示该函数是过时的，被淘汰的 // 这样使用该函数，在编译的时候，会发出警告 string toHostPort() const __attribute__((deprecated)) { return toIpPort(); } // default copy/assignment are Okay const struct sockaddr_in \u0026getSockAddrInet() const { return addr_; } void setSockAddrInet(const struct sockaddr_in \u0026addr) { addr_ = addr; } uint32_t ipNetEndian() const { return addr_.sin_addr.s_addr; } uint16_t portNetEndian() const { return addr_.sin_port; } private: struct sockaddr_in addr_; }; } // namespace net } // namespace muduo #endif // MUDUO_NET_INETADDRESS_H ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:9:3","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"18.4 Socket 该类使用了前面两个类中的函数，主要是对socket套接字操作的进一步封装，还包括一些setsockopt的选项操作封装： 首先看Socket类的定义： #ifndef MUDUO_NET_SOCKET_H #define MUDUO_NET_SOCKET_H #include \u003cboost/noncopyable.hpp\u003e namespace muduo { /// /// TCP networking. /// namespace net { class InetAddress; /// /// Wrapper of socket file descriptor. /// /// It closes the sockfd when desctructs. /// It's thread safe, all operations are delagated to OS. class Socket : boost::noncopyable { public: explicit Socket(int sockfd) : sockfd_(sockfd) {} // Socket(Socket\u0026\u0026) // move constructor in C++11 ~Socket(); int fd() const { return sockfd_; } /// abort if address in use // 调用bind绑定服务器IP端口 void bindAddress(const InetAddress \u0026localaddr); /// abort if address in use // 调用listen监听套接字 void listen(); /// On success, returns a non-negative integer that is /// a descriptor for the accepted socket, which has been /// set to non-blocking and close-on-exec. *peeraddr is assigned. /// On error, -1 is returned, and *peeraddr is untouched. // 调用accept接受新客户连接请求 int accept(InetAddress *peeraddr); // 调用shutdown关闭服务端写通道 void shutdownWrite(); /* 下面四个函数都是调用setsockopt来设置一些socket选项 */ /// Nagle /// 算法是频繁发一些小的数据包，会攒在一起发送，合并包发送。一般来说这个延迟时间是200毫秒 /// Enable/disable TCP_NODELAY (disable/enable Nagle's algorithm). /// // Nagle算法可以一定程度上避免网络拥塞 // TCP_NODELAY选项可以禁用Nagle算法 // 禁用Nagle算法，可以避免连续发包出现延迟，这对于编写低延迟的网络服务很重要 void setTcpNoDelay(bool on); /// /// Enable/disable SO_REUSEADDR /// void setReuseAddr(bool on); /// /// Enable/disable SO_KEEPALIVE /// // // TCP keepalive是指定期探测连接是否存在，如果应用层有心跳的话，这个选项不是必需要设置的 void setKeepAlive(bool on); private: const int sockfd_; //服务器监听套接字文件描述符 }; } // namespace net } // namespace muduo #endif // MUDUO_NET_SOCKET_H Socket类使用了RAII编程方法，通过构造函数在初始化列表接管资源，在析构函数中释放资源： explicit Socket(int sockfd) : sockfd_(sockfd) {} Socket::~Socket() { sockets::close(sockfd_); } 下来这几个函数，都是直接调用了SocketsOps中封装的socket操作函数： void Socket::bindAddress(const InetAddress \u0026addr) { sockets::bindOrDie(sockfd_, addr.getSockAddrInet()); } void Socket::listen() { sockets::listenOrDie(sockfd_); } int Socket::accept(InetAddress *peeraddr) { struct sockaddr_in addr; bzero(\u0026addr, sizeof addr); int connfd = sockets::accept(sockfd_, \u0026addr); if (connfd \u003e= 0) { peeraddr-\u003esetSockAddrInet(addr); } return connfd; } void Socket::shutdownWrite() { sockets::shutdownWrite(sockfd_); } 下面这个函数选项禁用Nagle算法： void Socket::setTcpNoDelay(bool on) { int optval = on ? 1 : 0; ::setsockopt(sockfd_, IPPROTO_TCP, TCP_NODELAY, \u0026optval, sizeof optval); // FIXME CHECK } 接下来这个函数设置地址复用： void Socket::setReuseAddr(bool on) { int optval = on ? 1 : 0; ::setsockopt(sockfd_, SOL_SOCKET, SO_REUSEADDR, \u0026optval, sizeof optval); // FIXME CHECK } 接下来这个函数设置周期性测试连接是否存活： void Socket::setKeepAlive(bool on) { int optval = on ? 1 : 0; ::setsockopt(sockfd_, SOL_SOCKET, SO_KEEPALIVE, \u0026optval, sizeof optval); // FIXME CHECK } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:9:4","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"19. Buffer Buffer类其实是封装了一个用户缓冲区，以及向这个缓冲区写数据读数据等一系列控制方法。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:10:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"19.1 设计思想 这个缓冲区类的实现值得参考和借鉴，以前我们写的只支持一次性全部读出和写入，而这个Buffer类可以读一点，写一点，内部逻辑稳定。这个Buffer类是vector（方便动态扩容），对外表现出std::queue的特性，它的内部原理大概就是下图这样子的，用两个游标（readerIndex_和writerIndex_）标记可读缓冲区的起始位置和空闲空间的起始位置。 其中需要关注的就是，随着写入数据和读入数据，蓝色的空闲空间会越来越少，prependable空间会越来越大，当什么时候空用空间耗尽了，就会向步骤4一样，把所有数据拷贝前移，重新调整。另外当整个缓冲区的prependable空间和蓝色的空闲空间都无法装下新来的数据时，那就会调用vector的resize，实现扩容机制。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:10:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"19.2 几个重要的成员函数 // 将data数据添加到缓冲区中 append(const char* data, size_t len); // 获取缓冲区中长度为len的数据，并以strnig返回 string retrieveAsString(size_t len); // 获取缓冲区所有数据，并以string返回。 string retrieveAllAsString(); // 确保缓冲区可写空间\u003e=len，如果不足则扩充 // 当你打算向缓冲区写入长度为len的数据之前，先调用这个函数，这个函数会检查你的缓冲区可写空间能不能装下长度为len的数据，如果不能，就动态扩容。 void ensureWritableBytes(size_t len) 下面这个方法主要是封装了调用了上面几个方法： /// Read data directly into buffer. /// /// It may implement with readv(2) /// @return result of read(2), @c errno is saved // 客户端发来数据，readFd从该TCP接收缓冲区中将数据读出来并放到Buffer中。 ssize_t readFd(int fd, int *savedErrno); 值得说明的是，目前写数据通过将Buffer中的数据拷贝到TCP发送缓冲区中，以如下方式处理： ... ssize_t n = sockets::write(channel_-\u003efd(), outputBuffer_.peek(), outputBuffer_.readableBytes()); if (n \u003e 0) { outputBuffer_.retrieve(n); ... } ... ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:10:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"20. Acceptor 套接字TCP服务器编程中，服务器需要一个监听套接字，该套接字用于监听客户端连接。 “监听套接字\"也是一个文件描述符，一个文件描述符在muduo中应该和一个Channel联系。muduo网络库将专用于监听连接的套接字操作封装成了Acceptor。所以一个Acceptor中一定会有一个套接字socket和一个Channel，有了Channel一定会关联一个EventLoop： EventLoop *loop_; Socket acceptSocket_; // listening socket(即server socket) Channel acceptChannel_; // 用于观察acceptSocket_的readable事件，并回调Accptor::handleRead() 其构造函数如下： Acceptor::Acceptor(EventLoop *loop, const InetAddress \u0026listenAddr) : loop_(loop), acceptSocket_(sockets::createNonblockingOrDie()), // Channel对象都是通过EventLoop对象注册的 acceptChannel_(loop, acceptSocket_.fd()), listenning_(false), idleFd_(::open(\"/dev/null\", O_RDONLY | O_CLOEXEC)) { assert(idleFd_ \u003e= 0); acceptSocket_.setReuseAddr(true); // 设置了监听套接字地址复用 acceptSocket_.bindAddress(listenAddr); acceptChannel_.setReadCallback(boost::bind(\u0026Acceptor::handleRead, this)); } 其中idleFd_的作用会在后面介绍。在构造函数中初始化了acceptSocket_，并将该Socket管理的监听套接字和acceptChannel_关联。然后在构造函数中设置了监听套接字地址复用，并绑定了传入参数的监听地址结构，最后设置了acceptChannel_的读事件函数Acceptor::handleRead，当监听套接字上有连接事件时将会出发该回调函数，该回调函数将在后面详细介绍。 在设置完acceptChannel_的回调函数后，即构造函数初始化结束后，acceptChannel_还是没有和EventLoop中的Poller关联，因为一个Channel如果要和Poller关联，那么必须要调用enablexxx函数，enablexxx函数内部又会调用update函数，这样才能达成关联。所以如果要达成这个目的，还需要有该函数： void Acceptor::listen() { loop_-\u003eassertInLoopThread(); listenning_ = true; acceptSocket_.listen(); acceptChannel_.enableReading(); } 创建套接字后还需要设置套接字监听，并和Poller关联，这样一来，如果有客户连接，那么将调用Acceptor::handleRead函数： //调用accept(2)来接受新连接，并回调用户callback void Acceptor::handleRead() { loop_-\u003eassertInLoopThread(); InetAddress peerAddr(0); // FIXME loop until no more int connfd = acceptSocket_.accept(\u0026peerAddr); if (connfd \u003e= 0) { // string hostport = peerAddr.toIpPort(); // LOG_TRACE \u003c\u003c \"Accepts of \" \u003c\u003c hostport; if (newConnectionCallback_) { newConnectionCallback_(connfd, peerAddr); } else { sockets::close(connfd); } } else { // Read the section named \"The special problem of // accept()ing when you can't\" in libev's doc. // By Marc Lehmann, author of livev. //创建的文件描述符太多了 if (errno == EMFILE) { ::close(idleFd_); //由于我们使用的是电频触发，这个accept会一直触发，所以采用一个空闲的文件描述符，关闭idleFd_，再用来接收这个accept的idleFd_，再关闭idleFd_ idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL); ::close(idleFd_); idleFd_ = ::open(\"/dev/null\", O_RDONLY | O_CLOEXEC); } } } 在该函数中调用了accetp函数来接收连接，先看连接成功的情况(connfd \u003e= 0)，在该代码分支会将该连接客户端套接字及其地址传入newConnectionCallback_处理，newConnectionCallback_可以通过如下函数来设置： void setNewConnectionCallback(const NewConnectionCallback \u0026cb) { newConnectionCallback_ = cb; } 可以理解，在setNewConnectionCallback中必然会处理客户端连接套接字，至于muduo如何处理，在TcpConnection中会介绍。如果该函数没有设置，也就是默认不处理该连接套接字，那么直接关闭该套接字。 接下来再看看else分支情况。else分支中会判断errno 是否为 EMFILE，如果发生该情况则说明系统文件描述符用尽了，需要处理。由于我们使用的是电频触发，这个accept会一直触发，所以这里利用一个空闲的文件描述符来处理这个问题，它是在Acceptor初始化列表中就创建了。首先关闭idleFd_(空闲文件描述符)，再用来接收这个accept的acceptSocket_，再关闭它，最后再创建一个空闲的描述符。 最后是析构函数，在该函数中将释放监听套接字资源，去除与其相关的Channel及销毁空闲的文件描述符： Acceptor::~Acceptor() { // 移除Channel需要保证它处于：kNoneEvent状态 acceptChannel_.disableAll(); acceptChannel_.remove(); ::close(idleFd_); } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:11:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"21. TcpConnection Acceptor代表了监听连接的套接字listenfd，那么TcpConnection 就代表了已连接的客户端套接字connfd。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:12:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"21.1 设计思想 TcpConnection 代表的是客户端连接套接字，所以TcpConnection 内部一定会管理一个文件描述符，以及该文件描述符对应的Channel，该Channel也需要关联一个EventLoop： EventLoop *loop_; boost::scoped_ptr\u003cSocket\u003e socket_; boost::scoped_ptr\u003cChannel\u003e channel_; 对于TcpConnection中的socket_，TcpConnection还使用了两个地址结构来分别保存本机IP地址和对等方IP地址： InetAddress localAddr_; // 保存本机IP地址 InetAddress peerAddr_; // 对等方IP地址 使用一个状态来标识当前套接字的连接状态(已断开，正在连接(三次握手)，已连接，正在断开(四次挥手)状态)： enum StateE { kDisconnected, kConnecting, kConnected, kDisconnecting }; StateE state_; // FIXME: use atomic variable 这些变量都在构造函数中被初始化了： TcpConnection::TcpConnection(EventLoop *loop, const string \u0026nameArg, int sockfd, const InetAddress \u0026localAddr, const InetAddress \u0026peerAddr) : loop_(CHECK_NOTNULL(loop)), name_(nameArg), state_(kConnecting), socket_(new Socket(sockfd)), channel_(new Channel(loop, sockfd)), localAddr_(localAddr), peerAddr_(peerAddr), highWaterMark_(64 * 1024 * 1024) { // 通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间 channel_-\u003esetReadCallback(boost::bind(\u0026TcpConnection::handleRead, this, _1)); // 通道可写事件到来的时候，回调TcpConnection::handleWrite channel_-\u003esetWriteCallback(boost::bind(\u0026TcpConnection::handleWrite, this)); // 连接关闭，回调TcpConnection::handleClose channel_-\u003esetCloseCallback(boost::bind(\u0026TcpConnection::handleClose, this)); // 发生错误，回调TcpConnection::handleError channel_-\u003esetErrorCallback(boost::bind(\u0026TcpConnection::handleError, this)); LOG_DEBUG \u003c\u003c \"TcpConnection::ctor[\" \u003c\u003c name_ \u003c\u003c \"] at \" \u003c\u003c this \u003c\u003c \" fd=\" \u003c\u003c sockfd; socket_-\u003esetKeepAlive(true); } 构造函数初始化列表中的name_指的是该TcpConnection的名字，需要传入。highWaterMark_“高水位\"标识在后面会介绍。 构造函数将state_ 设置为了kConnecting状态，意思是还没有完成连接，当然还有kConnected和kDisconnected两种状态，这在后面会具体介绍。 在构造函数中设置了Channel的读、写、关闭和错误回调函数，这些回调函数的具体内容会在后续介绍。 构造函数中，设置了socket_-\u003esetKeepAlive(true)，设置套接字保持连接(TCP心跳)。 构造函数调用之后，该连接套接字还没有让EventLoop中的Poller监听，因为Channel还没有调用enableXXX函数，该函数会在建立连接回调TcpConnection::connectEstablished函数，这在后续会详细介绍。 总之，一个TcpConnection代表了一个连接套接字及其Channel。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:12:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"21.2 TCP 网络编程的本质 TCP 网络编程最本质的是处理三个半事件： (1) 连接的建立，包括服务端接受(accept) 新连接和客户端成功发起(connect) 连接。TCP 连接一旦建立，客户端和服务端是平等的，可以各自收发数据。 (2) 连接的断开，包括主动断开(close 或shutdown) 和被动断开(read(2) 返回0)。 (3) 消息到达，文件描述符可读。这是最为重要的一个事件，对它的处理方式决定了网络编程的风格(阻塞还是非阻塞，如何处理分包，应用层的缓冲如何设计等等)。 (3.5) 消息发送完毕，这算半个。对于低流量的服务，可以不必关心这个事件；另外，这里\"发送完毕\"是指将数据写入操作系统的缓冲区，将由TCP 协议栈负责数据的发送与重传，不代表对方已经收到数据。 对于这\"三个半事件”，在TcpConnection中体现如下： typedef boost::shared_ptr\u003cTcpConnection\u003e TcpConnectionPtr; typedef boost::function\u003cvoid(const TcpConnectionPtr \u0026)\u003e ConnectionCallback; typedef boost::function\u003cvoid(const TcpConnectionPtr \u0026)\u003e CloseCallback; typedef boost::function\u003cvoid(const TcpConnectionPtr \u0026)\u003e WriteCompleteCallback; // the data has been read to (buf, len) typedef boost::function\u003cvoid(const TcpConnectionPtr \u0026, Buffer *, Timestamp)\u003e MessageCallback; ConnectionCallback connectionCallback_; // 连接建立或关闭后的处理函数 MessageCallback messageCallback_; // 收到消息后的处理函数 WriteCompleteCallback writeCompleteCallback_; // 消息发送完后的处理函数 CloseCallback closeCallback_; // 连接关闭后的处理函数 void defaultConnectionCallback(const TcpConnectionPtr \u0026conn); void defaultMessageCallback(const TcpConnectionPtr \u0026conn, Buffer *buffer, Timestamp receiveTime); 并提供了如下函数，来供用户自定义这些回调函数： void setConnectionCallback(const ConnectionCallback \u0026cb) { connectionCallback_ = cb; } void setMessageCallback(const MessageCallback \u0026cb) { messageCallback_ = cb; } void setWriteCompleteCallback(const WriteCompleteCallback \u0026cb) { writeCompleteCallback_ = cb; } 而Muduo库中定义的如下函数: /// Internal use only. void setCloseCallback(const CloseCallback \u0026cb) { closeCallback_ = cb; } 它与TcpServer::removeConnection或TcpClient::removeConnection函数进行绑定。 上面几个函数都是在TcpServer或TcpClient中传递的，所以在后续的TcpServer分析中会具体介绍这些函数。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:12:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"21.3 发送和接收缓冲区 TcpConnection使用Buffer作为发送和接收缓冲区： Buffer inputBuffer_; // 应用层接收缓冲区 // FIXME: use list\u003cBuffer\u003e as output buffer. Buffer outputBuffer_; // 应用层发送缓冲区 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:12:3","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"21.4 连接事件处理 TcpConnection 中有： void TcpConnection::connectEstablished() { loop_-\u003eassertInLoopThread(); assert(state_ == kConnecting); setState(kConnected); LOG_TRACE \u003c\u003c \"[3] usecount=\" \u003c\u003c shared_from_this().use_count(); // enable_shared_from_this是一个以其派生类为模板类型参数的基类模板，继承它，派生类的this指针就能变成一个shared_ptr。 channel_-\u003etie(shared_from_this()); channel_-\u003eenableReading(); // TcpConnection所对应的通道加入到Poller关注 connectionCallback_(shared_from_this()); LOG_TRACE \u003c\u003c \"[4] usecount=\" \u003c\u003c shared_from_this().use_count(); } 该函数不是TcpConnection调用的，是在TcpServer设置调用的，现在只需要了解即可。该函数在建立连接时会被调用，该函数设置连接状态为kConnected(如果之前没有连接)，然后会调用Channel的tie和enableReading函数，让该监听套接字及其Channel和EventLoop的Poller绑定。最后调用connectionCallback_。 关于boost中enable_shared_from_this类的原理分析 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:12:4","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"21.5 “读\"事件处理 在构造函数中做过如下设置： // 通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间 channel_-\u003esetReadCallback(boost::bind(\u0026TcpConnection::handleRead, this, _1)); TcpConnection::handleRead定义如下： void TcpConnection::handleRead(Timestamp receiveTime) { loop_-\u003eassertInLoopThread(); int savedErrno = 0; ssize_t n = inputBuffer_.readFd(channel_-\u003efd(), \u0026savedErrno); if (n \u003e 0) { messageCallback_(shared_from_this(), \u0026inputBuffer_, receiveTime); } else if (n == 0) { handleClose(); } else { errno = savedErrno; LOG_SYSERR \u003c\u003c \"TcpConnection::handleRead\"; handleError(); } } 具体读的过程会调用Buffer::readFd函数，该函数定义如下： // 结合栈上的空间，避免内存使用过大，提高内存使用率 // 如果有5K个连接，每个连接就分配64K+64K的缓冲区的话，将占用640M内存， // 而大多数时候，这些缓冲区的使用率很低 ssize_t Buffer::readFd(int fd, int *savedErrno) { // saved an ioctl()/FIONREAD call to tell how much to read // 节省一次ioctl系统调用(获取有多少可读数据) char extrabuf[65536]; struct iovec vec[2]; const size_t writable = writableBytes(); // 第一块缓冲区 vec[0].iov_base = begin() + writerIndex_; vec[0].iov_len = writable; // 第二块缓冲区 vec[1].iov_base = extrabuf; vec[1].iov_len = sizeof extrabuf; const ssize_t n = sockets::readv(fd, vec, 2); if (n \u003c 0) { *savedErrno = errno; } else if (implicit_cast\u003csize_t\u003e(n) \u003c= writable) //第一块缓冲区足够容纳 { writerIndex_ += n; } else // 当前缓冲区，不够容纳，因而数据被接收到了第二块缓冲区extrabuf，将其append至buffer { writerIndex_ = buffer_.size(); append(extrabuf, n - writable); } // if (n == writable + sizeof extrabuf) // { // goto line_30; // } return n; } 该函数利用了readv函数、iovec结构体和Buffer。vec[0]指向的是Buffer的写指针地址，vec[1]指向的是extrabuf的地址。这样做是为了双保险，如果读出的数据比较小，Buffer可以容纳，那么就全部读到Buffer中了，如果读出的数据很多，Buffer不够用了，那么还有65535字节的缓冲区可以接收这些数据，读出来的一些数据就保持在了Buffer中，剩下数据在extrabuf里，所以需要将在extrabuf中的数据再次append到Buffer中，Buffer也会适当扩容，最后所有数据都在Buffer中了。 readFd巧妙的设计，可以让用户一次性把所有TCP接收缓冲区的所有数据全部都读出来并放到用户自定义的缓冲区Buffer中。用户自定义缓冲区Buffer是有大小限制的，我们一开始不知道TCP接收缓冲区中的数据量有多少，如果一次性读出来会不会导致Buffer装不下而溢出？所以在readFd()函数中会在栈上创建一个临时空间extrabuf，然后使用readv的分散读特性，将TCP缓冲区中的数据先拷贝到Buffer中，如果Buffer容量不够，就把剩余的数据都拷贝到extrabuf中，然后再调整Buffer的容量(动态扩容)，再把extrabuf的数据拷贝到Buffer中。当这个函数结束后，extrabuf也会被释放。另外extrabuf是在栈上开辟的空间，速度比在堆上开辟还要快。 linux ioctl()函数详解 现在回到TcpConnection::handleRead中，如果读取到数据，则调用messageCallback_；如果读取到数据为0，说明客户端已经断开连接，那么调用handleClose()函数来关闭连接： void TcpConnection::handleClose() { loop_-\u003eassertInLoopThread(); LOG_TRACE \u003c\u003c \"fd = \" \u003c\u003c channel_-\u003efd() \u003c\u003c \" state = \" \u003c\u003c state_; assert(state_ == kConnected || state_ == kDisconnecting); // we don't close fd, leave it to dtor, so we can find leaks easily. setState(kDisconnected); channel_-\u003edisableAll(); TcpConnectionPtr guardThis(shared_from_this()); connectionCallback_(guardThis); // 调用连接建立或关闭后的处理函数 LOG_TRACE \u003c\u003c \"[7] usecount=\" \u003c\u003c guardThis.use_count(); // must be the last line closeCallback_(guardThis); // 调用TcpServer::removeConnection或TcpClient::removeConnection LOG_TRACE \u003c\u003c \"[11] usecount=\" \u003c\u003c guardThis.use_count(); } 该函数设置state_为kDisconnected，将连接套接字及其Channel从EventLoop的Poller中解除监听，然后依次调用connectionCallback_和closeCallback_函数。断开连接也属于connectionCallback_。(连接到来或者连接关闭都会调用ConnectionCallback回调函数) 如果读取出现错误，那么将调用handleError函数： void TcpConnection::handleError() { int err = sockets::getSocketError(channel_-\u003efd()); LOG_ERROR \u003c\u003c \"TcpConnection::handleError [\" \u003c\u003c name_ \u003c\u003c \"] - SO_ERROR = \" \u003c\u003c err \u003c\u003c \" \" \u003c\u003c strerror_tl(err); } 将错误输出到日志中。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:12:5","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"21.6 发送数据 在TcpConnection中提供了如下函数发送数据： // void send(string\u0026\u0026 message); // C++11 void send(const void *message, size_t len); void send(const StringPiece \u0026message); // void send(Buffer\u0026\u0026 message); // C++11 void send(Buffer *message); // this one will swap data 使用重载技术编写了三个send函数，这里只介绍参数为Buffer的那个，其余的大体类似： // 线程安全，可以跨线程调用 void TcpConnection::send(Buffer *buf) { if (state_ == kConnected) { if (loop_-\u003eisInLoopThread()) { sendInLoop(buf-\u003epeek(), buf-\u003ereadableBytes()); buf-\u003eretrieveAll(); } else { loop_-\u003erunInLoop(boost::bind(\u0026TcpConnection::sendInLoop, this, buf-\u003eretrieveAllAsString())); // std::forward\u003cstring\u003e(message))); } } } void TcpConnection::sendInLoop(const StringPiece \u0026message) { sendInLoop(message.data(), message.size()); } 无论是在当前EventLoop线程还是跨线程调用，它们都最终调用了TcpConnection::sendInLoop函数： void TcpConnection::sendInLoop(const void *data, size_t len) { /* loop_-\u003eassertInLoopThread(); sockets::write(channel_-\u003efd(), data, len); */ loop_-\u003eassertInLoopThread(); ssize_t nwrote = 0; size_t remaining = len; bool error = false; if (state_ == kDisconnected) { LOG_WARN \u003c\u003c \"disconnected, give up writing\"; return; } // if no thing in output queue, try writing directly // 通道没有关注可写事件并且发送缓冲区没有数据，直接write if (!channel_-\u003eisWriting() \u0026\u0026 outputBuffer_.readableBytes() == 0) { nwrote = sockets::write(channel_-\u003efd(), data, len); if (nwrote \u003e= 0) { remaining = len - nwrote; // 写完了，回调writeCompleteCallback_ if (remaining == 0 \u0026\u0026 writeCompleteCallback_) { loop_-\u003equeueInLoop( boost::bind(writeCompleteCallback_, shared_from_this())); } } else // nwrote \u003c 0 { nwrote = 0; if (errno != EWOULDBLOCK) { LOG_SYSERR \u003c\u003c \"TcpConnection::sendInLoop\"; if (errno == EPIPE) // FIXME: any others? { error = true; } } } } assert(remaining \u003c= len); // 没有错误，并且还有未写完的数据(说明内核发送缓冲区满，要将未写完的数据添加到output buffer中) if (!error \u0026\u0026 remaining \u003e 0) { LOG_TRACE \u003c\u003c \"I am going to write more data\"; size_t oldLen = outputBuffer_.readableBytes(); // 如果超过highWaterMark_(高水位标)，回调highWaterMarkCallback_ if (oldLen + remaining \u003e= highWaterMark_ \u0026\u0026 oldLen \u003c highWaterMark_ \u0026\u0026 highWaterMarkCallback_) { loop_-\u003equeueInLoop(boost::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining)); } outputBuffer_.append(static_cast\u003cconst char *\u003e(data) + nwrote, remaining); if (!channel_-\u003eisWriting()) { channel_-\u003eenableWriting(); // 关注POLLOUT事件 } } } 在该函数中会调用： if (!channel_-\u003eisWriting() \u0026\u0026 outputBuffer_.readableBytes() == 0) 判断该Channel有没有使能\"写”。在第一次调用该函数时是没有使能\"写\"的，前面只是使能了\"读”，关注读事件。而且会判断Buffer的输出缓冲区内是否有数据，如果是第一次调用了该函数，那么发送缓冲区内肯定是没有有数据的，只不过第一次调用时还没有使能\"写\"，所以该判断成立，直接调用write函数写入数据，如果数据写入比较少，一次性就发送完了，那么直接调用writeCompleteCallback_，结束该分支。如果一次性没有写完，那么代码会跳转到该分支执行： if (!error \u0026\u0026 remaining \u003e 0) { ... } 它会继续判断，当前的Buffer缓冲区里的数据长度(oldLen)与需要发送数据长度(remaining)之和是否大于\"高水位标志\"highWaterMark_，而且Buffer缓冲区内的数据小于highWaterMark_，是否设置了\"高水位标志\"回调函数highWaterMarkCallback_，如果设置了，那么执行highWaterMarkCallback_函数。然后将发送数据中没有发送的部分拷贝到Buffer中，然后使能\"写\"。接下来的数据就交给Poller返回后调用TcpConnection::handleWrite函数处理了。 因为Tcp发送缓冲区是有大小限制的，假如达到了高水位线，就没办法把发送的数据通过send()直接拷贝到Tcp发送缓冲区，而是暂存在这个outputBuffer_中，等TCP发送缓冲区有空间了，触发可写事件了，再把outputBuffer_中的数据拷贝到Tcp发送缓冲区中。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:12:6","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"21.7 “写\"事件处理 在构造函数中做过如下设置： // 通道可写事件到来的时候，回调TcpConnection::handleWrite channel_-\u003esetWriteCallback(boost::bind(\u0026TcpConnection::handleWrite, this)); 当需要向连接套接字中写入数据时，TcpConnection::handleWrite将被调用： // 内核发送缓冲区有空间了，回调该函数 void TcpConnection::handleWrite() { loop_-\u003eassertInLoopThread(); if (channel_-\u003eisWriting()) { ssize_t n = sockets::write(channel_-\u003efd(), outputBuffer_.peek(), outputBuffer_.readableBytes()); if (n \u003e 0) { outputBuffer_.retrieve(n); if (outputBuffer_.readableBytes() == 0) // 发送缓冲区已清空 { channel_-\u003edisableWriting(); // 停止关注POLLOUT事件，以免出现busy loop if (writeCompleteCallback_) // 回调writeCompleteCallback_ { // 应用层发送缓冲区被清空，就回调用writeCompleteCallback_ loop_-\u003equeueInLoop( boost::bind(writeCompleteCallback_, shared_from_this())); } // 发送缓冲区已清空并且连接状态是kDisconnecting，要关闭连接 if (state_ == kDisconnecting) { shutdownInLoop(); // 只关闭写的这一半，进入半关闭状态(close SHUT_WR) } } else { LOG_TRACE \u003c\u003c \"I am going to write more data\"; } } else { LOG_SYSERR \u003c\u003c \"TcpConnection::handleWrite\"; // if (state_ == kDisconnecting) // { // shutdownInLoop(); // } } } else { LOG_TRACE \u003c\u003c \"Connection fd = \" \u003c\u003c channel_-\u003efd() \u003c\u003c \" is down, no more writing\"; } } 当客户端套接字变得可写时，调用write往套接字中写入Buffer内容，如果写完了，那么设置Channel，客户端套接字停止\"写行为”。如果设置了writeCompleteCallback_，则调用writeCompleteCallback_函数。 当内核发送缓冲区有空间了，回调handleWrite函数，调用write往套接字中写入Buffer内容，如果写完了，那么设置Channel，客户端套接字停止\"写行为\"。那么已经取消关注了可写的事件，在什么地方又得重新设置再次关注可写事件呢？客户端每次发送数据都是通过send函数，它就在内部调用了enableWriting函数。 如果当前TcpConnection状态为kDisconnecting，说明没有连接，则调用shutdownInLoop函数，关闭该套接字的写端，但仍然可以读： void TcpConnection::shutdownInLoop() { loop_-\u003eassertInLoopThread(); if (!channel_-\u003eisWriting()) { // we are not writing socket_-\u003eshutdownWrite(); } } 当调用如下函数后，状态为kDisconnecting： void TcpConnection::shutdown() { // FIXME: use compare and swap if (state_ == kConnected) { setState(kDisconnecting); // FIXME: shared_from_this()? loop_-\u003erunInLoop(boost::bind(\u0026TcpConnection::shutdownInLoop, this)); } } 使用该函数来断开连接。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:12:7","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"21.8 TcpConnection生存期管理 第5步，在TcpSever中removeConnection 移除掉TcpConnection, 正常应该在移除后销毁掉TcpConnection，但是不能销毁，如果现在销毁了TcpConnection的Channel对象也就跟着销毁了，而这时调用Channel的handleEvent() 函数，就会出现Core Dump，所以说TcpConnection 的生命期应该长于Channel对象。 当连接到来，创建一个TcpConnection对象，立刻用share_ptr 来管理，引用计数为1， 在Channel中维护一个weak_ptr(tie_)，将这个share_ptr 对象赋值给tie_，引用计数仍为1， 当连接关闭，在handleEvent()，将tie_提升，得到一个share_ptr 对象，引用计数就变成了2。 第6步TcpServer 中erase 后引用计数变为1，第七步queueInLoop 加入bind 引用计数变为2，handleEvent 执行完引用计数减1变为1，bind执行完后引用计数变为0，自动销毁。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:12:8","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"22. TcpServer TcpServer中融合了前面讲过的几乎所有东西，通过TcpServer 提供了三个成员函数来注册三个回调函数，连接成功和断开用了同一个回调函数。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:13:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"22.1 I/O 线程 TcpServer 正如其名，是一个服务器，而且是一个可以支持多线程Reactor的服务器，所以该服务器必须要有诸多IO线程： EventLoop *loop_; // the acceptor loop boost::scoped_ptr\u003cEventLoopThreadPool\u003e threadPool_; 它们在构造函数中被初始化： TcpServer::TcpServer(EventLoop* loop, const InetAddress\u0026 listenAddr, const string\u0026 nameArg) : loop_(CHECK_NOTNULL(loop)), ... threadPool_(new EventLoopThreadPool(loop)), ... nextConnId_(1) { ... } 可通过该函数来创建多少个IO线程： void TcpServer::setThreadNum(int numThreads) { assert(0 \u003c= numThreads); threadPool_-\u003esetThreadNum(numThreads); } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:13:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"22.2 Acceptor TcpServer使用Acceptor来操作监听套接字，而且需要一个监听套接字地址和端口： TcpServer::TcpServer(EventLoop* loop, const InetAddress\u0026 listenAddr, const string\u0026 nameArg) : loop_(CHECK_NOTNULL(loop)), hostport_(listenAddr.toIpPort()), ... acceptor_(new Acceptor(loop, listenAddr)), ... { // Acceptor::handleRead函数中会回调用TcpServer::newConnection // _1对应的是socket文件描述符，_2对应的是对等方的地址(InetAddress) acceptor_-\u003esetNewConnectionCallback( boost::bind(\u0026TcpServer::newConnection, this, _1, _2)); } 此时的Acceptor还没有加入事件监听中，也就是没有调用Acceptor::listen()方法。Acceptor需要TcpServer传入一个函数来处理连接事件，因为Acceptor只负责处理连接，所以只关注读事件： acceptChannel_.setReadCallback( boost::bind(\u0026Acceptor::handleRead, this)); ... void Acceptor::handleRead() { ... if (connfd \u003e= 0) { if (newConnectionCallback_) { newConnectionCallback_(connfd, peerAddr); } else { sockets::close(connfd); } } else { ... } } 而这个函数便是TcpServer::newConnection，该函数在下面详细介绍。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:13:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"22.3 启动服务器 调用该函数即可启动服务器： // 该函数多次调用是无害的 // 该函数可以跨线程调用 void TcpServer::start() { if (!started_) { started_ = true; threadPool_-\u003estart(threadInitCallback_); } if (!acceptor_-\u003elistenning()) { // get_pointer：返回原生指针 loop_-\u003erunInLoop(boost::bind(\u0026Acceptor::listen, get_pointer(acceptor_))); } } 该函数首先启动了IO线程池，并传入线程初始化函数，TcpServer中threadInitCallback_定义如下： typedef boost::function\u003cvoid(EventLoop *)\u003e ThreadInitCallback; ThreadInitCallback threadInitCallback_; // IO线程池中的线程在进入事件循环前，会回调用此函数 可通过该函数设置这一回调函数： void setThreadInitCallback(const ThreadInitCallback \u0026cb) { threadInitCallback_ = cb; } 在初始化IO后便启动了Acceptor，Acceptor加入了事件循环。值得一提的是，如果IO线程池设置线程数量为0，那么全局只有一个EventLoop，threadPool_中的EventLoop也是指向TcpServer中的EventLoop。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:13:3","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"22.4 处理客户端连接 Acceptor 绑定的\"读事件\"回调函数是newConnection，当有客户端连接时该函数将会被调用： void TcpServer::newConnection(int sockfd, const InetAddress \u0026peerAddr) { loop_-\u003eassertInLoopThread(); // 按照轮叫的方式选择一个EventLoop EventLoop *ioLoop = threadPool_-\u003egetNextLoop(); char buf[32]; snprintf(buf, sizeof buf, \":%s#%d\", hostport_.c_str(), nextConnId_); ++nextConnId_; string connName = name_ + buf; LOG_INFO \u003c\u003c \"TcpServer::newConnection [\" \u003c\u003c name_ \u003c\u003c \"] - new connection [\" \u003c\u003c connName \u003c\u003c \"] from \" \u003c\u003c peerAddr.toIpPort(); InetAddress localAddr(sockets::getLocalAddr(sockfd)); // FIXME poll with zero timeout to double confirm the new connection // FIXME use make_shared if necessary /*TcpConnectionPtr conn(new TcpConnection(loop_, connName, sockfd, localAddr, peerAddr));*/ TcpConnectionPtr conn( new TcpConnection(ioLoop, connName, sockfd, localAddr, peerAddr)); LOG_TRACE \u003c\u003c \"[1] usecount=\" \u003c\u003c conn.use_count(); connections_[connName] = conn; LOG_TRACE \u003c\u003c \"[2] usecount=\" \u003c\u003c conn.use_count(); conn-\u003esetConnectionCallback(connectionCallback_); conn-\u003esetMessageCallback(messageCallback_); conn-\u003esetWriteCompleteCallback(writeCompleteCallback_); conn-\u003esetCloseCallback( boost::bind(\u0026TcpServer::removeConnection, this, _1)); // FIXME: unsafe // conn-\u003econnectEstablished(); ioLoop-\u003erunInLoop(boost::bind(\u0026TcpConnection::connectEstablished, conn)); LOG_TRACE \u003c\u003c \"[5] usecount=\" \u003c\u003c conn.use_count(); } 该函数调用后，TcpServer将从threadPool_轮询方式获取一个EventLoop，让该EventLoop来处理新连接客户端套接字事件。接下来会创建一个TcpConnection，然后将该TcpConnection保存到connections_中，该成员变量定义如下： typedef std::map\u003cstring, TcpConnectionPtr\u003e ConnectionMap; ConnectionMap connections_; // 连接列表 再设置该TcpConnection的对应的三个半的回调事件，其中connectionCallback_和messageCallback_在构造函数中设置了默认处理函数，这两个默认函数里没有做任何实事： typedef boost::function\u003cvoid(const TcpConnectionPtr \u0026)\u003e ConnectionCallback; // the data has been read to (buf, len) typedef boost::function\u003cvoid(const TcpConnectionPtr \u0026, Buffer *, Timestamp)\u003e MessageCallback; ConnectionCallback connectionCallback_; MessageCallback messageCallback_; TcpServer::TcpServer(EventLoop *loop, const InetAddress \u0026listenAddr, const string \u0026nameArg) : ... connectionCallback_(defaultConnectionCallback), messageCallback_(defaultMessageCallback), started_(false), ... { ... } 可以通过如下函数来设置这些回调函数： /// Set connection callback. /// Not thread safe. // 设置连接到来或者连接关闭回调函数 void setConnectionCallback(const ConnectionCallback \u0026cb) { connectionCallback_ = cb; } /// Set message callback. /// Not thread safe. // 设置消息到来回调函数 void setMessageCallback(const MessageCallback \u0026cb) { messageCallback_ = cb; } /// Set write complete callback. /// Not thread safe. void setWriteCompleteCallback(const WriteCompleteCallback \u0026cb) { writeCompleteCallback_ = cb; } /// Internal use only. void setCloseCallback(const CloseCallback \u0026cb) { closeCallback_ = cb; } 需要注意的是，连接关闭回调函数绑定的是TcpServer::removeConnection： void TcpServer::removeConnection(const TcpConnectionPtr\u0026 conn) { // FIXME: unsafe loop_-\u003erunInLoop(boost::bind(\u0026TcpServer::removeConnectionInLoop, this, conn)); } void TcpServer::removeConnectionInLoop(const TcpConnectionPtr \u0026conn) { loop_-\u003eassertInLoopThread(); LOG_INFO \u003c\u003c \"TcpServer::removeConnectionInLoop [\" \u003c\u003c name_ \u003c\u003c \"] - connection \" \u003c\u003c conn-\u003ename(); LOG_TRACE \u003c\u003c \"[8] usecount=\" \u003c\u003c conn.use_count(); size_t n = connections_.erase(conn-\u003ename()); LOG_TRACE \u003c\u003c \"[9] usecount=\" \u003c\u003c conn.use_count(); (void)n; assert(n == 1); EventLoop *ioLoop = conn-\u003egetLoop(); ioLoop-\u003equeueInLoop(boost::bind(\u0026TcpConnection::connectDestroyed, conn)); // loop_-\u003equeueInLoop( // boost::bind(\u0026TcpConnection::connectDestroyed, conn)); LOG_TRACE \u003c\u003c \"[10] usecount=\" \u003c\u003c conn.use_count(); } 这一串函数将该TcpConnection从TcpServer的connections_中删除，TcpServer与该TcpConnection没有任何关系了，然后调用TcpConnection::connectDestroyed将该TcpConnection的连接套接字及其Channel与EventLoop及其Poller解除联系，这样一来就彻底除掉该TcpConnection了。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:13:4","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"22.5 释放资源 将connections_保存的所有TcpConnection全部去除，去除方法和前面TcpServer::removeConnectionInLoop去除单个TcpConnection的方法是一样的。 TcpServer::~TcpServer() { loop_-\u003eassertInLoopThread(); LOG_TRACE \u003c\u003c \"TcpServer::~TcpServer [\" \u003c\u003c name_ \u003c\u003c \"] destructing\"; for (ConnectionMap::iterator it(connections_.begin()); it != connections_.end(); ++it) { TcpConnectionPtr conn = it-\u003esecond; it-\u003esecond.reset(); // 释放当前所控制的对象，引用计数减一 conn-\u003egetLoop()-\u003erunInLoop( boost::bind(\u0026TcpConnection::connectDestroyed, conn)); conn.reset(); // 释放当前所控制的对象，引用计数减一 } } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:13:5","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"23. Connector Connector 是为TcpClient所调用的，一个客户端需要一个套接字来与服务端通信，muduo 使用Connector 来封装这个与服务端通信的套接字(如同Acceptor 封装了监听客户端连接的套接字)。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:14:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"23.1 设计思想 前面说到，该Connector 封装了一个客户端用于连接服务器的套接字，本着muduo中 Every Fd is Channel 的精神，Connector也同样遵循这样的准测： EventLoop *loop_; // 所属EventLoop boost::scoped_ptr\u003cChannel\u003e channel_; // Connector所对应的Channel 但是成员变量中却没有套接字，该套接字是在建立连接时才创建的，待创建成功才与channel_绑定： void Connector::connect() { int sockfd = sockets::createNonblockingOrDie(); // 创建非阻塞套接字 int ret = sockets::connect(sockfd, serverAddr_.getSockAddrInet()); ... } 而且从构造函数来看，该Channel也没有和EventLoop绑定，至于为什么这样做，在后面会详细介绍。 Connector::Connector(EventLoop* loop, const InetAddress\u0026 serverAddr) : loop_(loop), serverAddr_(serverAddr), connect_(false), state_(kDisconnected), retryDelayMs_(kInitRetryDelayMs) { LOG_DEBUG \u003c\u003c \"ctor[\" \u003c\u003c this \u003c\u003c \"]\"; } 构造函数中需要传入一个EventLoop和一个服务端地址结构，至于初始化列表中的后三个变量，在本文后续会详细介绍。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:14:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"23.2 连接服务端 调用Connector::start函数可启动Connector： // 可以跨线程调用 void Connector::start() { connect_ = true; loop_-\u003erunInLoop(boost::bind(\u0026Connector::startInLoop, this)); // FIXME: unsafe } 该函数又进而调用Connector::startInLoop函数： void Connector::startInLoop() { loop_-\u003eassertInLoopThread(); assert(state_ == kDisconnected); if (connect_) { connect(); } else { LOG_DEBUG \u003c\u003c \"do not connect\"; } } 由于一开始构造函数对state_的设置，assert(state_ == kDisconnected)成立。在Connector::start中已经将connect_设置为true，所以直接调用connect()函数，该函数定义如下： void Connector::connect() { int sockfd = sockets::createNonblockingOrDie(); // 创建非阻塞套接字 int ret = sockets::connect(sockfd, serverAddr_.getSockAddrInet()); int savedErrno = (ret == 0) ? 0 : errno; switch (savedErrno) { case 0: case EINPROGRESS: // 非阻塞套接字，未连接成功返回码是EINPROGRESS表示正在连接 case EINTR: case EISCONN: // 连接成功 connecting(sockfd); break; case EAGAIN: case EADDRINUSE: case EADDRNOTAVAIL: case ECONNREFUSED: case ENETUNREACH: retry(sockfd); // 重连 break; case EACCES: case EPERM: case EAFNOSUPPORT: case EALREADY: case EBADF: case EFAULT: case ENOTSOCK: LOG_SYSERR \u003c\u003c \"connect error in Connector::startInLoop \" \u003c\u003c savedErrno; sockets::close(sockfd); // 不能重连，关闭sockfd break; default: LOG_SYSERR \u003c\u003c \"Unexpected error in Connector::startInLoop \" \u003c\u003c savedErrno; sockets::close(sockfd); // connectErrorCallback_(); break; } } 在该函数中会创建一个非阻塞的套接字，并调用sockets::connect函数，如果连接成功则调用connecting函数，如果是连接超时，非阻塞套接字返回，那么调用retry函数，其他情况下都是出现错误，直接关闭该套接字。retry这种情况会在下一节内容中介绍，这部分主要关注connecting函数的调用： void Connector::connecting(int sockfd) { setState(kConnecting); assert(!channel_); // Channel与sockfd关联 channel_.reset(new Channel(loop_, sockfd)); // 设置可写回调函数，这时候如果socket没有错误，sockfd就处于可写状态 channel_-\u003esetWriteCallback( boost::bind(\u0026Connector::handleWrite, this)); // FIXME: unsafe // 设置错误回调函数 channel_-\u003esetErrorCallback( boost::bind(\u0026Connector::handleError, this)); // FIXME: unsafe // channel_-\u003etie(shared_from_this()); is not working, // as channel_ is not managed by shared_ptr channel_-\u003eenableWriting(); // 让Poller关注可写事件 } 该函数将state_设置为kConnecting状态，重置channel_的值，绑定EventLoop和连接成功的套接字sockfd，设置Channel的\"写\"和\"错误\"回调函数，并使能\"写\"，这样一来，Channel及其连接套接字就在EventLoop的Poller中了。 Connector::handleWrite和Connector::handleError两个函数会在下几节介绍。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:14:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"23.3 错误处理与重连 当连接套接字上出现错误时将调用该函数： void Connector::handleError() { LOG_ERROR \u003c\u003c \"Connector::handleError\"; assert(state_ == kConnecting); int sockfd = removeAndResetChannel(); // 从poller中移除关注，并将channel置空 int err = sockets::getSocketError(sockfd); LOG_TRACE \u003c\u003c \"SO_ERROR = \" \u003c\u003c err \u003c\u003c \" \" \u003c\u003c strerror_tl(err); retry(sockfd); } 在该函数中会调用removeAndResetChannel函数，removeAndResetChannel会清除该连接套接字Channel和EventLoop的Poller绑定，释放channel_智能指针所管理的内存，并将该连接套接字返回： int Connector::removeAndResetChannel() { channel_-\u003edisableAll(); channel_-\u003eremove(); // 从poller移除关注 int sockfd = channel_-\u003efd(); // Can't reset channel_ here, because we are inside Channel::handleEvent // 不能在这里重置channel_，因为正在调用Channel::handleEvent loop_-\u003equeueInLoop( boost::bind(\u0026Connector::resetChannel, this)); // FIXME: unsafe return sockfd; } void Connector::resetChannel() { channel_.reset(); // channel_ 置空 } 回到Connector::handleError函数，在清理资源并获取到产生错误的sockfd后，该函数会再调用retry函数尝试连接： // 采用back-off策略重连，即重连时间逐渐延长，0.5s, 1s, 2s, ...直至30s void Connector::retry(int sockfd) { sockets::close(sockfd); setState(kDisconnected); if (connect_) { LOG_INFO \u003c\u003c \"Connector::retry - Retry connecting to \" \u003c\u003c serverAddr_.toIpPort() \u003c\u003c \" in \" \u003c\u003c retryDelayMs_ \u003c\u003c \" milliseconds. \"; // 注册一个定时操作，重连 loop_-\u003erunAfter(retryDelayMs_ / 1000.0, boost::bind(\u0026Connector::startInLoop, shared_from_this())); retryDelayMs_ = std::min(retryDelayMs_ * 2, kMaxRetryDelayMs); } else { LOG_DEBUG \u003c\u003c \"do not connect\"; } } 在介绍retry函数之前需要了解这两个常量： static const int kMaxRetryDelayMs = 30 * 1000; // 30秒，最大重连延迟时间 static const int kInitRetryDelayMs = 500; // 0.5秒，初始状态，连接不上，0.5秒后重连 kInitRetryDelayMs指的是过500ms便发动一次连接，尝试连接到服务器；kMaxRetryDelayMs指的是尝试超时连接总时间为30*1000ms。在retry函数中调用了runAfter定时函数来尝试连接。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:14:3","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"23.4 处理\"写\"事件 如果socket没有错误，sockfd就处于可写状态，函数定义如下： void Connector::handleWrite() { LOG_TRACE \u003c\u003c \"Connector::handleWrite \" \u003c\u003c state_; if (state_ == kConnecting) { int sockfd = removeAndResetChannel(); // 从poller中移除关注，并将channel置空 // socket可写并不意味着连接一定建立成功 // 还需要用getsockopt(sockfd, SOL_SOCKET, SO_ERROR, ...)再次确认一下。 int err = sockets::getSocketError(sockfd); if (err) // 有错误 { LOG_WARN \u003c\u003c \"Connector::handleWrite - SO_ERROR = \" \u003c\u003c err \u003c\u003c \" \" \u003c\u003c strerror_tl(err); retry(sockfd); // 重连 } else if (sockets::isSelfConnect(sockfd)) // 自连接 { LOG_WARN \u003c\u003c \"Connector::handleWrite - Self connect\"; retry(sockfd); // 重连 } else // 连接成功 { setState(kConnected); if (connect_) { newConnectionCallback_(sockfd); // 回调 } else { sockets::close(sockfd); } } } else { // what happened? assert(state_ == kDisconnected); } } 在该函数中只是获取到连接成功套接字的文件描述符sockfd，并且将Channel清除，然后调用newConnectionCallback_函数，该函数在TcpClient中传入。为什么要将该连接Channel移除是有原因的，客户端连接套接字只有一个，而Connector中已经将该套接字与自己的Channel绑定了，只是负责连接而已，connect函数调用成功该套接字则变得可写，这时的Connector已经完成任务了，需要将该套接字的所有权转让给TcpClient，所以调用了newConnectionCallback_函数，而该函数在TcpClient中给该套接字绑定了一个新的Channel，该Channel和Connector中的Channel同属于一个EventLoop，所以转移所有权需要彻底，Connector中的Channel必须要被移除，否则将导致\"串台\"。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:14:4","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"23.5 重置连接 “断线重连\"和\"重置连接\"是两个概念，“断线重连\"指的是在已经连接成功的情况下又断开连接，再多次尝试连接；“重置连接\"指的是放弃之前的连接，从零开始连接： // 不能跨线程调用 void Connector::restart() { loop_-\u003eassertInLoopThread(); setState(kDisconnected); retryDelayMs_ = kInitRetryDelayMs; connect_ = true; startInLoop(); } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:14:5","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"24. TcpClient 在Connector中说到\"在该函数中只是获取到连接成功套接字的文件描述符sockfd，并且将Channel清除，然后调用newConnectionCallback_函数，该函数在TcpClient中传入”，Connector::handleWrite函数是被TcpClient调用的，那么我们先一窥newConnectionCallback_函数究竟。 在此之前，先看看TcpClient中的Connector： typedef boost::shared_ptr\u003cConnector\u003e ConnectorPtr; EventLoop *loop_; ConnectorPtr connector_; // 用于主动发起连接 TcpClient::TcpClient(EventLoop* loop, const InetAddress\u0026 serverAddr, const string\u0026 name) : loop_(CHECK_NOTNULL(loop)), connector_(new Connector(loop, serverAddr)), name_(name), ... { // 设置连接成功回调函数 connector_-\u003esetNewConnectionCallback( boost::bind(\u0026TcpClient::newConnection, this, _1)); // FIXME setConnectFailedCallback LOG_INFO \u003c\u003c \"TcpClient::TcpClient[\" \u003c\u003c name_ \u003c\u003c \"] - connector \" \u003c\u003c get_pointer(connector_); } 在构造函数中，Connector被设置了新连接回调函数TcpClient::newConnection，也就是前面的newConnectionCallback_，该函数定义如下： void TcpClient::newConnection(int sockfd) { loop_-\u003eassertInLoopThread(); InetAddress peerAddr(sockets::getPeerAddr(sockfd)); char buf[32]; snprintf(buf, sizeof buf, \":%s#%d\", peerAddr.toIpPort().c_str(), nextConnId_); ++nextConnId_; string connName = name_ + buf; InetAddress localAddr(sockets::getLocalAddr(sockfd)); // FIXME poll with zero timeout to double confirm the new connection // FIXME use make_shared if necessary TcpConnectionPtr conn( new TcpConnection(loop_, connName, sockfd, localAddr, peerAddr)); conn-\u003esetConnectionCallback(connectionCallback_); conn-\u003esetMessageCallback(messageCallback_); conn-\u003esetWriteCompleteCallback(writeCompleteCallback_); conn-\u003esetCloseCallback( boost::bind(\u0026TcpClient::removeConnection, this, _1)); // FIXME: unsafe { MutexLockGuard lock(mutex_); connection_ = conn; // 保存TcpConnection } conn-\u003econnectEstablished(); // 这里回调connectionCallback_ } 该函数将连接成功的socfd封装为一个TcpConnection，并设置\"三个半\"回调事件函数。好的，到了这里就解释了前面Connector为什么不自己持有一个sockfd、为什么要在连接成功时清空Channel等诸多问题。拿到连接成功套接字后，创建TcpConnection与服务器进行数据交换。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:15:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"25 TCP网络编程本质 TCP网络编程最本质是的处理三个半事件： 连接建立：服务器accept(被动)接受连接，客户端connect(主动)发起连接 连接断开：主动断开(close、shutdown)，被动断开(read返回0) 消息到达：文件描述符可读 消息发送完毕：这算半个。对于低流量的服务，可不必关心这个事件;这里的发送完毕是指数据写入操作系统缓冲区，将由TCP协议栈负责数据的发送与重传，不代表对方已经接收到数据。 一个套接字有两个缓冲区，一个接收缓冲区一个发送缓冲区，当一个套接字到来的时候先被内核缓冲区接收。 当网络库事件循环中的可读事件触发，会将数据从内核缓冲区移动到应用缓冲区中。并且网络库会回调函数，如：OnMessage。由于TCP接收到的数据可能是宕包，OnMessage这个函数会根据协议判断这个数据包是否是完整的数据包，如果不是完整的数据OnMessage立刻返回，直到内核当中又有数据接收，进行下一次循环操作；如果读到完整的数据，将进行常规处理(read-\u003edecode-\u003ecompute-\u003eencode-\u003ewrite-\u003e进行下一次事件循环)。 调用write(buf,..)函数：如果数据全部填充到了内核缓冲区，网络库回调一个函数，如：OnWriteComplete函数。如果内核缓冲区的不足以容纳buf数据，就会将buf部分的数据放入进来，不足以容纳的数据存放到应用层的发送缓冲区当中。内核的发送缓冲区的数据发送完成后会触发可写事件，继续下一次的事件循环。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:16:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"25.1 连接建立 当我们创建一个TcpServer对象，构造函数将实例化了一个Acceptor对象，并往这个Acceptor对象注册了一个回调函数TcpServer::newConnection()。 Acceptor的构造函数会实例化一个Channel对象，即acceptChannel_，该Channel对象封装了服务器监听套接字文件描述符（尚未注册到main EventLoop的事件监听器上）。 接着Acceptor构造函数将Acceptor::handleRead()方法注册进acceptChannel_中，这也意味着，以后如果事件监听器监听到acceptChannel_发生可读事件，将会调用Acceptor::handleRead()函数。 至此，TcpServer对象创建完毕，用户调用TcpServer::start()方法，启动TcpServer。 cpServer::start()方法主要是调用Acceptor::listen()函数（底层是调用了linux的函数listen()）监听服务器套接字，以及将acceptChannel_注册到main EventLoop的事件监听器上监听它的可读事件（新用户连接事件）。 接着用户调用loop.loop()，即调用了EventLoop::loop()函数，该函数就会循环的获取事件监听器的监听结果，并且根据监听结果调用注册在事件监听器上的Channel对象的事件处理函数。 当回调Acceptor::handleRead()函数，说明acceptChannel_发生可读事件，程序处理新客户连接请求。该函数首先调用了Linux的函数accept()接受新客户连接。接着调用了TcpServer::newConnection()函数，这个函数是TcpServer注册给Acceptor，并由TcpServer成员变量newConnectionCallback_保存。 TcpServer::newConnection()函数的主要功能就是将建立好的连接进行封装（封装成TcpConnection对象），并使用轮询的方式选择一个sub EventLoop，并调用TcpConnection::connectEstablished()将TcpConnection::channel_注册到刚刚选择的sub EventLoop上。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:16:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"25.2 消息到达 在main EventLoop中接受新连接请求之后，将这条Tcp连接封装成TcpConnection对象。其主要封装了连接套接字的fd(socket_)、连接套接字的channel_等。在TcpConnection的构造函数中会将TcpConnection::handleRead()、TcpConnection::handleWrite()、TcpConnection::handleClose()、TcpConnection::handleError()这个四个方法注册进这个channel_内。当TcpConnection对象建立完毕之后，main EventLoop的Acceptor会将这个TcpConnection对象中的channel_注册到某一个SubEventLoop中。 如上图所示，SubEventLoop中的EventLoop::loop()函数内部会循环的执行上图中的步骤1和步骤2。 步骤1就是调用Poller::poll()方法获取事件监听结果，这个事件监听结果是一个Channel集合，每一个Channel封装着一个fd及fd感兴趣的事件和事件监听器监听到该fd实际发生的事件。 步骤2就是调用每一个Channel的Channel::HandlerEvent方法。该方法会根据每一个Channel的感兴趣事件以及实际发生的事件调用提前注册在Channel内的对应的事件处理函数（readCallback_、writeCallback_、closeCallback_、errorCallback_)。readCallback_保存的函数其实是TcpConnection::handleRead()，消息读取的处理逻辑也就是由这个函数提供的。 TcpConnection::handleRead()函数首先调用Buffer_.readFd(channel_-\u003efd(), \u0026saveErrno)，该函数底层调用Linux的函数readv()，将Tcp接收缓冲区数据拷贝到用户定义的缓冲区中（inputBuffer_）。如果在读取拷贝的过程中发生了什么错误，这个错误信息就会保存在savedErrno中。 当readFd()返回值大于0，说明从接收缓冲区中读取到了数据，那么会接着调用messageCallback_中保存的用户自定义的读取消息后的处理函数。 当readFd()返回值等于0，说明客户端连接关闭，这时候应该调用TcpConnection::handleClose()来处理连接关闭事件。 当readFd()返回值等于-1，说明发生了错误，调用TcpConnection::handleError()来处理savedErrno的错误事件。 Moduo库只支持LT模式，所以读事件不会出现EAGAIN的错误，所以一旦出现错误，说明肯定是比较不好的非正常错误了。而EAGAIN错误只不过是非阻塞IO调用时的一种常见错误而已。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:16:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"25.3 消息发送完毕 当用户调用了TcpConnetion::send(buf)函数时，相当于要求muduo库把数据buf发送给该Tcp连接的客户端。此时该TcpConnection注册在事件监听器上的感兴趣事件中是没有可写事件的。TcpConnection::send(buf)函数内部，对持有的Channel设置\"写行为”，当内核发送缓冲区有空间了，回调TcpConnection::handleWrite()，其内部就会调用了Linux的函数write()。如果TCP发送缓冲区能一次性容纳buf，那这个write()函数将buf全部拷贝到发送缓冲区中，就停止\"写行为”，否则等到下一次事件循环再次回调TcpConnection::handleWrite()函数，直至清空发送缓冲区。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:16:3","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"25.4 连接断开 连接断开分为：主动断开(close、shutdown)和被动断开(read返回0)。 25.4.1 被动断开 服务端TcpConnection::handleRead()中read返回0感知到客户端把连接断开了。TcpConnection::handleRead()函数内部调用了Linux的函数readv()，当readv()返回0的时候，服务端就知道客户端断开连接了。然后就接着调用TcpConnection::handleClose()。 在执行TcpConnection::handleClose()的时候，该函数还是在sub EventLoop线程中运行的，接着调用closeCallback_(const TcpConnectionPtr \u0026connPtr)回调函数，该函数保存的其实是TcpServer::removeConnection()函数。 TcpServer::removeConnection()函数调用了removeConnectionInLoop()函数，该函数的运行是在main EventLoop线程中执行的。 removeConnectionInLoop()函数：TcpServer对象中有一个connections_成员变量，这是一个unordered_map，负责保存string –\u003e TcpConnection的映射，其实就是保存着Tcp连接的名字到TcpConnection对象的映射。因为这个Tcp连接要关闭了，所以也要把这个TcpConnection对象从connections_中删掉。然后再调用TcpConnection::connectDestroyed函数。 为什么removeConnectionInLoop()要在main EventLoop中运行，因为该函数需要从TcpServer对象中删除某条数据。而TcpServer对象是属于main EventLoop的。这也是贯彻了One Loop Per Thread的理念。 TcpConnection::connectDestroyed()函数的执行是又跳回到了sub EventLoop线程中。该函数就是将Tcp连接的监听描述符从事件监听器中移除。另外sub EventLoop中的Poller类对象还保存着这条Tcp连接的channel_，所以调用channel_.remove()将这个Tcp连接的channel对象从Poller内的数据结构中删除。 25.4.2 主动断开 当服务器主动关闭时，调用TcpServer::~TcpServer()析构函数。 在创建TcpConnection对象时，Acceptor都要将这个对象分发给一个sub EventLoop来管理。这个TcpConnection对象的一切函数执行都要在其管理的sub EventLoop线程中运行。再一次贯彻One Loop Per Thread的设计模式。比如要想彻底删除一个TcpConnection对象，就必须要调用这个对象的connecDestroyed()方法，这个方法执行完后才能释放这个对象的堆内存。每个TcpConnection对象的connectDestroyed()方法都必须在这个TcpConnection对象所属的SubEventLoop绑定的线程中执行。 不断循环的让这个TcpConnection对象所属的SubEventLoop线程执行TcpConnection::connectDestroyed()函数，同时在MainEventLoop的TcpServer::~TcpServer()函数中调用item.second.reset()释放保管TcpConnection对象的共享智能指针，以达到释放TcpConnection对象的堆内存空间的目的。 TcpConnection::connectDestroyed()函数的执行以及这个TcpConnection对象的堆内存释放操作不在同一个线程中运行，所以要考虑怎么保证一个TcpConnectino对象的堆内存释放操作是在TcpConnection::connectDestroyed()调用完后。这个析构函数巧妙利用了共享智能指针的特点，当没有共享智能指针指向这个TcpConnection对象时（引用计数为0），这个TcpConnection对象就会被析构删除（堆内存释放）。 TcpServer::~TcpServer()中的代码逻辑： 首先TcpServer::connections_是一个unordered_map\u003cstring, TcpConnectionPtr\u003e，其中TcpConnectionPtr的含义是指向TcpConnection的shared_ptr。 在一开始，每一个TcpConnection对象都被一个共享智能指针TcpConnetionPtr持有，当执行了TcpConnectionPtr conn = it-\u003esecond;时，这个TcpConnetion对象就被conn和这个item.second共同持有，但是这个conn的生存周期很短，只要离开了当前的这一次for循环，conn就会被释放。 紧接着调用it-\u003esecond.reset()释放掉TcpServer中保存的该TcpConnectino对象的智能指针。此时在当前情况下，只剩下conn还持有这个TcpConnection对象，因此当前TcpConnection对象还不会被析构。 接着调用了conn-\u003egetLoop()-\u003erunInLoop(bind(\u0026TcpConnection::connectDestroyed, conn));，是让sub EventLoop线程去执行TcpConnection::connectDestroyed()函数。当你把这个conn的成员函数传进去的时候，conn所指向的资源的引用计数会加1。因为传给runInLoop的不只有函数，还有这个函数所属的对象conn。 sub EventLoop线程开始运行TcpConnection::connectDestroyed() main EventLoop线程当前这一轮for循环跑完，共享智能指针conn离开代码块，因此被析构，但是TcpConnection对象还不会被释放，因为还有一个共享智能指针指向这个TcpConnection对象，而且这个智能指针在TcpConnection::connectDestroyed()中，只不过这个智能指针你看不到，它在这个函数中是一个隐式的this的存在。当这个函数执行完后，智能指针就真的被释放了。到此，就没有任何智能指针指向这个TcpConnection对象了。TcpConnection对象就彻底被析构删除了。 如果TcpConnection中有正在发送的数据，怎么保证在触发TcpConnection关闭机制后，能先让TcpConnection先把数据发送完再释放TcpConnection对象的资源？ void TcpConnection::connectEstablished() { loop_-\u003eassertInLoopThread(); assert(state_ == kConnecting); setState(kConnected); LOG_TRACE \u003c\u003c \"[3] usecount=\" \u003c\u003c shared_from_this().use_count(); // enable_shared_from_this是一个以其派生类为模板类型参数的基类模板，继承它，派生类的this指针就能变成一个shared_ptr。 channel_-\u003etie(shared_from_this()); channel_-\u003eenableReading(); // TcpConnection所对应的通道加入到Poller关注 connectionCallback_(shared_from_this()); LOG_TRACE \u003c\u003c \"[4] usecount=\" \u003c\u003c shared_from_this().use_count(); } TcpConnection类继承了一个类： class TcpConnection :public std::enable_shared_from_this\u003cTcpConnection\u003e 我们在TcpConnection对象中的成员函数中调用了shared_from_this()，该函数可以返回一个shared_ptr，并且这个shared_ptr指向的对象是TcpConnection本身。 接着这个shared_ptr就作为channel_的Channel::tie()函数的函数参数。 //Channel.h std::weak_ptr\u003cvoid\u003e tie_; void Channel::handleEvent(Timestamp receiveTime) { boost::shared_ptr\u003cvoid\u003e guard; if (tied_) { guard = tie_.lock(); // 确定shared_ptr指针还存在 if (guard) { handleEventWithGuard(receiveTime); } } else { handleEventWithGuard(receiveTime); } } 当事件监听器返回监听结果，就要对每一个发生事件的Channel对象调用它们的handleEvent()函数。在这个handleEvent函数中，会先把tie_这个weak_ptr","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:16:4","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"26. 阶段性总结 multiple reactors + threadpool (one loop per thread + threadpool)：Reactor 最核心的事件就是事件分发机制，即将IO multiplexing 拿到的IO事件分发给各个文件描述符(fd)的事件处理函数(handle)。 EventLoop起到一个驱动循环的功能，Poller负责从事件监听器上获取监听结果。而Channel类则在其中起到了将fd及其相关属性封装的作用，将fd及其感兴趣事件和发生的事件以及不同事件对应的回调函数封装在一起，这样在各个模块中传递更加方便。 Muduo库是基于Reactor模式实现的TCP网络编程库。Multi-Reactor模型如下所示： 一张图总结服务/客户端调用关系： 白色部分是外部类，对外可见的。灰色部分是内部类，对外不可见。黑色尖头是组合关系，负责生命周期。白色是聚合关系不负责生命周期。 EventLoop是对事件的抽象。一个EventLoop的Poller对象包含多个Channel，也就是说可以扑捉多个Channel的多个可读、可写事件。 Poller 是对IO 复用的抽象，有两个派生类：PollPoller 对poll 的封装，EPollPoller对epoll的封装。这个地方是muduo 唯一使用面向对象封装的。 Channel 是对IO事件的注册和响应的封装。Channel 的Update成员函数负责注册和更新IO的可读可写等事件。Channel 的handleEvent()成员函数是对所发生的IO事件进行处理。 Channel是selectable IO channel，负责注册与响应IO 事件，它不拥有file descriptor。 Channel是Acceptor、Connector、EventLoop、TimerQueue、TcpConnection的成员，生命期由后者控制。EventLoop 有一个特殊的Channel 用来唤醒loop实现跨线程调用，这个特殊的Channel的生命期由EventLoop负责。 TcpConnection负责一个客户端连接成功套接字，一旦被动连接(Acceptor)或主动连接(Connector)建立，就会得到一个已连接的套接字。 Acceptor负责一个服务器listen套接字，Accept被动连接，连接成功后都会创建一个TcpConnection对象。 Connector负责一个客户端connect套接字，Connector主动连接，连接成功后会创建一个TcpConnection对象。 TcpServer中持有Acceptor，通过Acceptor获取新的连接套接字，然后TcpServer会为该连接套接字建立一个TcpConnection，然后往该TcpConnection中传递用户需要TcpServer相应事件对应的函数，用户传入的函数其实是和TcpConnection中的Channel间接绑定，然后在事件触发后被Channel间接执行。 TcpClient中持有Connector，通过Connector里的Channel绑定一个连接套接字，在连接成功后，Connector会将该套接字转让给TcpClient，TcpClient中会为该连接套接字建立一个TcpConnection，然后往该TcpConnection中传递用户需要TcpClient相应事件对应的函数，用户传入的函数其实是和TcpConnection中的Channel间接绑定，然后在事件触发后被Channel间接执行。 EventLoop与Poller的关系是组合，一个EventLoop包含一个Poller，并且Poller的生命周期由EventLoop控制，EventLoop::loop()函数实际是通过Poller::poll()函数来实现的。 Channel是对I/O事件的注册与响应的封装，Channel::update()函数负责注册或更新I/O的可读和可写事件，同时会调用到EventLoop::updateChannel()函数，这个函数又会调用Poller::updateChannel()函数，相当于将这个Channle这个对象注册到Poller对象中，或者说将Channel对象中的fd(文件描述符)的可读、可写事件注册到Poller对象中；Channel::handleEvent()函数负责对所发生的I/O事件进行处理。一个EventLoop对象包含多个Channel对象，也就是说EventLoop可捕获多个Channel(通道)的可读、可写事件。一对多，且是聚合的关系。也就是说EventLoop不负责Channel的生命周期。Channel的生命周期由TcpConnection、Acceptor、Connector等等这些类来控制。Channel对象不拥有fd(文件描述符)，也就是说当Channel对象销毁的时候不关闭文件描述符。Channel对象和文件描述符是关联关系，一个Chanel有一个fd，一个EventLoop有多个fd，而这个fd是被套接字(Socket)所拥有的。也就是说fd的生命周期由套接字来控制，当套接字对象销毁时，文件描述符对象就会销毁(Socket::close)。 Chanel对象又是TcpConnection、Acceptor、Connector类的成员，它们与Channel对象之间也是组合关系，Channel的生命周期由它们来控制。 Acceptor是对被动连接的抽象，它关心的是监听事件的可读事件，监听事件的可读事件是由Channel来注册，触发事件调用Channel::handleEvent()函数，这个函数通过回调从而调用Acceptor::handleRead()函数来响应事件。这样的手法是基于对象的编程思想。 TcpConnection是对已连接套接字的抽象。 一旦被动连接(Acceptor)或主动连接(Connector)建立，就会得到一个已连接的套接字。即获得TcpConnection。 TcpServer和Acceptor是组合关系，TcpServer控制着Acceptor的生命周期。 TcpClient和Connector是组合关系，TcpClient控制着Connector的生命周期。 TcpServer与TcpConnection是聚合关系，一个TcpServer包含多个TcpConnection，但不控制TcpConnection的生命周期。 ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:17:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"Test ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:18:0","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"EventLoop 启动两个事件循环： #include \"EventLoop.h\" #include \u003cstdio.h\u003e using namespace muduo; using namespace muduo::net; void threadFunc() { printf(\"threadFunc(): pid = %d, tid = %d\\n\", getpid(), CurrentThread::tid()); EventLoop loop; loop.loop(); } int main(void) { printf(\"main(): pid = %d, tid = %d\\n\", getpid(), CurrentThread::tid()); EventLoop loop; Thread t(threadFunc); t.start(); loop.loop(); t.join(); return 0; } 一个EventLoop存在共享于两个线程中将会触发assertInLoopThread断言： #include \"EventLoop.h\" #include \u003cstdio.h\u003e using namespace muduo; using namespace muduo::net; EventLoop *g_loop; void threadFunc() { g_loop-\u003eloop(); } int main(void) { EventLoop loop; g_loop = \u0026loop; Thread t(threadFunc); t.start(); t.join(); return 0; } runInLoop实现跨线程安全调用的测试： #include \"EventLoop.h\" #include \u003cstdio.h\u003e using namespace muduo; using namespace muduo::net; EventLoop *g_loop; int g_flag = 0; void run4() { printf(\"run4(): pid = %d, flag = %d\\n\", getpid(), g_flag); g_loop-\u003equit(); } void run3() { printf(\"run3(): pid = %d, flag = %d\\n\", getpid(), g_flag); g_loop-\u003erunAfter(3, run4); g_flag = 3; } void run2() { printf(\"run2(): pid = %d, flag = %d\\n\", getpid(), g_flag); g_loop-\u003equeueInLoop(run3); // 异步地将run3方法添加到任务队列中 } void run1() { g_flag = 1; printf(\"run1(): pid = %d, flag = %d\\n\", getpid(), g_flag); g_loop-\u003erunInLoop(run2); g_flag = 2; } int main() { printf(\"main(): pid = %d, flag = %d\\n\", getpid(), g_flag); EventLoop loop; g_loop = \u0026loop; loop.runAfter(2, run1); loop.loop(); printf(\"main(): pid = %d, flag = %d\\n\", getpid(), g_flag); } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:18:1","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"TimerQueue 定时器的初步构思： #include \"Channel.h\" #include \"EventLoop.h\" #include \u003cboost/bind.hpp\u003e #include \u003cstdio.h\u003e #include \u003csys/timerfd.h\u003e using namespace muduo; using namespace muduo::net; EventLoop *g_loop; int timerfd; void timeout(Timestamp receiveTime) { printf(\"Timeout!\\n\"); uint64_t howmany; ::read(timerfd, \u0026howmany, sizeof howmany); g_loop-\u003equit(); } int main(void) { EventLoop loop; g_loop = \u0026loop; timerfd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC); Channel channel(\u0026loop, timerfd); channel.setReadCallback(boost::bind(timeout, _1)); channel.enableReading(); struct itimerspec howlong; bzero(\u0026howlong, sizeof howlong); howlong.it_value.tv_sec = 1; ::timerfd_settime(timerfd, 0, \u0026howlong, NULL); loop.loop(); ::close(timerfd); } TimerQueue测试： #include \"EventLoop.h\" #include \"EventLoopThread.h\" #include \"Thread.h\" #include \u003cboost/bind.hpp\u003e #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e using namespace muduo; using namespace muduo::net; int cnt = 0; EventLoop *g_loop; void printTid() { printf(\"pid = %d, tid = %d\\n\", getpid(), CurrentThread::tid()); printf(\"now %s\\n\", Timestamp::now().toString().c_str()); } void print(const char *msg) { printf(\"msg %s %s\\n\", Timestamp::now().toString().c_str(), msg); if (++cnt == 20) { g_loop-\u003equit(); } } void cancel(TimerId timer) { g_loop-\u003ecancel(timer); printf(\"cancelled at %s\\n\", Timestamp::now().toString().c_str()); } int main() { printTid(); sleep(1); { EventLoop loop; g_loop = \u0026loop; print(\"main\"); loop.runAfter(1, boost::bind(print, \"once1\")); loop.runAfter(1.5, boost::bind(print, \"once1.5\")); loop.runAfter(2.5, boost::bind(print, \"once2.5\")); loop.runAfter(3.5, boost::bind(print, \"once3.5\")); TimerId t45 = loop.runAfter(4.5, boost::bind(print, \"once4.5\")); loop.runAfter(4.2, boost::bind(cancel, t45)); loop.runAfter(4.8, boost::bind(cancel, t45)); loop.runEvery(2, boost::bind(print, \"every2\")); TimerId t3 = loop.runEvery(3, boost::bind(print, \"every3\")); loop.runAfter(9.001, boost::bind(cancel, t3)); loop.loop(); print(\"main loop exits\"); } sleep(1); { EventLoopThread loopThread; EventLoop *loop = loopThread.startLoop(); loop-\u003erunAfter(2, printTid); sleep(3); print(\"thread loop exits\"); } return 0; } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:18:2","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"EventLoopThread #include \"EventLoop.h\" #include \"EventLoopThread.h\" #include \u003cstdio.h\u003e using namespace muduo; using namespace muduo::net; void runInThread() { printf(\"runInThread(): pid = %d, tid = %d\\n\", getpid(), CurrentThread::tid()); } int main() { printf(\"main(): pid = %d, tid = %d\\n\", getpid(), CurrentThread::tid()); EventLoopThread loopThread; EventLoop *loop = loopThread.startLoop(); // 异步调用runInThread，即将runInThread添加到loop对象所在IO线程，让该IO线程执行 loop-\u003erunInLoop(runInThread); sleep(1); // runAfter内部也调用了runInLoop，所以这里也是异步调用 loop-\u003erunAfter(2, runInThread); sleep(3); loop-\u003equit(); printf(\"exit main().\\n\"); } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:18:3","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"Acceptor 服务启动后，模拟客户端连接telnet 127.0.0.1 8888 #include \"Acceptor.h\" #include \"EventLoop.h\" #include \"InetAddress.h\" #include \"SocketsOps.h\" #include \u003cstdio.h\u003e using namespace muduo; using namespace muduo::net; void newConnection(int sockfd, const InetAddress \u0026peerAddr) { printf(\"newConnection(): accepted a new connection from %s\\n\", peerAddr.toIpPort().c_str()); ::write(sockfd, \"How are you?\\n\", 13); sockets::close(sockfd); } int main() { printf(\"main(): pid = %d\\n\", getpid()); InetAddress listenAddr(8888); EventLoop loop; Acceptor acceptor(\u0026loop, listenAddr); acceptor.setNewConnectionCallback(newConnection); acceptor.listen(); loop.loop(); return 0; } ","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:18:4","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"TcpServer 服务启动后，模拟客户端连接telnet 127.0.0.1 8888 #include \"EventLoop.h\" #include \"InetAddress.h\" #include \"TcpServer.h\" #include \u003cstdio.h\u003e using namespace muduo; using namespace muduo::net; void onConnection(const TcpConnectionPtr \u0026conn) { if (conn-\u003econnected()) { printf(\"onConnection(): new connection [%s] from %s\\n\", conn-\u003ename().c_str(), conn-\u003epeerAddress().toIpPort().c_str()); } else { printf(\"onConnection(): connection [%s] is down\\n\", conn-\u003ename().c_str()); } } void onMessage(const TcpConnectionPtr \u0026conn, Buffer *buf, Timestamp receiveTime) { string msg(buf-\u003eretrieveAllAsString()); printf(\"onMessage(): received %zd bytes from connection [%s] at %s\\n\", msg.size(), conn-\u003ename().c_str(), receiveTime.toFormattedString().c_str()); conn-\u003esend(msg); } int main() { printf(\"main(): pid = %d\\n\", getpid()); InetAddress listenAddr(8888); EventLoop loop; TcpServer server(\u0026loop, listenAddr, \"TestServer\"); server.setConnectionCallback(onConnection); server.setMessageCallback(onMessage); server.start(); loop.loop(); } #include \"EventLoop.h\" #include \"InetAddress.h\" #include \"TcpServer.h\" #include \u003cboost/bind.hpp\u003e #include \u003cstdio.h\u003e using namespace muduo; using namespace muduo::net; class TestServer { public: TestServer(EventLoop *loop, const InetAddress \u0026listenAddr) : loop_(loop), server_(loop, listenAddr, \"TestServer\") { server_.setConnectionCallback( boost::bind(\u0026TestServer::onConnection, this, _1)); server_.setMessageCallback( boost::bind(\u0026TestServer::onMessage, this, _1, _2, _3)); } void start() { server_.start(); } private: void onConnection(const TcpConnectionPtr \u0026conn) { if (conn-\u003econnected()) { printf(\"onConnection(): new connection [%s] from %s\\n\", conn-\u003ename().c_str(), conn-\u003epeerAddress().toIpPort().c_str()); } else { printf(\"onConnection(): connection [%s] is down\\n\", conn-\u003ename().c_str()); } } void onMessage(const TcpConnectionPtr \u0026conn, Buffer *buf, Timestamp receiveTime) { string msg(buf-\u003eretrieveAllAsString()); printf(\"onMessage(): received %zd bytes from connection [%s] at %s\\n\", msg.size(), conn-\u003ename().c_str(), receiveTime.toFormattedString().c_str()); conn-\u003esend(msg); } EventLoop *loop_; TcpServer server_; }; int main() { printf(\"main(): pid = %d\\n\", getpid()); InetAddress listenAddr(8888); EventLoop loop; TestServer server(\u0026loop, listenAddr); server.start(); loop.loop(); } #include \"EventLoop.h\" #include \"InetAddress.h\" #include \"TcpServer.h\" #include \u003cboost/bind.hpp\u003e #include \u003cstdio.h\u003e using namespace muduo; using namespace muduo::net; class TestServer { public: TestServer(EventLoop *loop, const InetAddress \u0026listenAddr) : loop_(loop), server_(loop, listenAddr, \"TestServer\") { server_.setConnectionCallback( boost::bind(\u0026TestServer::onConnection, this, _1)); server_.setMessageCallback( boost::bind(\u0026TestServer::onMessage, this, _1, _2, _3)); message1_.resize(100); message2_.resize(200); std::fill(message1_.begin(), message1_.end(), 'A'); std::fill(message2_.begin(), message2_.end(), 'B'); } void start() { server_.start(); } private: void onConnection(const TcpConnectionPtr \u0026conn) { if (conn-\u003econnected()) { printf(\"onConnection(): new connection [%s] from %s\\n\", conn-\u003ename().c_str(), conn-\u003epeerAddress().toIpPort().c_str()); conn-\u003esend(message1_); conn-\u003esend(message2_); conn-\u003eshutdown(); } else { printf(\"onConnection(): connection [%s] is down\\n\", conn-\u003ename().c_str()); } } void onMessage(const TcpConnectionPtr \u0026conn, Buffer *buf, Timestamp receiveTime) { muduo::string msg(buf-\u003eretrieveAllAsString()); printf(\"onMessage(): received %zd bytes from connection [%s] at %s\\n\", msg.size(), conn-\u003ename().c_str(), receiveTime.toFormattedString().c_str()); conn-\u003esend(msg); } EventLoop *loop_; TcpServer server_; muduo::string message1_; muduo::string message2_; }; int main() { printf(\"main(): pid = %d\\n\", getpid()); InetAddress listenAddr(8888); EventLoop loop; TestServer server(\u0026loop, listenAddr); server.start(); loop.loop(); } #include \"EventLoop.h\" #include \"InetAddress.h\" #include \"TcpServer.h\" #include \u003cboost/bind.hpp\u003e #include \u003cst","date":"2022-12-06","objectID":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/:18:5","tags":["muduo"],"title":"muduo网络库源码学习","uri":"/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"categories":["c/c++"],"content":"1. 开始 iostream库包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。 std::cin：标准输入(standard input) std::cout：标准输出(standard output) std::cerr：标准错误(standard error)，通常用cerr来输出警告和错误消息 std::clog：clog用来输出程序运行时的一般性信息。 std::endl：这是一个被称为操纵符(manipulator)的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。 前缀std::指出名字cout和endl是定义在名为std的命名空间(namespace)中的。命名空间可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突。标准库定义的所有名字都在命名空间std中。 第Ⅰ部分 C++基础 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:1:0","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"2. 变量和基本类型 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:2:0","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"2.1 基本内置类型 C++是一种静态数据类型语言，它的类型检查发生在编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。 C++语言规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大。其中，数据类型long long是在C++11中新定义的。 与其他整型不同，字符型被分为了三种：char、signed char和unsigned char。特别需要注意的是：类型char和类型signed char并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。 提示：切勿混用带符号类型和无符号类型 进制： 20 //十进制 024 //八进制 0x14 //十六进制 字符串： 编译器在每个字符串的结尾处添加一个空字符(′\\0′)，因此，字符串字面值的实际长度要比它的内容多1。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:2:1","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"2.2 变量 初始值： 当对象在创建时获得了一个特定的值，我们说这个对象被初始化(initialized)了。初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。 列表初始化： int a = {0}; int b{0}; 当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错： long double ld = 3.1415926536; int a{ld}, b = {ld}; //错误：转换未执行，因为存在丢失信息的危险 int c = ld; //正确：转换执行，且确实丢失了部分值 使用long double的值初始化int变量时可能丢失数据，所以编译器拒绝了a和b的初始化请求。其中，至少ld的小数部分会丢失掉，而且int也可能存不下ld的整数部分。 默认初始化： 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。 定义于任何函数体之外的变量被初始化为0。 定义在函数体内部的内置类型变量将不被初始化(uninitialized)。 每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。 定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。C++11新标准规定，可以为数据成员提供一个类内初始值(in-class initializer)。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。 类初始值列表： class A { public: A() :a(1),b(2) {}; int a; int b; }; 类内初始化： class A { public: A(){}; int a = 1; int b{ 2 }; }; C++11的类内初始化允许非static成员的初始化，可以用{}或=号。 类类型的默认初始化： 每个类各自决定其默认初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么： 绝大多数类都支持无需显式初始化而定义对象，这样的类提供了一个合适的默认值，使用默认构造函数来初始化。例如，string 类规定如果没有指定初值则生成一个空串。 但有一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误。 如果是自定义的（或自动生成的）不执行任何操作的默认构造函数，那么适用与内置数据类型相同的规则来初始化成员变量；且如果成员变量是类类型，则会调用相应的默认构造函数对其进行初始化。 #include \u003ciostream\u003e // 合成的默认构造函数 class Worker { public: int height; }; // 有用户定义的默认构造函数 class Person { public: int height; Person() {}; // 默认构造函数，不执行任何操作 }; Worker g_worker; Person g_person; int main() { Worker localWorker; Person localPerson; std::cout \u003c\u003c g_worker.height \u003c\u003c std::endl; //0 std::cout \u003c\u003c g_person.height \u003c\u003c std::endl; //0 //std::cout \u003c\u003c localWorker.height \u003c\u003c std::endl; //error C4700: 使用了未初始化的局部变量“localWorker” std::cout \u003c\u003c localPerson.height \u003c\u003c std::endl; //随机值 return 0; } 构造函数的初始化列表与类内成员初始化 没有谁好谁不好，谁来替代谁，两种方法可相互补充使用。类内初始化有一些好处： 当你有多个构造函数时，如果使用初始化列表，每个构造函数都要写一遍，烦人不说，同时产生重复代码，修改易漏。如果把这些成员都用类内初始化，初始化列表就不用再列出它们了。 类内初始化，成员之间的顺序是隐式的，会有些便利。如果使用初始化列表，它是有顺序之分的，顺序不对，编译器会警告。 对于简单的类或结构，没有构造函数的，可以直接用类内初始化在成员声明的同时直接初始化，方便。 对于一些类类型的成员初始化要小心，如果成员之间有依赖关系，这时使用初始化列表显式的指明这些成员的构造（初始化）顺序是比较稳妥的。 如果成员已经使用了类内初始化，但在构造函数的初始化列表又列出来，编译器以后者优先，类内初始化会被忽略。如果某些成员使用不同构造函数时，会有不同的默认值，这种情况就要用初始化列表。同时，其它成员依然可以使用类内初始化。 类内初始化绝对不是解决什么内置类型默认初始化时未定义问题。面向对象编程一个很重要的原则，程序员有责任要保证对象产生出来，它的每个成员都必须是初始化的，这是设计问题以及基本意识，无论是使用哪种方法初始化。 一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。 变量定义和声明的关系： 为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译(separate compilation)机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。 如果将程序分为多个文件，则需要有在文件间共享代码的方法。 为了支持分离式编译，C++语言将声明和定义区分开来。声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义(definition)负责创建与名字关联的实体。 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量：extern int i; 任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用。 extern语句如果包含初始值就不再是声明，而变成定义了：extern int j = 3; 声明和定义的区别看起来也许微不足道，但实际上却非常重要。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:2:2","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"2.3 复合类型 引用： 引用即别名，引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。 因为引用本身不是一个对象，所以不能定义引用的引用。 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。 指针： 指针的值(即地址)应属下列4种状态之一： 指向一个对象。 指向紧邻对象所占空间的下一个位置。 空指针，意味着指针没有指向任何对象。 无效指针，也就是上述情况之外的其他值。 试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。 解引用操作仅适用于那些确实指向了某个对象的有效指针。 以下列出几个生成空指针的方法： 得到空指针最直接的办法就是用字面值nullptr来初始化指针，这也是C++11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。 通过将指针初始化为字面值0来生成空指针。 过去的程序还会用到一个名为NULL的预处理变量(preprocessor variable)来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。 预处理器是运行于编译过程之前的一段程序，预处理变量它由预处理器负责管理，因此我们可以直接使用预处理变量。当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此用NULL初始化指针和用0初始化指针是一样的。在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL。 void＊是一种特殊的指针类型，可用于存放任意对象的地址。一个void＊指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。概括说来，以void＊的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。 涉及指针或引用的声明，一般有两种写法。第一种把修饰符和变量标识符写在一起：这种形式着重强调变量具有的复合类型。第二种把修饰符和类型名写在一起，并且每条语句只定义一个变量：这种形式着重强调本次声明定义了一种复合类型。 着重强调变量具有的复合类型： int *pl, int *p2; 着重强调本次声明定义了一种复合类型： int* p1; int* p2; 推荐采用第一种方式：着重强调变量具有的复合类型。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:2:3","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"2.4 const限定符 const对象一旦创建后其值就不能再改变，所以const对象必须初始化。一如既往，初始值可以是任意复杂的表达式： const int i = get_size(); //正确：运行时初始化 const int j = 42; //正确：编译时初始化 默认状态下，const对象仅在文件内有效。解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了： // file_1.cc 定义并初始化了一个常量，该常量能被其他文件访问 extern const int bufSize = fcn(); // file_1.h extern const int bufSize; //与file_1.cc中定义的bufSize是一个 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。 const 的引用： 可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用(reference to const)。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。 只有const引用才能绑定一个临时量。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。 const指针： 指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针(const pointer)必须初始化，而且一旦初始化完成，则它的值(也就是存放在指针中的那个地址)就不能再改变了。把＊放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值。 顶层const和底层const： 如前所述，指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const(top-level const)表示指针本身是个常量，而用名词底层const(low-level const)表示指针所指的对象是一个常量。 更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显： int i = 0; int *const p1 = \u0026i; //不能改变p1的值，这是一个顶层const const int ci = 42; //不能改变ci的值，这是一个顶层const const int *p2 = \u0026ci; //不能改变p2的值，这是一个顶层const const int *const p3 = p2; //靠右的const是顶层const，靠左的是底层const const int \u0026r = ci; //用于声明引用的const都是底层const 当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响： i = ci; //正确：拷贝ci的值，ci是一个顶层const，对此操作无影响 p2 = p3; //正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响 执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。 另一方面，底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。 constexpr和常量表达式： 常量表达式(const expression)是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。 一个对象(或表达式)是不是常量表达式由它的数据类型和初始值共同决定，例如： const int max_files = 20; //max_files是常量表达式 const int limit = max_files + 1; //limit是常量表达式 int staff_size = 27; //staff_size不是常量表达式 const int sz = get_size(); //sz不是常量表达式 尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而非const int，所以它不属于常量表达式。 另一方面，尽管sz本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。 constexpr常量： C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。 一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。 字面值类型： 常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”(literal type)。 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。 指针和constexpr： 必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关： const int *p = nullptr; //p是一个指向整型常量的指针 constexpr int *q = nullptr; //q是一个指向整数的常量指针 其中的关键在于constexpr把它所定义的对象置为了顶层const ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:2:4","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"2.5 处理类型 类型别名： 类型别名(type alias)是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。 传统的方法是使用关键字typedef： typedef double wages; //wages是double的同义词 typedef wages base, *p; //base是double的同义词，p是double*的同义词 新标准规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名： using SI = Sales_item; //SI是Sales_item的同义词 指针、常量和类型别名： 如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是类型char＊的别名： typedef char *pstring; const pstring cstr = 0; //cstr是指向char的常量指针 const pstring *ps; //ps是一个指针，它的对象是指向char的常量指针 上述两条声明语句的基本数据类型都是const pstring，和过去一样，const是对给定类型的修饰。pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针，而非指向常量字符的指针。 遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义： const char *cstr = 0; //是对const pstring cstr的错误理解 再强调一遍：这种理解是错误的。声明语句中用到pstring时，其基本数据类型是指针。可是用char＊重写了声明语句后，数据类型就变成了char，＊成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。 auto类型说明符： 编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符(比如double)不同，auto让编译器通过初始值来推算变量的类型。 显然，auto定义的变量必须有初始值。 使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样。 首先，正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型： int i = 0, \u0026r = i; auto a = r; //a是一个整数(r是i的别名，而i是一个整数) 其次，auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时： const int ci = i, \u0026cr = ci; auto b = ci; //b是一个整数(ci的顶层const特性被忽略掉了) auto c = cr; //c是一个整数(cr是ci的别名，ci本身是一个顶层const) auto d = \u0026i; //d是一个整型指针(整型的地址就是指向整数的指针) auto c = \u0026ci; //e是一个指向整数常量的指针(对变量对象取地址是一种底层const) 如果希望推断出的auto类型是一个顶层const，需要明确指出： const auto f = ci; //ci的推演类型是int，f是const int 还可以将引用的类型设为auto，此时原来的初始化规则仍然适用： auto \u0026g = ci; //g是一个整型常量引用，绑定到ci auto \u0026h = 42; //错误：不能为非常量引用绑定字面值 const auto \u0026j = 42; //正确：可以为常量引用绑定字面值 设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。 decltype类型指示符： 有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。 int i = 42, *p = \u0026i, \u0026r = i; decltype(r + 0) b; //正确：加法的结果是int，因此b是一个(未初始化)的int decltype(r) x; //错误：x是int\u0026，必须初始化 decltype(*p) c; //错误：c是int\u0026，必须初始化 decltype((i)) d; //错误：d是int\u0026，必须初始化 decltype(i) e; //e是一个(未初始化)的int 切记：decltype(( variable))(注意是双层括号)的结果永远是引用，而decltype( variable)结果只有当 variable 本身就是一个引用时才是引用。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:2:5","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"2.6 自定义数据结构 为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。例如，库类型string在名为string的头文件中定义。 预处理器概述： 确保头文件多次包含仍能安全工作的常用技术是预处理器(preprocessor)，它由C++语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。之前已经用到了一项预处理功能#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。 C++程序还会用到的一项预处理功能是头文件保护符(header guard)，头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已 经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。 预处理变量无视C++语言中关于作用域的规则。 整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:2:6","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"3. 字符串、向量和数组 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:3:0","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"3.1 命名空间的using声明 有了using声明就无须专门的前缀(形如命名空间：：)也能使用所需的名字了。using声明具有的形式：using namespace::name; #include \u003ciostream\u003e using std::cout; int main() { cout \u003c\u003c \"hello\"; return 0; } 头文件不应包含using声明，位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:3:1","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"3.2 标准库类型string 作为标准库的一部分，string定义在命名空间std中。 直接初始化和拷贝初始化： C++语言有几种不同的初始化方式，通过string我们可以清楚地看到在这些初始化方式之间到底有什么区别和联系。如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化(copy initialization)，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化(direct initialization)。 string s5 = \"hiya\"; //拷贝初始化 string s6(\"hiya\"); //直接初始化 string s7(10, 'c'); //直接初始化，内容是cccccccccc 读取string对象： int main() { string s; //空字符串 cin \u003e\u003e s; //将string对象读入s，遇到空白停下 cout \u003c\u003c s \u003c\u003cendl; //输出s } 这段程序首先定义一个名为s的空string，然后将标准输入的内容读取到s中。在执行读取操作时，string对象会自动忽略开头的空白(即空格符、换行符、制表符等)并从第一个真正的字符开始读起，直到遇见下一处空白为止。 string与流： //在读取时检测流的状态 while(std::cin \u003e\u003e word) { ..... } getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止(注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去(注意不存换行符)。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。 //和输入运算符一样，getline也会返回它的流参数。 //每次读取一整行，直至到达文件末尾 while(getline(std::cin, line)) { .... } 触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象中并不包含该换行符。 string::size_type类型： string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字size_type是在类string中定义的。 string::size_type类型：它是一个无符号类型的值而且能足够存放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是string::size_type类型的。 表达式达式s.size() \u003c n的判断结果几乎肯定是true。这是因为负值n会自动地转换成一个比较大的无符号值。 如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。 std::strig对象的比较，都是依照(大小写敏感的)字典顺序： 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。 如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。 下面是string对象比较的一个示例： string str = \"Hello\"; string phrase = \"Hello World\"; string slang = \"Hiya\"; 根据规则1可判断，对象str小于对象phrase；根据规则2可判断，对象slang既大于str也大于phrase。 字符值和string对象相加： 当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符(+)的两侧的运算对象至少有一个是string。 处理string对象中的字符： cctype头文件中包含了处理字符的一些函数。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:3:2","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"3.3 标准库类型vector 模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化(instantiation)，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。 某些编译器可能仍需以老式的声明语句来处理元素为vector的vector对象，如vector\u003cvector \u003e。必须在外层vector对象的右尖括号和其元素类型之间添加一个空格。 几种初始化方式： 其一，使用拷贝初始化时(即使用=时)，只能提供一个初始值； 其二，如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。 第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。 vector\u003cstring\u003e v1{\"a\", \"an\", \"the\"}; //列表初始化 vector\u003cstring\u003e v2(\"a\", \"an\", \"the\"); //错误 值初始化： 通常情况下，可以只提供vector对象容纳的元素数量而不用略去初始值。此时库会创建一个值初始化的(value-initialized)元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。 如果vector对象的元素是内置类型，比如int，则元素初始值自动设为0。如果元素是某种类类型，比如string，则元素由类默认初始化： vector\u003cint\u003e ivec(10); //10个元素，每个都初始化为0 vector\u003cstring\u003e svec(10); //10个元素，每个都是空string对象 如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。 列表初始值还是元素数量？ vector\u003cint\u003e v1(10); //v1有10个元素，每个的值都是0 vector\u003cint\u003e v2{10}; //v2有1个元素，该元素的值都是10 vector\u003cint\u003e v3(10, 1); //v3有10个元素，每个的值都是1 vector\u003cint\u003e v4{10, 1}; //v4有2个元素，值分别是10和1 如果用的是圆括号，可以说提供的值是用来构造(construct)vector对象的。 如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。 如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。 C++标准要求vector应该能在运行时高效快速地添加元素。 vector对象的比较操作： 各个相等性运算符和关系运算符也与string的相应运算符功能一致。两个vector对象相等当且仅当它们所含的元素个数相同，而且对应位置的元素值也相同。关系运算符依照字典顺序进行比较：如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。 只有当元素的值可比较时，vector对象才能被比较。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:3:3","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"3.4 迭代器介绍 迭代器类型： 一般来说我们也不知道(其实是无须知道)迭代器的精确类型。而实际上，那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型： vector\u003cint\u003e::iterator it; //it能读写vector\u003cint\u003e的元素 string::iterator it2; //it2能读写string对象中的字符 vector\u003cint\u003e::const_iterator it3;//it3只能读元素，不能写元素 string::const_iterator it4; //it4只能读字符，不能写字符 容器自己的begin和end运算符： begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator。 C++11新标准引入了两个新函数，分别是cbegin和cend；不论vector对象(或string对象)本身是否是常量，返回值都是const_iterator。 结合解引用和成员访问操作： 解引用迭代器可获得迭代器所指的对象，C++语言定义了箭头运算符(-\u003e)。箭头运算符把解引用和成员访问两个操作结合在一起。 迭代器运算： 只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名 为difference_type的带符号整型数。string和vector都定义了difference_type，因为这个距离可正可负，所以difference_type是带符号类型的。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:3:4","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"3.5 数组 如果不清楚元素的确切个数，请使用vector。 数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式。 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。 显示初始化数组元素： 可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反，如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值。 不允许拷贝和赋值： 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。 理解复杂的数组声明： int *(\u0026arry)[10] = ptrs; //arry是数组的引用，该数组含有10个指针 按照由内向外的顺序阅读上述语句，首先知道arry是一个引用，然后观察右边知道，arry引用的对象是一个大小为10的数组，最后观察左边知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用。 要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。 访问数组元素： 在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。 标准库函数begin和end： C++11新标准引入了两个名为begin和end(cbegin和cend)的函数。begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针，这两个函数定义在iterator头文件中。使用begin和end可以很容易地写出一个循环并处理数组中的元素。 指针运算： 两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型。 下标和指针： 标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。内置的下标运算符可以处理负值，当然，结果地址必须指向原来的指针所指同一数组中的元素(或是同一数组尾元素的下一位置)。 const char *ptr1 = \"1234\"; const char* ptr2 = ptr1 + 2; printf(\"%c\", ptr2[-1]); //输出：2 C风格字符串： C风格字符串，是以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符(’\\0’)。一般利用指针来操作这些字符串。 string对象和C风格字符串： 如果程序的某处需要一个C风格字符串，string专门提供了一个名为c_str的成员函数： std::string s = \"hello\"; char *str = s.c_str(); c_str函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象的一样。结果指针的类型是const char＊，从而确保我们不会改变字符数组的内容。 我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效用。如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。 使用数组初始化vector对象： int int_arr[] = {0, 1, 2, 3, 4, 5}; // ivec有6个元素。分别是int_arr中对应元素的副本 vector\u003cint\u003e ivec(begin(int_arr), end(int_arr)); ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:3:5","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"3.6 多维数组 严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:3:6","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"4. 表达式 sizeof运算符： sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。 C++11新标准允许我们使用作用域运算符来获取类成员的大小。 显示转换： static_cast： 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。 当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。一般来说，如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息；但是当我们执行了显式的类型转换后，警告信息就会被关闭了。 const_cast： const_cast只能改变运算对象的底层const。 对于将常量对象转换成非常量对象的行为，我们一般称其为“去掉const性质(cast away the const)”。一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。 reinterpret_cast： einterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。 举个例子，假设有如下的转换： int *ip; char *pc = reinterpret_cast\u003cchar *\u003e(ip); 我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。例如： string str(pc); //错误 使用reinterpret_cast是非常危险的，用pc初始化str的例子很好地证明了这一点。其中的关键问题是类型改变了，但编译器没有给出任何警告或者错误的提示信息。当我们用一个int的地址初始化pc时，由于显式地声称这种转换合法，所以编译器不会发出任何警告或错误信息。接下来再使用pc时就会认定它的值是char＊类型，编译器没法知道它实际存放的是指向int的指针。最终的结果就是，在上面的例子中虽然用pc初始化str没什么实际意义，甚至还可能引发更糟糕的后果，但仅从语法上而言这种操作无可指摘。查找这类问题的原因非常困难，如果将ip强制转换成pc的语句和用pc初始化string对象的语句分属不同文件就更是如此。 reinterpret_cast本质上依赖于机器。要想安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。 强制类型转换： 根据所涉及的类型不同，旧式的强制类型转换分别具有与const_cast、static_cast或reinterpret_cast相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成const_cast和static_cast也合法，则其行为与对应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与reinterpret_cast类似的功能： //效果与使用reinterpret_cast一样。 char *pc = (char *)ip; //ip是指向整数的指针 建议：避免强制类型转换。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:4:0","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"5. 语句 空语句： 最简单的语句是空语句(null statement)，空语句中只含有一个单独的分号。如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。例如，我们想读取输入流的内容直到遇到一个特定的值为止，除此之外什么事情也不做： //重复读入数据直至到达文件末尾或某次输入的值等于sought while(cin \u003e\u003e s \u0026\u0026 s != sought) { ; } ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:5:0","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"6. 函数 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:6:0","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"6.1 函数基础 局部静态对象： 某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态对象(local static object)在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。 如果局部静态变量没有显式的初始值，它将执行值初始化。 函数声明： 和其他名字一样，函数的名字也必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。 函数的三要素(返回类型、函数名、形参类型)描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作函数原型(function prototype)。 分离式编译： 随着程序越来越复杂，我们希望把程序的各个部分分别存储在不同文件中。例如，可以把函数存在一个文件里，把使用这些函数的代码存在其他源文件中。为了允许编写程序时按照逻辑关系将其划分开来，C++语言支持所谓的分离式编译(separate compilation)。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:6:1","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"6.2 参数传递 指针形参： 当形参是引用类型时，我们说它对应的实参被引用传递(passed by reference)或者函数被传引用调用(called by reference)。和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应的实参的别名。 当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递(passed by value)或者函数被传值调用(called by value)。 熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参替代指针，使用引用避免拷贝。如果函数无须改变引用形参的值，最好将其声明为常量引用。 const形参和实参： 和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的： //fcn能读取i，但是不能向i写值 void fcn(const int i); 指针或引用形参与const： 形参的初始化方式和变量的初始化方式是一样的。我们可以使用非常量初始化一个底层const对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。 尽量使用常量引用： 把函数不会改变的形参定义成(普通的)引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。 数组形参： 数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：不允许拷贝数组以及使用数组时(通常)会将其转换成指针。因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式： // 尽管形参不同，但这三个print函数是等价的 // 每个函数都有一个const int*类型的参数 void print(const int *); void print(const int[]); //可以看出来，函数的意图是作用于一个数组 void print(const int[10]) //这里的维度表示我们期望数组含有多少元素，实际不一定 尽管表现形式不同，但上面的三个函数是等价的：每个函数的唯一形参都是const int＊类型的。当编译器处理对print函数的调用时，只检查传入的参数是否是const int＊类型。 使用标记指定数组长度： 使用标准库规范： void print(const int *beg, const int *end) { while(beg != end) { // do something } } 显式传递一个表示数组大小的形参 void print(const int ia[], size_t size) { for(size_t i = 0; i != size; i++) { // do something } } 数组引用形参： C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上： // 正确：形参是数组的引用，维度是类型的一部分 void print(int (\u0026arr)[10]) { for(auto elem : arr) { cout \u003c\u003c elem \u003c\u003c endl; } } \u0026arr两端的括号必不可少： f(int \u0026arr[10]) // 错误：将arr声明成了引用的数组 f(int (\u0026arr)[10]) // 正确：arr是具有10个整数的整型数组的引用 因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。但是，这一用法也无形中限制了print函数的可用性，我们只能将函数作用于大小为10的数组： int i= 0, j[2] = {0, 1}; int k[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; print(\u0026i); // 错误：实参不是含有10个整数的数组 print(j); // 错误：实参不是含有10个整数的数组 print(k); // 正确：实参是含有10个整数的数组 main函数处理命令行选项： int main(int argc, char *argv[]); //or int main(int argc, char **argv); 第一个形参argc表示数组中字符串的数量。第二个形参argv是一个数组，它的元素是指向C风格字符串的指针； 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。 含有可变形参的函数： 为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板(属于高级部分，暂不介绍)。 C++还有一种特殊的形参类型(即省略符)，可以用它传递可变数量的实参。本节将简要介绍省略符形参，不过需要注意的是，这种功能一般只用于与C函数交互的接口程序。 initializer_list形参： 如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中。 和vector一样，initializer_list也是一种模板类型。定义initializer_list对象时，必须说明列表中所含元素的类型：和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。 省略符形参： 省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。通常，省略符形参不应用于其他目的。你的C编译器文档会描述如何使用varargs。 省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。 可参考：C 库宏 #include \u003ccstdarg\u003e #include \u003ciostream\u003e static double sumOfFloat(int count, ...) { va_list ap; double sum = 0.0; va_start(ap, count); for (int i = 0; i \u003c count; ++i) { sum += va_arg(ap, double); } va_end(ap); return sum; } int main() { std::cout \u003c\u003c sumOfFloat(5, 1.1, 2.2, 3.3, 4.4, 5.5) \u003c\u003c std::endl; return 0; } 省略符形参只能出现在形参列表的最后一个位置。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:6:2","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"6.3 返回类型和return语句 值是如何被返回的： 返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。 不要返回局部对象的引用或指针： 函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。 引用返回左值： 函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。 列表初始化返回值： C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。 vector\u003cstring\u003e process(bool flag) { if(flag) { return {\"hello\", \"world\"}; //返回列表初始化的vector对象 } else { return {}; //返回一个空的vector对象 } } 主函数main的返回值： 我们允许main函数没有return语句直接结束。如果控制到达了main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句。 main函数的返回值可以看做是状态指示器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，我们可以使用这两个变量分别表示成功与失败： int main() { bool flag = false; if(flag) { return EXIT_FAILURE; } else { return EXIT_SUCCESS; } } 返回数组指针： 因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名： int arr[10]; //arr是一个含有10个整数的数组 int *p1[2]; //p1是一个含有10个指针的数组 int (*p2)[10] = \u0026arr; //p2是一个指针，它指向含有10个整数的数组 如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。 举个具体点的例子，下面这个func函数的声明没有使用类型别名： int (*func(int i))[10]; 可以按照以下的顺序来逐层理解该声明的含义： func(int i)表示调用func函数时需要一个int类型的实参。 (＊func(int i))意味着我们可以对函数调用的结果执行解引用操作。 (＊func(int i))[10]表示解引用func的调用将得到一个大小是10的数组。 int (＊func(int i))[10]表示数组中的元素是int类型。 使用尾置返回类型： 在C++11新标准中可以使用尾置返回类型（trailing return type）。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个-\u003e符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto： // func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组 auto func(int i) -\u003e int(*)[10]; 因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。 使用decltype： 还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个： int odd[] = {1, 3, 5, 7, 9}; int even[] = {0, 2, 4, 6, 8}; // 返回一个指针，该指针指向含有5个整数的数组 decltype(odd) *arrPtr(int i) { return (i % 2) ? \u0026odd : \u0026even; //返回一个指向数组的指针 } arrPtr使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与odd的类型一致。因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。有一个地方需要注意：decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个＊符号。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:6:3","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"6.4 函数重载 重载和const形参： 顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来： Record lookup(Phone); Record lookup(const Phone); //重复声明了Record lookup(Phone) Record lookup(Phone *); Record lookup(Phone* const); //重复声明了Record lookup(Phone *) 在这两组函数声明中，每一组的第二个声明和第一个声明是等价的。 另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的： // 对于接受引用或指针的函数来说，对象是变量还是非常量对应的形参不同 // 定义了4个独立的重载函数 Record lookup(Account\u0026); // 函数作用于Account的引用 Record lookup(const Account\u0026); // 新函数，作用于常量引用 Record lookup(Account*); // 新函数，作用于指向Account的指针 Record lookup(const Account*); // 新函数，作用于指向常量的指针 在上面的例子中，编译器可以通过实参是否是常量来推断应该调用哪个函数。因为const不能转换成其他类型，所以我们只能把const对象（或指向const的指针）传递给const形参。相反的，因为非常量可以转换成const，所以上面的4个函数都能作用于非常量对象或者指向非常量对象的指针。不过，当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。 何时不应该重载函数： 尽管函数重载能在一定程度上减轻我们为函数起名字、记名字的负担，但是最好只重载那些确实非常相似的操作。有些情况下，给函数起不同的名字能使得程序更易理解。举个例子，下面是几个负责移动屏幕光标的函数： Screen \u0026moveHome(); Screen \u0026moveAbs(int,int); Screen \u0026moveRel(int,int,string direction); 乍看上去，似乎可以把这组函数统一命名为move，从而实现函数的重载： Screen \u0026move(); Screen \u0026move(int,int); Screen \u0026move(int,int,string direction); 其实不然，重载之后这些函数失去了名字中本来拥有的信息。尽管这些函数确实都是在移动光标，但是具体移动的方式却各不相同。以moveHome为例，它表示的是移动光标的一种特殊实例。一般来说，是否重载函数要看哪个更容易理解： //那种形式更容易理解呢？ myScreen.movehome(); // 我们认为应该是这一个 myScreen.move(); const_cast和重载： const_cast在重载函数的情景中最有用： // 比较两个string对象的长度，返回较短的那个引用 const strig \u0026shorterString(const string \u0026s1, const string \u0026s2) { return s1.size() \u003c= s2.size() ? s1 : s2; } 这个函数的参数和返回类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string的引用。 当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点： strig \u0026shorterString(string \u0026s1, string \u0026s2) { auto \u0026r = shorterString(const_cast\u003cconst string\u0026\u003e(s1), const_cast\u003cconst string\u0026\u003e(s2)); return const_cast\u003cstring\u0026\u003e(r); } 在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的string\u0026，这显然是安全的。 调用重载的函数： 定义了一组重载函数后，我们需要以合理的实参调用它们。函数匹配（function matching）是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做重载确定（overload resolution）。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。 现在我们需要掌握的是，当调用重载函数时有三种可能的结果： 编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配（no match）的错误信息。 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用（ambiguous call）。 重载与作用域： 如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。 当我们调用函数时，编译器首先寻找对该函数名的声明。一旦在当前作用域中找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。剩下的工作就是检查函数调用是否有效了。 在C++语言中，名字查找发生在类型检查之前。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:6:4","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"6.5 特殊用途语言特性 默认实参： 某些函数有这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的默认实参（default argument）。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。 默认实参声明： 对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。假如给定： // 表示高度和宽度的形参没有默认值 string screen(sz, sz, char = ' '); 我们不能修改一个已经存在的默认值： string screen(sz, sz, char = '*'); //错误重复声明 但是可以按照如下形式添加默认实参： string screen(sz = 24, sz = 80, char); //正确：添加默认实参 通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。 内联函数和constexpr函数： 内联函数可避免函数调用的开销。将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。 内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。 constexpr函数： constexpr函数（constexpr function）是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。 执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。 我们允许constexpr函数的返回值并非一个常量 ？？？？？？？？？？？？？？？？ 把内联函数和constexpr函数放在头文件内： 和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。 assert预处理宏： assert是一种预处理宏（preprocessor marco）。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏定义在cassert头文件中。assert宏常用于检查“不能发生”的条件。 NDEBUG预处理变量： assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。 定义NDEBUG能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。因此，assert应该仅用于验证那些确实不可能发生的事情。我们可以把assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查。 除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码；如果定义了NDEBUG，这些代码将被忽略掉： void print(const int ia[], size_t size) { #ifndef NDEBUG //__func__是编译器定义的一个局部静态变量，用于存放函数的名字 cerr \u003c\u003c __func__ \u003c\u003c \": array size is \" \u003c\u003c size \u003c\u003c endl; #endif //..... } 在这段代码中，我们使用变量__func__输出当前调试的函数的名字。编译器为每个函数都定义了__func__，它是const char的一个静态数组，用于存放函数的名字。 除了C++编译器定义的__func__之外，预处理器还定义了另外4个对于程序调试很有用的名字： FILE 存放文件名的字符串字面值。 LINE 存放当前行号的整型字面值。 TIME 存放文件编译时间的字符串字面值。 DATE 存放文件编译日期的字符串字面值。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:6:5","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"6.6 函数匹配 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:6:6","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"6.7 函数指针 函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如： bool lengthCompare(const string \u0026, const string \u0026); //pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型 bool (*pf)(const string \u0026, const string \u0026); //未初始化 从我们声明的名字开始观察，pf前面有个＊，因此pf是指针；右侧是形参列表，表示pf指向的是函数；再观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。 pf两端的括号必不可少。如果不写这对括号，则pf是一个返回值为bool指针的函数： // 声明一个名为pf的函数，该函数返回bool* bool *pf(const string \u0026, const string \u0026); 使用函数指针： 当我们把函数名作为一个值使用时，该函数自动地转换成指针。此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针。 返回指向函数的指针： 和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名： using F = int(int *, int); // F是函数类型，不是指针 using PF = int(*)(int*, int); // PF是指针类型 其中我们使用类型别名将F定义成函数类型，将PF定义成指向函数类型的指针。必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针： PF fl(int); // 正确:PE 是指向函数的指针，f1 返回指向函数的指针 F fl(int); // 错误:F是函数类型，f1 不能返回一个函数 F *fl(int); // 正确:显式地指定返回类型是指向函数的指针 当然，我们也能用下面的形式直接声明f1： int (*f1(int))(int*, int); 按照由内向外的顺序阅读这条声明语句：我们看到f1有形参列表，所以f1是个函数；f1前面有*，所以f1返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int。 出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数： auto f1(int) -\u003e int (*)(int*, int); 将auto和decltype用于函数指针类型： 如果我们明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。例如假定有两个函数，它们的返回类型都是string：：size_type，并且各有两个const string\u0026类型的形参，此时我们可以编写第三个函数，它接受一个string类型的参数，返回一个指针，该指针指向前两个函数中的一个： string::size type sumLength(const string\u0026, const string\u0026); string::size type largerLength(const stringk, const string\u0026); //根据其形参的取值，getFcn 函数返回指向sumLength 或者largerLength 的指针 decltype(sumLength) *getFcn(const string \u0026); 声明getFcn唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型。因此，我们显式地加上*以表明我们需要返回指针，而非函数本身。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:6:7","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"7. 类 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:7:0","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"7.1 定义抽象数据类型 定义在类内部的函数是隐式的inline函数。 引入const成员函数： 默认情况下，this的类型是指向类类型非常量版本的常量指针(顶层const)。C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。 在类的外部定义成员函数： 像其他函数一样，当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，返回类型、参数列表和函数名都得与类内部的声明保持一致。如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的成员的名字必须包含它所属的类名： double Sales_data::avg_price() const { //........... } 定义类相关的非成员函数： 我们定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开来。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。 构造函数： 每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数（constructor）。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。 构造函数的名字和类名相同。和其他函数不一样的是，构造函数没有返回类型；除此之外类似于其他的函数，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。 不同于其他成员函数，构造函数不能被声明成const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。 合成的默认构造函数： 编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员： 如果存在类内的初始值，用它来初始化成员。 否则，默认初始化该成员。 对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三： 第一个原因也是最容易理解的一个原因就是编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。这条规则的依据是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。 第二个原因是对于某些类来说，合成的默认构造函数可能执行错误的操作。回忆我们之前介绍过的，如果定义在块中的内置类型或复合类型（比如数组和指针）的对象被默认初始化，则它们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。因此，含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则，用户在创建类的对象时就可能得到未定义的值。 如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。 第三个原因是有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类来说，我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。还有其他一些情况也会导致编译器无法生成一个正确的默认构造函数。 = default的含义： 在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上= default来要求编译器生成构造函数。其中，= default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果= default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。 构造函数初始值列表： Sales_data(const std::string \u0026s) : bookNo(s){ }; 这两个定义中出现了新的部分，即冒号以及冒号和花括号之间的代码，其中花括号定义了（空的）函数体。我们把新出现的部分称为构造函数初始值列表（constructor initialize list），它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:7:1","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"7.2 访问控制与封装 在C++语言中，我们使用访问说明符（access specifiers）加强类的封装性： 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。 使用class或struct关键字： 唯一的一点区别是，struct和class的默认访问权限不太一样。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。 友元： 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可： class Sales_data { // 为 Sales_data的非成员函数所做的友元声明 friend Sales_data add(const Sales_data\u0026, const Sales_data\u0026); friend std::ostream \u0026print(std::ostream\u0026, const Sales_data\u0026); friend std::istream \u0026read(std::istream\u0026, Sales_data\u0026); // ................... // ................... } //函数的声明 // 为 Sales_data接口的非成员组成部分的声明 Sales_data add(const Sales_data\u0026, const Sales_data\u0026); std::ostream \u0026print(std::ostream\u0026, const Sales_data\u0026); std::istream \u0026read(std::istream\u0026, Sales_data\u0026); 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。 一般来说，最好在类定义开始或结束前的位置集中声明友元。 友元的声明： 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。 为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。因此，我们的Sales_data头文件应该为read、print和add提供独立的声明（除了类内部的友元声明之外）。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:7:2","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"7.3 类的其他特性 定义一个类型成员： 除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种： class Screen { public: typedef std::string::size_type pos; private: pos cursor = 0; pos height = 0, width = 0; std::string contents; }; 我们在Screen的public部分定义了pos，这样用户就可以使用这个名字。Screen的用户不应该知道Screen使用了一个string对象来存放它的数据，因此通过把pos定义成public成员可以隐藏Screen实现的细节。 关于pos的声明有两点需要注意。首先，我们使用了typedef，也可以等价地使用类型别名： class Screen { public: // 使用类型别名等价地声明一个新类名字 using pos = std::string::size_type; private: pos cursor = 0; pos height = 0, width = 0; std::string contents; } 其次，用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别。因此，类型成员通常出现在类开始的地方。 令成员作为内联函数： 在类中，常有一些规模较小的函数适合于被声明成内联函数。我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：虽然我们无须在声明和定义的地方同时说明inline，但这么做其实是合法的。不过，最好只在类外部定义的地方说明inline，这样可以使类更容易理解。 和我们在头文件中定义inline函数的原因一样，inline成员函数也应该与相应的类定义在同一个头文件中。 可变数据成员： 一个可变数据成员（mutable data member）永远不会是const，即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值。 类数据成员的初始值： 在定义好Screen类之后，我们将继续定义一个窗口管理类并用它表示显示器上的一组Screen。这个类将包含一个Screen类型的vector，每个元素表示一个特定的Screen。默认情况下，我们希望Window_mgr类开始时总是拥有一个默认初始化的Screen。在C++11新标准中，最好的方式就是把这个默认值声明成一个类内初始值： class Window_mgr { private: // 这个Window_mgr追踪的Screen // 默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen std::vector\u003cScreen\u003e screens{Screen(24, 80, ' ')}; } 如我们之前所知的，类内初始值必须使用=的初始化形式（初始化Screen的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的）。 当我们提供一个类内初始值时，必须以符号=或者花括号表示。 从const成员函数返回＊this： 一个const成员函数如果以引用的形式返回＊this，那么它的返回类型将是常量引用。 基于const的重载： 通过区分成员函数是否是const的，我们可以对其进行重载。具体说来，因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的匹配。 类类型： 每个类定义了唯一的类型。对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。例如： 类的声明： 就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它： class Screen; // Screen类的声明 这种声明有时被称作前向声明（forward declaration），它向程序中引入了名字Screen并且指明Screen是一种类类型。对于类型Screen来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知Screen是一个类类型，但是不清楚它到底包含哪些成员。 不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。 对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。否则，编译器就无法了解这样的对象需要多少存储空间。类似的，类也必须首先被定义，然后才能用引用或者指针访问其成员。毕竟，如果类尚未定义，编译器也就不清楚该类到底有哪些成员。 直到类被定义之后数据成员才能被声明成这种类类型。换句话说，我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针： class Link_screen { screen window; Link_screen *next; Link_screen *prev; } 友元再探： 类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。 类之间的友元关系： 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。必须要注意的一点是，友元关系不存在传递性。 每个类负责控制自己的友元类或友元函数。 令成员函数作为友元 当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类： class Screen { // Window_mgr::clear必须在Screen类之前被声明 friend void Windown_mgr::clear(ScreenIndex); // Screen类的剩余部分 } 要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序： 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。 接下来定义Screen，包括对于clear的友元声明。 最后定义clear，此时它才可以使用Screen的成员。 #include \u003ciostream\u003e // 前置声明 class Screen; class Windown_mgr { public: void clear(Screen\u0026); }; class Screen { // Window_mgr::clear必须在Screen类之前被声明 friend void Windown_mgr::clear(Screen\u0026); public: Screen(int val) : val_(val) { }; int getVal() const { return val_; } private: int val_; }; void Windown_mgr::clear(Screen\u0026 screen) { screen.val_ = 0; } int main() { Screen screen(12); std::cout \u003c\u003c screen.getVal() \u003c\u003c std::endl; Windown_mgr mgr; mgr.clear(screen); std::cout \u003c\u003c screen.getVal() \u003c\u003c std::endl; return 0; } 函数重载和友元： 尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。 友元声明和作用域： 类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。 甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的： struct X { // 友元函数可以定义在类的内部 friend void f() {} X() { f(); } //错误：f还没被声明 void g(); void h(); }; void X::g() { return f(); } //错误：f还没被声明 void f(); //声明那个定义在X中的函数 void X::h() { return f(); } //正确：现在f的声明在作用域中了 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:7:3","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"7.4 类的作用域 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:7:4","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"7.5 构造函数再探 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。 建议使用构造函数初始值： 在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。除了效率问题外更重要的是，一些数据成员必须被初始化。建议读者养成使用构造函数初始值的习惯，这样能避免某些意想不到的编译错误，特别是遇到有的类含有需要构造函数初始值的成员时。 成员初始化的顺序： 构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。 一般来说，初始化的顺序没什么特别要求。不过如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了。考虑下面这个类： class X { int i; int j; public: //未定义的：i在j之前被初始化 X(int val) : j(val), i(j) { }; }; 在此例中，从构造函数初始值的形式上来看仿佛是先用val初始化了j，然后再用j初始化i。实际上，i先被初始化，因此这个初始值的效果是试图使用未定义的值j初始化i 最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。 默认实参和构造函数: 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。 委托构造函数： C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。 和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。 举个例子，我们使用委托构造函数重写Sales_data类，重写后的形式如下所示： class Sales_data { public: // 非委托构造函数使用对应的实参初始化成员 Sales_data(std::string s, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt * price) { }; // 其余构造函数全都委托给另一个构造函数 Sales_data() : Sale_data(\"\", 0, 0) { }; Sales_data(std::string s) : Sales_data(s, 0, 0) { }; Sales_data(std::istream \u0026is) : Sales_data() { read(is, *this) }; } 值初始化和默认初始化： 值初始化 顾名思义，就是用数值初始化变量。如果没有给定一个初始值，就会根据变量或类对象的类型提供一个初始值。对于int类型其值初始化后的值为0。 默认初始化：如果定义变量时没有指定初值，则变量被默认初始化。其初始值和变量的类型以及变量定义的位置相关。默认初始化类对象和默认初始化内置类型变量有所不同。 对于默认初始化内置类型变量来说： 定义在函数体之外的变量是全局变量，一般存储在全局区，存储在全局区的变量一般会执行值初始化。此时，其初始值和变量的类型有关。对于int类型其初始值为0，对于char类型其默认初始值为’ ‘。 定义在函数体内部的是局部变量，其存储在栈区中，如果没有指定初值，那么该局部变量将不会被初始化，也就是说这个局部变量的值是未定义的，是个随机值。此时，如果不给这个局部变量赋值，那么就不能使用该局部变量，否则就会出错，注意这种情况是没有被初始化，既没有使用默认初始化也没有使用值初始化，没有初始化的值是不能使用的。 默认构造函数的作用： 当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生： 当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时。 当一个类本身含有类类型的成员且使用合成的默认构造函数时。 当类类型的成员没有在构造函数初始值列表中显式地初始化时。 值初始化在以下情况下发生： 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。 当我们不使用初始值定义一个局部静态变量时。 当我们通过书写形如T（ ）的表达式显式地请求值初始化时，其中T是类型名（vector的一个构造函数只接受一个实参用于说明vector大小，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。 隐式的类类型转换： 编译器只会自动地执行一步类型转换。 class X { public: X(std::string str) : str_(str) { }; private: std::string str_; }; int main() { X x1(\"hello\"); return 0; } 抑制构造函数定义的隐式转换： 在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止： #include \u003ciostream\u003e #include \u003cstring\u003e class X { public: explicit X(const std::string \u0026str) : str_(str) { }; private: std::string str_; }; 关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复。 explicit构造函数只能用于直接初始化。发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=）。此时，我们只能使用直接初始化而不能使用explicit构造函数： X x1(\"hello\"); //正确，直接初始化 X x2 = \"hello\"; //错误，不能将explicit构造函数用于拷贝形式的初始化过程 当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。 聚合类： 聚合类（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的： 所有成员都是public的。 没有定义任何构造函数。 没有类内初始值。 没有基类，也没有virtual函数。 例如，下面的类是一个聚合类： struct Data { int ival; string s; }; 我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员： Data val1 = {0, \"Anna\"}; 初始值的顺序必须与声明的顺序一致，也就是说，第一个成员的初始值要放在第一个，然后是第二个，以此类推。 如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。 可以把聚合类理解成C语言的结构体 字面值常量类： 数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类： 数据成员都必须是字面值类型。 类必须至少含有一个constexpr构造函数。 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。 类必须使用析构函数的默认定义，该成员负责销毁类的对象。 constexpr构造函数： 尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:7:5","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"7.6 类的静态成员 当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句。 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。 因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。 要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。 静态成员的类内初始化： 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。 struct X { static int str_; }; int X::str_ = 2; 第Ⅱ部分 C++标准库 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:7:6","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"8. IO库 ","date":"2022-11-27","objectID":"/posts/c++_primer_5th/:8:0","tags":["c++ primer"],"title":"c++ primer 5th 要点记录","uri":"/posts/c++_primer_5th/"},{"categories":["c/c++"],"content":"前言 服务器设计的目的 高性能 高可用 故障转移(failover) 伸缩性 library和framework： 库中类相对比较独立，我们编写应用的时候需要编写一些\"胶水代码\"来粘合。 框架是能够应用于特定应用领域的，不需要编写过多的\"胶水代码\"来粘合。 框架提供用户注册一些回调函数，使得框架能够调用我们所编写的回调函数，这就使得控制反转了。 第一部分：Muduo基础库 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:1:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"1. 编程风格 C编程风格：注册三个全局函数到网络库，网络库通过函数指针来回调。 面向对象风格：用一个EchoServer继承TcpServer(抽象类)，实现三个接口OnConnection、OnMessage和OnClose。 基于对象风格：用一个EchoServer包含一个TcpServer(具体类)对象，在构造函数中用boost::bind来注册三个成员函数OnConnection、OnMessage和OnClose。 简单的Thread类的编程风格，Thread类的结构树如下： ├── CMakeLists.txt ├── include │ ├── MyThread.h │ └── Thread.h │── src │ ├── MyThread.cpp │ └── Thread.cpp ├── main ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:2:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"1.1 面向对象的Thread类 面向对象的Thread类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/Thread_oo ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:2:1","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"1.2 基于对象的Thread类 基于对象的Thread类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/Thread_ob ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:2:2","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"2. Timestamp类 Timestamp类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/Timestamp 值语义：可以拷贝的，拷贝之后，与原对象脱离关系。 对象语义：要么是不能拷贝的，要么可以拷贝，拷贝之后与原对象仍然存在一定的关系，比如共享底层资源(要实现自己的拷贝构造函数)。 宏BOOST_STATIC_ASSERT：编译时断言。 assert：是在运行时断言的。 muduo::copyable：空基类，标识类，值类型。 boost::equality_comparable： less_than_comparable：要求实现\u003c，可自动实现\u003e,\u003c=,\u003e= 使用PRId64，int64_t用来表示64位整数，在32位系统中是long long int，在64位系统中是long int,所以打印int64_t的格式化方法是： printf(“%ld”, value); // 64bit OS printf(\"%lld\", value); // 32bit OS 跨平台的做法： #define __STDC_FORMAT_MACROS #include \u003cinttypes.h\u003e #undef __STDC_FORMAT_MACROS printf(\"%\" PRId64 \"\\n\", value); ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:3:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"3. 原子操作 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:4:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"3.1 提供加减和逻辑运算的原子操作 gcc从4.1.2提供了__sync_*系列的built-in函数，用于提供加减和逻辑运算的原子操作。gcc原子性操作其声明如下： /*返回更新前的值*/ type __sync_fetch_and_add (type *ptr, type value, ...); // 将value加到*ptr上，结果更新到*ptr，并返回操作之前*ptr的值 type __sync_fetch_and_sub (type *ptr, type value, ...); // 从*ptr减去value，结果更新到*ptr，并返回操作之前*ptr的值 type __sync_fetch_and_or (type *ptr, type value, ...); // 将*ptr与value相或，结果更新到*ptr， 并返回操作之前*ptr的值 type __sync_fetch_and_and (type *ptr, type value, ...); // 将*ptr与value相与，结果更新到*ptr，并返回操作之前*ptr的值 type __sync_fetch_and_xor (type *ptr, type value, ...); // 将*ptr与value异或，结果更新到*ptr，并返回操作之前*ptr的值 type __sync_fetch_and_nand (type *ptr, type value, ...); // 将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之前*ptr的值 /*返回更新后的值*/ type __sync_add_and_fetch (type *ptr, type value, ...); // 将value加到*ptr上，结果更新到*ptr，并返回操作之后新*ptr的值 type __sync_sub_and_fetch (type *ptr, type value, ...); // 从*ptr减去value，结果更新到*ptr，并返回操作之后新*ptr的值 type __sync_or_and_fetch (type *ptr, type value, ...); // 将*ptr与value相或， 结果更新到*ptr，并返回操作之后新*ptr的值 type __sync_and_and_fetch (type *ptr, type value, ...); // 将*ptr与value相与，结果更新到*ptr，并返回操作之后新*ptr的值 type __sync_xor_and_fetch (type *ptr, type value, ...); // 将*ptr与value异或，结果更新到*ptr，并返回操作之后新*ptr的值 type __sync_nand_and_fetch (type *ptr, type value, ...); // 将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之后新*ptr的值 type可以是1,2,4或8字节长度的int类型，即： int8_t / uint8_t int16_t / uint16_t int32_t / uint32_t int64_t / uint64_t 后面的可扩展参数(…)用来指出哪些变量需要memory barrier(全屏障),因为目前gcc实现的是full barrier(类似于linux kernel 中的mb(),表示这个操作之前的所有内存操作不会被重排序到这个操作之后),所以可以略掉这个参数。 __sync_synchronize (...)：发出一个full barrier(完整内存栅栏)。 关于memory barrier,cpu会对我们的指令进行排序，一般说来会提高程序的效率，但有时候可能造成我们不希望得到的结果，举一个例子，比如我们有一个硬件设备，它有4个寄存器，当你发出一个操作指令的时候，一个寄存器存的是你的操作指令(比如READ)，两个寄存器存的是参数(比如是地址和size)，最后一个寄存器是控制寄存器，在所有的参数都设置好之后向其发出指令，设备开始读取参数，执行命令，程序可能如下： write1(dev.register_size,size); write1(dev.register_addr,addr); write1(dev.register_cmd,READ); write1(dev.register_control,GO); 如果最后一条write1被换到了前几条语句之前，那么肯定不是我们所期望的，这时候我们可以在最后一条语句之前加入一个memory barrier,强制cpu执行完前面的写入以后再执行最后一条： write1(dev.register_size,size); write1(dev.register_addr,addr); write1(dev.register_cmd,READ); __sync_synchronize(); write1(dev.register_control,GO); memory barrier有几种类型： acquire barrier : 不允许将barrier之后的内存读取指令移到barrier之前(linux kernel中的wmb())。 release barrier : 不允许将barrier之前的内存读取指令移到barrier之后 (linux kernel中的rmb())。 full barrier : 以上两种barrier的合集(linux kernel中的mb())。 示例如下： #include \u003cstdio.h\u003e #include \u003cpthread.h\u003e #include \u003cstdlib.h\u003e static int count = 0; void *test_func(void *arg) { int i=0; for(i=0;i\u003c20000;++i){ __sync_fetch_and_add(\u0026count,1); } return NULL; } int main(int argc, const char *argv[]) { pthread_t id[20]; int i = 0; //开启20个线程 for(i=0;i\u003c20;++i){ pthread_create(\u0026id[i],NULL,test_func,NULL); } //等待 for(i=0;i\u003c20;++i){ pthread_join(id[i],NULL); } printf(\"%d\\n\",count); return 0; } ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:4:1","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"3.2 原子比较和交换(设置)操作 CAS是compare and swap, 简单来说就是，在写入新值之前，读出旧值，当且仅当旧值与存储中的当前值(*ptr)一致时，才把新值写入存储。 bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...); // 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回true type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...); // 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回操作之前*ptr的值 这两个函数提供原子的比较和交换，如果*ptr == oldval,就将newval写入*ptr： 第一个函数在相等并写入的情况下返回true. 第二个函数在返回操作之前的值。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:4:2","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"3.3 原子赋值操作 type __sync_lock_test_and_set (type *ptr, type value, ...); // 将value写入*ptr，对*ptr加锁，并返回操作之前*ptr的值。即，try spinlock语义 void __sync_lock_release (type *ptr, ...); // 将0写入到*ptr，并对*ptr解锁。即，unlock spinlock语义 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:4:3","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"3.4 无锁队列的实现 参考：https://coolshell.cn/articles/8239.html ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:4:4","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"4. 原子类 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:5:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"4.1 AtomicIntegerT类 AtomicIntegerT类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/Atomic ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:5:1","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"4.2 volatile关键字 volatile的作用：作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。简单地说就是防止编译器对代码进行优化。 当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，而不是使用保存在寄存器中的备份。即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:5:2","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"5. 编译选项 -Wall // 大部分警告 -Wextra // 一些额外的警告 -Werror // 当出现警告时转为错误，停止编译 -Wconversion // 一些可能改变值的隐式转换，给出警告。 -Wno-unused-parameter // 函数中出现未使用的参数，不给出警告。 -Wold-style-cast // C风格的转换，给出警告 -Woverloaded-virtual // 如果函数的声明隐藏住了基类的虚函数，就给出警告。 -Wpointer-arith // 对函数指针或者void *类型的指针进行算术操作时给出警告 -Wshadow // 当一个局部变量遮盖住了另一个局部变量，或者全局变量时，给出警告。 -Wwrite-strings // 规定字符串常量的类型是const char[length]，因此，把这样的地址复制给 non-const char *指针将产生警告.这些警告能够帮助你在编译期间发现企图写入字符串常量 的代码 -march=native // 指定cpu体系结构为本地平台 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:6:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"6. 向上转型 #include \u003cstdio.h\u003e void foo(int x) {} class B { public: virtual void foo() {} }; class D : public B { public: void foo(int x) {} }; template \u003ctypename To, typename From\u003e inline To implicit_cast(From const \u0026f) { return f; } int main(void) { int n; double d = 1.23; n = d; B *pb; D *pd = NULL; pb = pd; pb = implicit_cast\u003cB *, D *\u003e(pd); return 0; } ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:7:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"7. Exception类 Exception类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/Exception backtrace函数：栈回溯，保存各个栈帧的地址。 backtrace_symbols函数：根据地址，转成相应的函数符号。 abi::__cxa_demangle函数：将编译器翻译的函数名称转换为自己编写的实际函数名，方便查看。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:8:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"8. 线程类 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:9:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"8.1 线程标识(线程ID) 一、线程标识 和进程的pid一样，每个线程也有对应的id即tid。 在线程中，线程ID的类型是pthread_t类型，由于在Linux下线程采用POSIX标准，所以，在不同的系统下，pthread_t的类型是不同的，比如在ubuntn下，是unsigned long类型，而在solaris系统中，是unsigned int类型。而在FreeBSD上才用的是结构体指针。 所以不能直接使用==判读，而应该使用pthread_equal来判断。 二、获取线程ID的方法 gettid或者类似gettid的方法(使用系统调用) 直接调用pthread_self()函数 获取线程ID的方法说明： 1、使用gettid方法 gettid并没有直接在glibc中实现，因此无法在程序中直接使用这个函数，与之类似的方法是执行系统调用。 a.首先查询该系统调用的调用号(在文件arch/arm64/Include/Asm/Unistd32.h中) b.使用系统调用来获取内核线程ID #include \u003csys/syscall.h\u003e printf(\"The ID of this thread is: %ld\\n\", (long int)syscall(224)); 2、直接调用pthread_self()函数获取id #include \u003cstdio.h\u003e #include \u003cpthread.h\u003e printf(\"pthread_self: %ld\\n\", pthread_self()); 三、知识点补充 线程的标识有两个【内核中的线程ID】【posix描述的线程ID(也就是用户层glibc库中的线程ID)】 gettid 获取的是内核中真实线程ID, 对于多线程进程来说，每个tid实际是不一样的。而pthread_self获取的是相对于进程的线程控制块的首地址， 只是用来描述同一进程中的不同线程。 gettid及使用系统调用方法获取到的id是内核中的线程id，pthread_self()获取到的是posix描述的ID 对于单线程的进程，内核中的tid==pid。对于多线程的进程，他们拥有相同的pid和不同的tid。 pthread_self()返回的id和内核中线程的id是不一样的，当一个线程退出后，新创建的线程可以复用原来的id 四、分为两个线程id的原因 因为线程库实际上由两部分组成：内核的线程支持+用户态的库支持(glibc)，linux上的线程实现就是在内核支持的基础上以POSIX thread的方式对外封装了接口，所以才会有两个ID的问题。 五、总结 Linux中，每个进程有一个pid，类型pid_t，由getpid()取得。Linux下的POSIX线程也有一个id，类型 pthread_t，由pthread_self()取得，该id由线程库维护，其id空间是各个进程独立的(即不同进程中的线程可能有相同的id)。Linux中的POSIX线程库实现的线程其实也是一个进程(LWP)，只是该进程与主进程(启动线程的进程)共享一些资源而已，比如代码段，数据段等。 有时候我们可能需要知道线程的真实pid。比如进程P1要向另外一个进程P2中的某个线程发送信号时，既不能使用P2的pid，更不能使用线程的pthread id，而只能使用该线程的真实pid，称为tid。 有一个函数gettid()可以得到tid，但glibc并没有实现该函数，只能通过Linux的系统调用syscall来获取。 return syscall(SYS_gettid) ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:9:1","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"8.2 __thread关键字 __thread是GCC内置的线程局部存储设施，存取效率可以和全局变量相比。__thread变量每一个线程有一份独立实体，各个线程的值互不干扰。可以用来修饰那些带有全局性且值可能变，但是又不值得用全局变量保护的变量。 __thread使用规则：只能修饰POD类型(类似整型指针的标量，不带自定义的构造、拷贝、赋值、析构的类型，二进制内容可以任意复制memset,memcpy,且内容可以复原)，不能修饰class类型，因为无法自动调用构造函数和析构函数，可以用于修饰全局变量，函数内的静态变量，不能修饰函数的局部变量或者class的普通成员变量，且__thread变量值只能初始化为编译器常量(值在编译器就可以确定const int i=5,运行期常量是运行初始化后不再改变const int i=rand()). #include \u003ciostream\u003e #include \u003cpthread.h\u003e #include \u003cunistd.h\u003e using namespace std; const int i = 5; __thread int var = i; //两种方式效果一样 //__thread int var=5;// void *worker1(void *arg); void *worker2(void *arg); int main() { pthread_t pid1, pid2; //__thread int temp=5; static __thread int temp = 10; //修饰函数内的static变量 pthread_create(\u0026pid1, NULL, worker1, NULL); pthread_create(\u0026pid2, NULL, worker2, NULL); pthread_join(pid1, NULL); pthread_join(pid2, NULL); cout \u003c\u003c temp \u003c\u003c endl; //输出10 return 0; } void *worker1(void *arg) { cout \u003c\u003c ++var \u003c\u003c endl; //输出 6 } void *worker2(void *arg) { sleep(1); //等待线程1改变var值，验证是否影响线程2 cout \u003c\u003c ++var \u003c\u003c endl; //输出6 } ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:9:2","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"8.3 std::is_same和std::decay 可参考：https://blog.csdn.net/czyt1988/article/details/52812797 C++11的模板类型判断：std::is_same和std::decay ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:9:3","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"8.4 pthread_atfork()函数 可参考：https://blog.csdn.net/chdhust/article/details/38436153 #include \u003cpthread.h\u003e int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void)); 调用fork时，内部创建子进程前在父进程中会调用prepare，内部创建子进程成功后，父进程会调用parent ，子进程会调用child。也就是说：最先调用prepare函数，只存在下面两种进程调度组合： prepare() -\u003e parent() -\u003e child() prepare() -\u003e child() -\u003e parent() 例子： #include \u003cstdio.h\u003e #include \u003ctime.h\u003e #include \u003cpthread.h\u003e #include \u003cunistd.h\u003e void prepare(void) { printf(\"pid = %d prepare ...\\n\", static_cast\u003cint\u003e(getpid())); } void parent(void) { printf(\"pid = %d parent ...\\n\", static_cast\u003cint\u003e(getpid())); } void child(void) { printf(\"pid = %d child ...\\n\", static_cast\u003cint\u003e(getpid())); } int main(void) { printf(\"pid = %d Entering main ...\\n\", static_cast\u003cint\u003e(getpid())); pthread_atfork(prepare, parent, child); fork(); printf(\"pid = %d Exiting main ...\\n\",static_cast\u003cint\u003e(getpid())); return 0; } ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:9:4","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"8.5 fork造成死锁的例子 deadLock_test.cpp // 一个在多线程程序里fork造成死锁的例子 // 一个输出示例： /* pid = 19445 Entering main ... pid = 19445 begin doit ... pid = 19447 begin doit ... pid = 19445 end doit ... pid = 19445 Exiting main ... 父进程在创建了一个线程，并对mutex加锁， 父进程创建一个子进程，在子进程中调用doit，由于子进程会复制父进程的内存，这时候mutex处于锁的状态， 父进程在复制子进程的时候，只会复制当前线程的执行状态，其它线程不会复制。因此子进程会处于死锁的状态。 */ #include \u003cstdio.h\u003e #include \u003ctime.h\u003e #include \u003cpthread.h\u003e #include \u003cunistd.h\u003e pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; void* doit(void* arg) { printf(\"pid = %d begin doit ...\\n\",static_cast\u003cint\u003e(getpid())); pthread_mutex_lock(\u0026mutex); struct timespec ts = {2, 0}; nanosleep(\u0026ts, NULL); pthread_mutex_unlock(\u0026mutex); printf(\"pid = %d end doit ...\\n\",static_cast\u003cint\u003e(getpid())); return NULL; } int main(void) { printf(\"pid = %d Entering main ...\\n\", static_cast\u003cint\u003e(getpid())); pthread_t tid; pthread_create(\u0026tid, NULL, doit, NULL); struct timespec ts = {1, 0}; nanosleep(\u0026ts, NULL); if (fork() == 0) { doit(NULL); } pthread_join(tid, NULL); printf(\"pid = %d Exiting main ...\\n\",static_cast\u003cint\u003e(getpid())); return 0; } deadLock_test2.cpp #include \u003cstdio.h\u003e #include \u003ctime.h\u003e #include \u003cpthread.h\u003e #include \u003cunistd.h\u003e pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; void* doit(void* arg) { printf(\"pid = %d begin doit ...\\n\",static_cast\u003cint\u003e(getpid())); pthread_mutex_lock(\u0026mutex); struct timespec ts = {2, 0}; nanosleep(\u0026ts, NULL); pthread_mutex_unlock(\u0026mutex); printf(\"pid = %d end doit ...\\n\",static_cast\u003cint\u003e(getpid())); return NULL; } void prepare(void) { pthread_mutex_unlock(\u0026mutex); } void parent(void) { pthread_mutex_lock(\u0026mutex); } int main(void) { pthread_atfork(prepare, parent, NULL); printf(\"pid = %d Entering main ...\\n\", static_cast\u003cint\u003e(getpid())); pthread_t tid; pthread_create(\u0026tid, NULL, doit, NULL); struct timespec ts = {1, 0}; nanosleep(\u0026ts, NULL); if (fork() == 0) { doit(NULL); } pthread_join(tid, NULL); printf(\"pid = %d Exiting main ...\\n\",static_cast\u003cint\u003e(getpid())); return 0; } ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:9:5","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"8.6 Thread类 Thread类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/Thread ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:9:6","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"9. linux同步机制 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:10:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"9.1 MutexLock/MutexLockGuard类 MutexLock/MutexLockGuard类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/Mutex MutexLockGuard(使用RAII技法封装)不管理MutexLock对象的生命周期，它们之间只是关联关系。 聚合：存在与整体与局部的关系。 组合：不仅存在与整体与局部的关系，还负责对象的声明周期。 RAII技法：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/RAII RAII技法参考：借刀杀对象–Raii技法 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:10:1","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"9.2 Condition类 Condition类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/Condition unix条件变量参考：unix同步——条件变量， linux条件变量 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:10:2","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"9.3 CountDownLatch类 CountDownLatch类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/CountDownLatch CountDownLatch中count down是倒数的意思，latch则是门闩的含义。整体含义可以理解为倒数的门栓，似乎有一点“三二一，芝麻开门”的感觉。CountDownLatch的作用也是如此，在构造CountDownLatch的时候需要传入一个整数n，在这个整数“倒数”到0之前，主线程需要等待在门口，而这个“倒数”过程则是由各个执行线程驱动的，每个线程执行完一个任务“倒数”一次。总结来说，CountDownLatch的作用就是等待其他的线程都执行完任务，必要时可以对各个任务的执行结果进行汇总，然后主线程才继续往下执行。 即可以用于所有子线程等待主线程发起\"起跑\"。 也可以用于主线程等待子线程初始化完毕才开始工作。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:10:3","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"10. 队列类的实现 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:11:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"BlockinngQueue类 BlockinngQueue类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/BlockingQueue BlockinngQueue\u003cT\u003e：无界缓冲区。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:11:1","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"BoundedBlockingQueue类 BoundedBlockingQueue类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/BoundedBlockingQueue BoundedBlockingQueue\u003cT\u003e：有界缓冲区，使用的是环形缓冲区(循环利用，读写覆盖)。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:11:2","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"11. 线程池ThreadPool的实现 ThreadPool类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/ThreadPool 线程池问题本质上也是生产者和消费者的问题。ThreadPool存在两个队列： 线程队列：一旦任务队列有任务就唤醒线程队列中的线程(可以理解为消费者线程)来执行这些任务。 任务队列：外部线程(可以认为是生产者线程)可以向任务队列添加任务。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:12:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"12. 线程安全Singleton类 Singleton类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/Singleton pthread_once：某个函数只能被执行一次，这样就能保存对象只能是一个，并且是线程安全的。 atexit：注册一个销毁的函数，让程序结束的时候自动调用该函数来销毁对象。在stdlib.h头文件中。 typedef char T_must_be_complete_type[sizeof(T) == 0 ? -1 : 1];：能保证我们取地址的时候，如果是一个不完全类型的指针在编译期就会报错，而不是警告。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:13:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"12.1 pthread_once()函数详解 在多线程环境中，有些事仅需要执行一次。通常当初始化应用程序时，可以比较容易地将其放在main函数中。但当你写一个库时，就不能在main里面初始化了，你可以用静态初始化，但使用一次初始化(pthread_once)会比较容易些。 int pthread_once(pthread_once_t *once_control, void (*init_routine) (void)) 功能：本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。 在多线程编程环境下，尽管pthread_once()调用会出现在多个线程中，init_routine()函数仅执行一次，究竟在哪个线程中执行是不定的，是由内核调度来决定。 Linux Threads使用互斥锁和条件变量保证由pthread_once()指定的函数执行且仅执行一次，而once_control表示是否执行过。 如果once_control的初值不是PTHREAD_ONCE_INIT(Linux Threads定义为0)，pthread_once() 的行为就会不正常。 在LinuxThreads中，实际\"一次性函数\"的执行状态有三种：NEVER(0)、IN_PROGRESS(1)、DONE (2)，如果once初值设为1，则由于所有pthread_once()都必须等待其中一个激发\"已执行一次\"信号，因此所有pthread_once ()都会陷入永久的等待中；如果设为2，则表示该函数已执行过一次，从而所有pthread_once()都会立即返回0。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:13:1","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"12.2 atexit()函数详解 对C语言有所了解的人都知道main函数是整个程序的入口，但是其实不然，在内核中可以使用链接器来设置程序的开始地方。当内核使⽤⼀个exec函数执⾏C程序时，在调⽤main函数之前先调⽤⼀个特殊的启动例程，可执⾏程序将此例程指定为程序的起始地址。启动例程从内核获取命令⾏参数和环境变量，然后为调⽤main函数做好准备。 前面我们关注的是程序开始进入时的调用函数，而atexit函数是一个特殊的函数，它是在正常程序退出时调用的函数，我们把他叫为登记函数。 int atexit (void (*)(void)) ⼀个进程可以登记若⼲个(具体⾃⼰验证⼀下)个函数，这些函数由exit⾃动调⽤，这些函数被称为终⽌处理函数，atexit函数可以登记这些函数。 exit调⽤终⽌处理函数的顺序和atexit登记的顺序相反(网上很多说造成顺序相反的原因是参数压栈造成的，参数的压栈是先进后出，和函数的栈帧相同)，如果⼀个函数被多次登记，也会被多次调⽤。 atexit函数调用时机： 进程终⽌的⽅式有8种，前5种为正常终⽌，后三种为异常终⽌： 从main函数返回； 调⽤exit函数； 调⽤_exit或_Exit； 最后⼀个线程从启动例程返回； 最后⼀个线程调⽤pthread_exit； 调⽤abort函数； 接到⼀个信号并终⽌； 最后⼀个线程对取消请求做出响应。 exit()和_exit()以及_Exit()函数的本质区别是是否立即进入内核，_exit()以及_Exit()函数都是在调用后立即进入内核，而不会执行一些清理处理，但是exit()则会执行一些清理处理，这也是为什么会存在atexit()函数的原因，因为exit()函数需要执行清理处理，需要执行一系列的操作，这些终止处理函数实际上就是完成各种所谓的清除操作的实际执行体。 下面我们来验证atexit的调用顺序和退出顺序： #include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e //atexit函数所属头文件 void func1() { printf(\"The process is done...\\n\"); } void func2() { printf(\"Clean up the processing\\n\"); } void func3() { printf(\"Exit sucessful..\\n\"); } int main() { //其作用是注册某一个函数，当进程执行结束时，会自动调用注册的函数 //注册几次，就执行几次 atexit(func1); atexit(func2); atexit(func3); exit(0); } 我们可以看到atexit函数的调用顺序是和登记顺序相反的。 atexit函数的用途也是比较广泛的：可以按照你予设的顺序摧毁全局变量(类)，例如有个log类，你在其它的全局类里也有可能调用到Log类写日志。所以log 类必须最后被析构 。假如没有规定析构顺序，那么程序在退出时将有可能首先析构log类，那么其它的全局类在此时将无法正确写日志。 把数据写回文件, 删除临时文件, 这才是真正有用的. ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:13:2","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"12.3 不完全类型检测 Boost库，在头文件checked_delete.hpp中的用于释放空间的类模板函checked_array_delete(T * x)： template\u003cclass T\u003e inline void checked_array_delete(T * x) { typedef char type_must_be_complete[sizeof(T) ? 1: -1]; (void) sizeof(type_must_be_complete); delete [] x; } 这是一种不完全类型检测：T如果不是不完全类型那么sizeof(T)就应该是type_must_be_complete[-1]，数组是不能为负数的，所以就会报错； 什么又是不完全类型呢？简单理解就是类型的定义不完整，比如只对类进行了声明，却未定义； 我们应该尽量让错误在编译时出现，而不是在执行时，所用可以用到不完全类型检测的方法，在编译的时候就会对这种情况报错； 可以通过size_t temp = sizeof(T)来判断，但是这个只能在运行期发现错误。 typedef关键字参考：关键字Typedef深入了解 关键字 typedef 是在编译阶段有效，因此 typedef 有类型检查的功能。 sizeof(T)疑问参考：关于ThreadLocalSingleton.h中判断complete type的疑问 sizeof(T)虽然在编译器完成了计算，但是不一定会报错，不一定~~ ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:13:3","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"13. 线程本地存储ThreadLock类 线程特定数据： 在单线程程序中，我们经常要用到\"全局变量\"以实现多个函数间共享数据。 在多线程环境下，由于数据空间是共享的，因此全局变量也为所有线程所共有。 但有时应用程序设计中有必要提供线程私有的全局变量，仅在某个线程中有效，但却可以跨多个函数访问。 POSIX线程库通过维护一定的数据结构来解决这个问题，这个些数据称为(Thread-specific Data，或 TSD)。 线程特定数据也称为线程本地存储TLS(Thread-local storage)。 对于POD类型的线程本地存储，可以用__thread关键字。 #include \u003cpthread.h\u003e int pthread_key_create (pthread_key_t *__key, void (*__destr_function) (void *)); int pthread_key_delete (pthread_key_t __key); void *pthread_getspecific (pthread_key_t __key); int pthread_setspecific (pthread_key_t __key, const void *__pointer); 说明： 函数 pthread_key_create()用来创建线程私有数据。该函数从 TSD 池中分配一项，将其地址值赋给 key 供以后访问使用。第 2 个参数是一个销毁函数，它是可选的，可以为 NULL，为 NULL 时，则系统调用默认的销毁函数进行相关的数据注销。如果不为空，则在线程退出时(调用pthread_exit()函数)时将以 key 锁关联的数据作为参数调用它，以释放分配的缓冲区，或是关闭文件流等。 不论哪个线程调用了pthread_key_create()，所创建的 key 都是所有线程可以访问的，但各个线程可以根据自己的需要往 key 中填入不同的值，相当于提供了一个同名而不同值的全局变量(这个全局变量相对于拥有这个变量的线程来说)。 注销一个 TSD 使用pthread_key_delete() 函数。该函数并不检查当前是否有线程正在使用该 TSD，也不会调用清理函数(destructor function)，而只是将 TSD 释放以供下一次调用pthread_key_create()使用。在 LinuxThread 中，它还会将与之相关的线程数据项设置为 NULL。 pthread_key_delete()：销毁线程特定数据键。由于键已无效，因此将释放与该键关联的所有内存。在调用该函数之前必须释放所有线程的特定资源，该函数不会调用任何析构函数。反复调用pthread_key_create与pthread_key_delete可能会产生问题。对于每个所需的键，应当只调用pthread_key_create一次。 在多线程程序中，经常要用全局变量来实现多个函数间的数据共享。由于数据空间是共享的，因此全局变量也为所有进程共有。但有时应用程序设计中必要提供线程私有的全局变量，这个变量仅在线程中有效，但却可以跨过多个函数访问。 比如在程序里可能需要每个线程维护一个链表，而会使用相同的函数来操作这个链表，最简单的方法就是使用同名而不同变量地址的线程相关数据结构。这样的数据结构可以由 Posix 线程库维护，成为线程私有数据 (Thread-specific Data，或称为 TSD)。 示例一，线程私有数据： #include \u003cpthread.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e pthread_key_t key; struct test_struct { int i; float k; }; void *child1(void *arg) { struct test_struct struct_data; struct_data.i = 10; struct_data.k = 3.1415; pthread_setspecific(key, \u0026struct_data); printf(\"结构体struct_data的地址为 0x%p\\n\", \u0026(struct_data)); printf(\"child1 中 pthread_getspecific(key)返回的指针为:0x%p\\n\", (struct test_struct *)pthread_getspecific(key)); printf( \"利用 pthread_getspecific(key)打印 child1 \" \"线程中与key关联的结构体中成员值:\\nstruct_data.i:%d\\nstruct_data.k: %f\\n\", ((struct test_struct *)pthread_getspecific(key))-\u003ei, ((struct test_struct *)pthread_getspecific(key))-\u003ek); printf(\"------------------------------------------------------\\n\"); } void *child2(void *arg) { int temp = 20; sleep(2); printf(\"child2 中变量 temp 的地址为 0x%p\\n\", \u0026temp); pthread_setspecific(key, \u0026temp); printf(\"child2 中 pthread_getspecific(key)返回的指针为:0x%p\\n\", (int *)pthread_getspecific(key)); printf(\"利用 pthread_getspecific(key)打印 child2 \" \"线程中与key关联的整型变量temp 值:%d\\n\", *((int *)pthread_getspecific(key))); } int main(void) { pthread_t tid1, tid2; //创建线程私有数据 pthread_key_create(\u0026key, NULL); pthread_create(\u0026tid1, NULL, child1, NULL); pthread_create(\u0026tid2, NULL, child2, NULL); pthread_join(tid1, NULL); pthread_join(tid2, NULL); //将TSD释放以供下一次调用 pthread_key_delete(key); return (0); } output： 结构体struct_data的地址为 0x0x7ffff7a57ea0 child1 中 pthread_getspecific(key)返回的指针为:0x0x7ffff7a57ea0 利用 pthread_getspecific(key)打印 child1 线程中与key关联的结构体中成员值: struct_data.i:10 struct_data.k: 3.141500 ------------------------------------------------------ child2 中变量 temp 的地址为 0x0x7ffff7256ea4 child2 中 pthread_getspecific(key)返回的指针为:0x0x7ffff7256ea4 利用 pthread_getspecific(key)打印 child2 线程中与key关联的整型变量temp 值:20 由输出可见，pthread_getspecific() 返回的是与key 相关联数据的指针。需要注意的是，在利用这个返回的指针时，它首先是 void 类型的，它虽然指向关联的数据地址处，但并不知道指向的数据类型，所以在具体使用时，要对其进行强制类型转换。 其次，两个线程对自己的私有数据操作是互相不影响的。也就是说哦，虽然 key 是同名且全局，但访问的内存空间并不是相同的一个。key 就像是一个数据管理员，线程的私有数据只是到他那去注册，让它知道你这个数据的存在。 示例二，线程与私有数据： #include \u003cpthread.h\u003e #include \u003ciostream\u003e pthread_key_t thread_log_key; /*通用函数里可以利用 pthread_getspecific() 处理线程各自的私有数据*/ void write_to_thread_log(const char *message) { FILE *thread_log = (FILE *)pthread_getspecific(thread_log_key); fprintf(thread_log, \"%s \\n \", message); } void close_thread_log(void *thread_log) { fclose((FILE *)thread_log); } void *thread_function(void *args) { char thread_log_filename[128]; char thread_start_message[128]; FILE *thread_log; sprintf(thread_log_filename, \"thread_%u.log\", pthread_self()); ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:14:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"14. ThreadLocalSingleton类 ThreadLocalSingleton类：https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/ThreadLocalSingleton ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:15:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"15. 日志 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:16:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"15.1 日志 参考：muduo网络库学习 日志作用： 开发过程中： 调试错误 更好的理解程序 运行过程中： 诊断系统故障并处理 记录系统运行状态 建议在实际开发更多使用日志进行调试，而不是GDB。 日志级别： TRACE：指出比DEBUG粒度更细的一些信息事件(开发过程中使用) DEBUG：指出细粒度信息事件对调试应用程序是非常有帮助的。(开发过程中使用) INFO：表明消息在粗粒度级别上突出强调应用程序的运行过程。 WARN：系统能正常运行，但可能会出现潜在错误的情形。 ERROR：指出虽然发生错误事件，但仍然不影响系统的继续运行。 FATAL：指出每个严重的错误事件将会导致应用程序的退出。 Logger使用时序图： Logger =\u003e Impl =\u003e LogStream =\u003e operator« FixedBuffer =\u003e g_output =\u003e g_flush(FATAL级别时调用，也就是说日志的打印不是实时的) 安装boost测试框架：sudo apt-get install libboost-test-dev test库必须依赖两个动态库，分别是boost_unit_test_framework和boost_test_exec_monitor 比较运算符： \u003c,\u003c abcd abcdefg \u003c,\u003c abcdx abcdefg __type_traits：类型特性类 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:16:1","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"15.2 日志滚动 I/O总线，能不能并行？ 多个线程对于同一个文件进行写入，效率可能不如单个线程对同一个文件写入的效率高。 异步日志：多个线程写入的数据发送给另一个线程，进行排队写入，如此就是线程安全的。 日志滚动条件： 文件大小(例如每写满1G换下一个文件) 时间(每天零点新建一个日志文件，不论前一个文件是否写满) 一个典型的日志文件名：logfile_test.20130411-115604.popo.7743.log 第二部分：Muduo网络库 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:16:2","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"16. 多线程与并发服务器设计 iterative服务器： 短链接，单线程，可以处理多个客户端。每次处理完就断开连接。 长连接，单线程，每次只能处理一个客户端。一直read 和 write。 multiple reactors： round robin(轮叫)，均匀调用。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:17:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"17. TCP网络编程本质 TCP网络编程最本质是的处理三个半事件： 连接建立：服务器accept(被动)接受连接，客户端connect(主动)发起连接 连接断开：主动断开(close、shutdown)，被动断开(read返回0) 消息到达：文件描述符可读 消息发送完毕：这算半个。对于低流量的服务，可不必关心这个事件;这里的发送完毕是指数据写入操作系统缓冲区，将由TCP协议栈负责数据的发送与重传，不代表对方已经接收到数据。 网络库事件循环中的可读事件触发，将数据从内核缓冲区移动到应用缓冲区中。并且网络库会回调函数，如：OnMessage。由于TCP接收到的数据可能是宕包，OnMessage这个函数会根据协议判断这个数据包是否是完整的数据包，如果不是完整的数据OnMessage立刻返回，直到内核当中又有数据接收，进行下一次循环操作；如果读到完整的数据，将进行常规处理(read-\u003edecode-\u003ecompute-\u003eencode-\u003ewrite-\u003e进行下一次事件循环)。 调用write(buf,..)函数：如果数据全部填充到了内核缓冲区，网络库回调一个函数，如：OnWriteComplete函数。如果内核缓冲区的不足以容纳buf数据，就会将buf部分的数据放入进来，不足以容纳的数据存放到应用层的发送缓冲区当中。内核的发送缓冲区的数据发送完成后会触发可写事件，继续下一次的事件循环。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:18:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"18. Reactor模式 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:19:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"18.1 简介 Reactor 最核心的事件就是事件分发机制，即将IO multiplexing 拿到的IO事件分发给各个文件描述符(fd)的事件处理函数(handle); multiple reactors + threadpool (one loop per thread + threadpool) Muduo网络库的类图： 白色部分是外部类，对外可见的。灰色部分是内部类，对外不可见。黑色尖头是组合关系，负责生命周期。白色是聚合关系不负责生命周期。 EventLoop是对事件的抽象。 Poller 是对IO 复用的抽象，有两个派生类，PollPoller 对poll 的封装，EPollPoller对epoll的封装 。这个地方是muduo 唯一使用面向对象封装的。 Channel 是对IO事件的注册和响应的封装 。Channel 的Update成员函数负责注册和更新IO的可读可写等事件。Channel 的handleEvent()成员函数是对所发生的IO事件进行处理。一个EventLoop 包含多个Channel，也就是说可以扑捉多个Channel的多个可读可写事件。 Accept 被动连接，Connector主动连接，连接成功后都会创建一个TcpConnection。 Channel是selectable IO channel，负责注册与响应IO 事件，它不拥有file descriptor。 Channel是Acceptor、Connector、EventLoop、TimerQueue、TcpConnection的成员，生命期由后者控制。EventLoop 有一个特殊的Channel 用来唤醒loop 这个特殊的Channel的生命期由EventLoop负责。 EventLoop与Poller的关系是组合，一个EventLoop包含一个Poller，并且Poller的生命周期由EventLoop控制，EventLoop::loop()函数实际是通过Poller::poll()函数来实现的。 Channel是对I/O事件的注册与响应的封装，Channel::update()函数负责注册或更新I/O的可读和可写事件，同时会调用到EventLoop::updateChannel()函数，这个函数又会调用Poller::updateChannel()函数，相当于将这个Channle这个对象注册到Poller对象中，或者说将Channel对象中的fd(文件描述符)的可读、可写事件注册到Poller对象中；Channel::handleEvent()函数负责对所发生的I/O事件进行处理。 一个EventLoop对象包含多个Channel对象，也就是说EventLoop可捕获多个Channel(通道)的可读、可写事件。一对多，且是聚合的关系。也就是说EventLoop不负责Channel的生命周期。Channel的生命周期由TcpConnection、Acceptor、Connector等等这些类来控制。 Channel对象不拥有fd(文件描述符)，也就是说当Channel对象销毁的时候不关闭文件描述符。Channel对象和文件描述符是关联关系，一个Channel有一个fd，一个EventLoop有多个fd，而这个fd是被套接字(Socket)所拥有的。也就是说fd的生命周期由套接字来控制，当套接字对象销毁时，文件描述符对象就会销毁(Socket::close)。 Channel对象又是TcpConnection、Acceptor、Connector类的成员，它们与Channel对象之间也是组合关系，Channel的生命周期由它们来控制。 Acceptor是对被动连接的抽象，它关心的是监听事件的可读事件，监听事件的可读事件是由Channel来注册，触发事件调用Channel::handleEvent()函数，这个函数通过回调从而调用Acceptor::handleRead()函数来响应事件。这样的手法是基于对象的编程思想。 TcpConnection是对已连接套接字的抽象。 一旦被动连接(Acceptor)或主动连接(Connector)建立，就会得到一个已连接的套接字。即获得TcpConnection。 TcpServer和Acceptor是组合关系，TcpServer控制着Acceptor的生命周期。 TcpClient和Connector是组合关系，TcpClient控制着Connector的生命周期。 TcpServer与TcpConnection是聚合关系，一个TcpServer包含多个TcpConnection，但不控制TcpConnection的生命周期。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:19:1","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"18.2 EventLoop类 EventLoop概述： Poller是封装了和事件监听有关的方法和成员，调用一次Poller::poll方法它就能给你返回事件监听器的监听结果(发生事件的fd及其发生的事件)。作为一个网络服务器，需要有持续监听、持续获取监听结果、持续处理监听结果对应的事件的能力，也就是我们需要循环的去调用Poller:poll方法获取实际发生事件的Channel集合，然后调用这些Channel里面保管的不同类型事件的处理函数(调用Channel::HandlerEvent方法)。 EventLoop就是负责实现\"循环”，负责驱动“循环”的重要模块！！Channel和Poller提供接口供EventLoop的使用，EventLoop整合封装了二者并向上提供了更方便的接口来使用。 EventLoop起到一个驱动循环的功能，Poller负责从事件监听器上获取监听结果。而Channel类则在其中起到了将fd及其相关属性封装的作用，将fd及其感兴趣事件和发生的事件以及不同事件对应的回调函数封装在一起，这样在各个模块中传递更加方便。 EventLoop类重要的成员变量： //说明：在linux中对bool类型的操作都是原子性的 bool looping_; //判断EventLoop是否在事件循环中 bool quit_; //判断是否停止事件循环(不是立刻停止) bool eventHandling_; //判断是否处于处理事件中 const pid_t threadId_; // 当前对象所属线程ID Timestamp pollReturnTime_;//执行完Poller::poll()的时间 boost::scoped_ptr\u003cPoller\u003e poller_; boost::scoped_ptr\u003cTimerQueue\u003e timerQueue_; ChannelList activeChannels_; // Poller返回的活动通道 Channel *currentActiveChannel_; // 当前正在处理的活动通道 One Loop Per Thread 含义介绍： 每一个EventLoop都绑定了一个线程(一对一绑定)，这种运行模式是Muduo库的特色！！充份利用了多核cpu的能力，每一个核的线程负责循环监听一组文件描述符的集合。 EventLoop类最重要的两个方法： void EventLoop::loop() { //.............. //EventLoop 所属线程执行 while(!quit_) { activeChannels_.clear(); pollReturnTime_ = poller_-\u003epoll(kPollTimeMs, \u0026activeChannels_);//此时activeChannels已经填好了事件发生的channel for(Channel *channel : activeChannels_) channel-\u003eHandlerEvent(pollReturnTime_); //.............. } //.............. } 每个EventLoop对象都唯一绑定了一个线程，这个线程其实就在一直执行这个函数里面的while循环，这个while循环的大致逻辑比较简单。就是调用Poller::poll方法获取事件监听器上的监听结果。接下来在loop里面就会调用监听结果中每一个Channel的处理函数HandlerEvent()。每一个Channel的处理函数会根据Channel类中封装的实际发生的事件，执行Channel类中封装的各事件处理函数。(比如一个Channel发生了可读事件，可写事件，则这个Channel的HandlerEvent()就会在调用提前注册好这个Channel的可读、可写事件处理函数，又比如另一个Channel只发生了可读事件，那么HandlerEvent()就只会调用提前注册在这个Channel中的可读事件处理函数)。 EventLoop的主要功能就是持续循环的获取监听结果并且根据结果调用处理函数。 void EventLoop::runInLoop(const Functor \u0026cb) { if (isInLoopThread()) { cb(); } else { queueInLoop(cb); } } void EventLoop::queueInLoop(const Functor \u0026cb) { { MutexLockGuard lock(mutex_); pendingFunctors_.push_back(cb); } if (!isInLoopThread() || callingPendingFunctors_) { wakeup(); } } 此函数的作用是为外部线程提供接口，将函数注入到EventLoop所属的线程中执行。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:19:2","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"18.3 Channel类 Channel类概述： Channel类其实相当于一个文件描述符的保姆！一个Channel对象关联一个文件描述符，但不拥有它(不负责这个文件描述符的生命周期)。Channel类则封装了一个fd和这个fd感兴趣事件，以及事件监听器监听到该fd实际发生的事件。 在TCP网络编程中，我们可以通过I/O复用，将这个fd和fd感兴趣的事情通过epoll_ctl注册到IO多路复用模块(事件监视器)。当事件监听器监听到该fd发生了某个事件。事件监听器返回 所有发生事件的fd集合以及每个fd都发生了什么事件。 实际上Channel类就是将上述操作进行封装。 Channel是selectable IO channel，负责注册与响应IO事件，它不拥有file descriptor。 Channel是Acceptor、Connector、EventLoop、TimerQueue、TcpConnection的成员，生命期由后者控制。 Channel类重要的成员变量： EventLoop *loop_; // 所属EventLoop const int fd_; // Channel对象绑定的文件描述符，但不负责关闭该文件描述符 int events_; // 关注的事件 int revents_; // poll/epoll返回的事件，即实际监听到发生的事件类型 int index_; // used by Poller.表示在poll的事件数组中的序号，初始值为-1 bool logHup_; // for POLLHUP 对方描述符挂起 boost::weak_ptr\u003cvoid\u003e tie_; bool tied_; bool eventHandling_; // 是否处于处理事件中 ReadEventCallback readCallback_; EventCallback writeCallback_; EventCallback closeCallback_; EventCallback errorCallback_; loop：就是这个Channel所属的EventLoop对象 fd_：Channel对象所关联的文件描述符 events_：fd_所关注的事件 revents_：fd_实际发生的事件 index_：表示在poll的事件数组中的序号，初始值为-1 readCallback_、writeCallback_、closeCallback_、errorCallback_：代表着这个Channel为这个文件描述符保存的各事件类型发生时的处理函数。 Channel类重要的成员方法： 向Channel对象注册各类事件的处理函数： void setReadCallback(const ReadEventCallback \u0026cb) { readCallback_ = cb; } void setWriteCallback(const EventCallback \u0026cb) { writeCallback_ = cb; } void setCloseCallback(const EventCallback \u0026cb) { closeCallback_ = cb; } void setErrorCallback(const EventCallback \u0026cb) { errorCallback_ = cb; } 一个文件描述符会发生可读、可写、关闭、错误事件。当发生这些事件后，就需要调用相应的处理函数来处理。外部通过调用上面这四个函数可以将事件处理函数放进Channel类中，当需要调用的时候就可以直接拿出来调用了。 将Channel中的文件描述符及其感兴趣事件注册事件监听器上或从事件监听器上移除： void enableReading() {events_ |= kReadEvent; upadte();} void disableReading() {events_ \u0026= ~kReadEvent; update();} void enableWriting() {events_ |= kWriteEvent; update();} void disableWriting() {events_ \u0026= ~kWriteEvent; update();} void disableAll() {events_ |= kNonEvent; update();} 外部通过这几个函数来告知Channel你所监管的文件描述符都对哪些事件类型感兴趣，并把这个文件描述符及其感兴趣事件注册到事件监听器(IO多路复用模块)上。这些函数里面都有一个update()私有成员方法，这个update其实本质上就是调用了epoll_ctl()。 当事件监听器监听到某个文件描述符发生了什么事件，通过如下函数可以将这个文件描述符实际发生的事件封装进这个Channel中。 int set_revents(int revt) {revents_ = revt;} 当调用epoll_wait()后，可以得知事件监听器上哪些Channel(文件描述符)发生了哪些事件，事件发生后就可以调用这些Channel对应的处理函数。Channel::HandleEvent，让每个发生了事件的Channel调用自己保管的事件处理函数。每个Channel会根据自己文件描述符实际发生的事件(通过Channel中的revents_变量得知)和感兴趣的事件(通过Channel中的events_变量得知)来选择调用read_callback_和/或write_callback_和/或close_callback_和/或error_callback_。 void HandlerEvent(TimeStamp receive_time); ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:19:3","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"18.4 Poller类 Poller概述: 负责监听文件描述符事件是否触发以及返回发生事件的文件描述符以及具体事件的模块就是Poller。所以可以理解为一个Poller对象对应一个事件监听器。 muduo提供了epoll和poll两种IO多路复用方法来实现事件监听。不过默认是使用epoll来实现，也可以通过选项选择poll。 这个Poller是个抽象虚类，由EpollPoller和PollPoller继承实现，与监听文件描述符和返回监听结果的具体方法是在这两个派生类中实现。EpollPoller就是封装了用epoll方法实现的与事件监听有关的各种方法，PollPoller就是封装了poll方法实现的与事件监听有关的各种方法。 Poller派生类的重要成员： EventLoop *ownerLoop_; // Poller所属EventLoop int epollfd_; EventList events_; ChannelMap channels_; //文件标识符与Channel对象的映射关系 ownerLoop_：Poller所属的EventLoop对象 epollfd_：用epoll_create方法返回的epoll句柄 events_：监听事件的集合，通过vector容器实现动态扩容 channels_：文件描述符与Channel对象的映射关系，通过map容器来管理 Poller派生类给外部提供的最重要的方法： TimeStamp poll(int timeoutMs, ChannelList *activeChannels); 这个函数可以说是Poller的核心，当外部调用poll方法的时候，该方法底层其实是通过epoll_wait获取这个事件监听器上发生事件的fd及其对应发生的事件，我们知道每个fd都是由一个Channel封装的，通过哈希表channels_可以根据fd找到封装这个fd的Channel。将事件监听器监听到该fd发生的事件写进这个Channel中的revents成员变量中。然后再把这个Channel装进activeChannels中(它是一个vector\u003cChannel*\u003e)。这样，当外部调用完poll之后就能拿到事件监听器的监听结果(activeChannels_容器)。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:19:4","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"18.5 定时器 定时函数，用于让程序等待一段时间或安排计划任务： sleep alarm usleep nanosleep clock_nanosleep getitimer / setitimer timer_create / timer_settime / timer_gettime / timer_delete timerfd_create / timerfd_gettime / timerfd_settime timerfd_* 入选的原因： sleep / alarm / usleep 在实现时有可能用了信号 SIGALRM，在多线程程序中处理信号是个相当麻烦的事情，应当尽量避免 nanosleep 和 clock_nanosleep 是线程安全的，但是在非阻塞网络编程中，绝对不能用让线程挂起的方式来等待一段时间，程序会失去响应。正确的做法是注册一个时间回调函数。 getitimer 和 timer_create 也是用信号来 deliver 超时，在多线程程序中也会有麻烦。 timer_create 可以指定信号的接收方是进程还是线程，算是一个进步，不过在信号处理函数(signal handler)能做的事情实在很受限。 timerfd_create 把时间变成了一个文件描述符，该“文件”在定时器超时的那一刻变得可读，这样就能很方便地融入到 select/poll 框架中，用统一的方式来处理 IO 事件和超时事件，这也正是 Reactor 模式的长处。 信号转换成文件描述符来处理： 如果要处理信号的话，也可以让信号转换成文件描述符来处理，signalfd #include \u003csys/timerfd.h\u003e int timerfd_create(int clockid, int flags); int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value); int timerfd_gettime(int fd, struct itimerspec *curr_value) 示例： #include \"Channel.h\" #include \"EventLoop.h\" #include \u003cboost/bind.hpp\u003e #include \u003cstdio.h\u003e #include \u003csys/timerfd.h\u003e using namespace muduo; using namespace muduo::net; EventLoop *g_loop; int timerfd; void timeout(Timestamp receiveTime) { printf(\"Timeout!\\n\"); uint64_t howmany; ::read(timerfd, \u0026howmany, sizeof howmany); // 这里一定要读走，不然处于高电平状态一直触发 g_loop-\u003equit(); } int main(void) { EventLoop loop; g_loop = \u0026loop; timerfd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC); Channel channel(\u0026loop, timerfd); channel.setReadCallback(boost::bind(timeout, _1)); channel.enableReading(); struct itimerspec howlong; bzero(\u0026howlong, sizeof howlong); howlong.it_value.tv_sec = 1; ::timerfd_settime(timerfd, 0, \u0026howlong, NULL); loop.loop(); ::close(timerfd); } muduo的定时器由三个类实现，TimerId、Timer、TimerQueue，用户只能看到第一个类，其它两个都是内部实现细节。 TimerQueue的接口很简单，只有两个函数addTimer和cancel。调用addTimer 返回timerld。添加定时器， timerld 是外部类。调用cancel 传递timerld 取消定时器。实际使用也不用TimerQueue的方法，使用的时候用EventLoop提供的函数。TimerQueue 会调用实际的定时器函数。 EventLoop： runAt 在某个时刻运行定时器 runAfter 过一段时间运行定时器 runEvery 每隔一段时间运行定时器 cancel 取消定时器 TimerQueue数据结构的选择，能快速根据当前时间找到已到期的定时器，也要高效的添加和删除Timer，因而可以用二叉搜索树，用map或者set： typedef std::pair\u003cTimestamp, Timer*\u003e Entry; typedef std::set\u003cEntry\u003e TimerList; 以Entry作为key时，存在Timestamp对象是相同的，只需保证pair的first(Timestamp)或second(Timer)其中一个不相等就可以。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:19:5","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"18.6 lower_bound() 和 upper_bound() 参考：C++ lower_bound 与upper_bound函数的使用 lower_bound在set中用法：二分查找一个有序数列，返回第一个大于等于x的数，如果没找到，返回末尾的迭代器位置。 lower_bound()函数与upper_bound()函数都是基于二分搜索操作的函数，其操作对象是有序的。lower_bound()函数返回指向第一个不小于给定值的元素的迭代器，upper_bound()函数返回指向第一个大于给定值的元素的迭代器。 lower_bound函数： 对lower_bound函数而言，其默认的比较函数是operator\u003c。下面是一个简单的示例。例子中，data中存储的是按照非严格递增的方式存储的数据。 #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cvector\u003e int main() { std::vector\u003cint\u003e data = {1, 2, 4, 5, 5, 6}; for (int i = 0; i \u003c 8; i++) { auto iter = lower_bound(data.begin(), data.end(), i); if (iter != data.end()) { std::cout \u003c\u003c \"首个不小于\" \u003c\u003c i \u003c\u003c \"的元素的索引为：\" \u003c\u003c distance(data.begin(), iter); std::cout \u003c\u003c \" 该元素为：\" \u003c\u003c *iter \u003c\u003c '\\n'; } else { std::cout \u003c\u003c \"data中不存在不小于\" \u003c\u003c i \u003c\u003c \"的元素\" \u003c\u003c std::endl; } } } output： 首个不小于0的元素的索引为：0 该元素为：1 首个不小于1的元素的索引为：0 该元素为：1 首个不小于2的元素的索引为：1 该元素为：2 首个不小于3的元素的索引为：2 该元素为：4 首个不小于4的元素的索引为：2 该元素为：4 首个不小于5的元素的索引为：3 该元素为：5 首个不小于6的元素的索引为：5 该元素为：6 data中不存在不小于7的元素 upper_bound函数： #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cvector\u003e int main() { std::vector\u003cint\u003e data = {1, 2, 4, 5, 5, 6}; for (int i = 0; i \u003c 8; i++) { auto iter = upper_bound(data.begin(), data.end(), i); if (iter != data.end()) { std::cout \u003c\u003c \"首个大于\" \u003c\u003c i \u003c\u003c \"的元素的索引为：\" \u003c\u003c distance(data.begin(), iter); std::cout \u003c\u003c \" 该元素为：\" \u003c\u003c *iter \u003c\u003c '\\n'; } else { std::cout \u003c\u003c \"data中不存在大于\" \u003c\u003c i \u003c\u003c \"的元素\" \u003c\u003c std::endl; } } } output： 首个大于0的元素的索引为：0 该元素为：1 首个大于1的元素的索引为：1 该元素为：2 首个大于2的元素的索引为：2 该元素为：4 首个大于3的元素的索引为：2 该元素为：4 首个大于4的元素的索引为：3 该元素为：5 首个大于5的元素的索引为：5 该元素为：6 data中不存在大于6的元素 data中不存在大于7的元素 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:19:6","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"18.7 C++ 编译器优化之 RVO 与 NRVO C++ 编译器优化之 RVO 与 NRVO RVO 即 “Return Value Optimization”，是一种编译器优化技术，通过该技术编译器可以减少函数返回时生成临时值值(对象)的个数，从某种程度上可以提高程序的运行效率，对需要分配大量内存的类对象其值复制过程十分友好。NRVO 全称为 “Named Return Value Optimization”，该优化的大致流程与 RVO 类似。 #include \u003ciostream\u003e class A { public: A() { std::cout \u003c\u003c \"[C] constructor fired.\" \u003c\u003c std::endl; } A(const A \u0026a) { std::cout \u003c\u003c \"[C] copying constructor fired.\" \u003c\u003c std::endl; } A(A \u0026\u0026a) { std::cout \u003c\u003c \"[C] moving copying constructor fired.\" \u003c\u003c std::endl; } ~A() { std::cout \u003c\u003c \"[C] destructor fired.\" \u003c\u003c std::endl; } }; A getTempA() { return A(); } int main(int argc, char **argv) { auto x = getTempA(); return 0; } output： [C] constructor fired. [C] destructor fired. ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:19:7","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"18.8 线程唤醒 线程唤醒方法： 一个线程如何通知另一个等待中的线程，可以有三个方法： pipe管道有一对文件描述符。pipe[0] 对应管道的读端，pipe[1] 对应管道的写端，等待的线程关注pipe[0]的读端，通知线程向pipe[1] 写入数据，pipe[0] 就变的可读了，等待线程获得通知就唤醒线程。 socketpair 和管道一样有一对文件描述符，不同的是可以双向通信。 eventfd。等待线程监听文件描述符可读事件，通知线程只要往这个线程写入数据，等待线程就会获得通知。是一个比 pipe 更高效的线程间事件通知机制，一方面它比 pipe 少用一个 file descripor，节省了资源；另一方面，eventfd 的缓冲区管理也简单得多，全部“buffer” 只有定长8 bytes，不像 pipe 那样可能有不定长的真正 buffer。 int createEventfd() { int evtfd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC); if (evtfd \u003c 0) { LOG_SYSERR \u003c\u003c \"Failed in eventfd\"; abort(); } return evtfd; } EventLoop::EventLoop() : looping_(false), quit_(false), eventHandling_(false), callingPendingFunctors_(false), threadId_(CurrentThread::tid()), poller_(Poller::newDefaultPoller(this)), timerQueue_(new TimerQueue(this)), wakeupFd_(createEventfd()), wakeupChannel_(new Channel(this, wakeupFd_)), currentActiveChannel_(NULL) { LOG_TRACE \u003c\u003c \"EventLoop created \" \u003c\u003c this \u003c\u003c \" in thread \" \u003c\u003c threadId_; // 如果当前线程已经创建了EventLoop对象，终止(LOG_FATAL) if (t_loopInThisThread) { LOG_FATAL \u003c\u003c \"Another EventLoop \" \u003c\u003c t_loopInThisThread \u003c\u003c \" exists in this thread \" \u003c\u003c threadId_; } else { t_loopInThisThread = this; } wakeupChannel_-\u003esetReadCallback(boost::bind(\u0026EventLoop::handleRead, this)); // we are always reading the wakeupfd //这里设置回将wakeupChannel_注册到Poller对象中，实现事件循环 wakeupChannel_-\u003eenableReading(); } // 唤醒，写uint64_t类型的字节就可产生可读事件，达到唤醒的目的 void EventLoop::wakeup() { uint64_t one = 1; // ssize_t n = sockets::write(wakeupFd_, \u0026one, sizeof one); ssize_t n = ::write(wakeupFd_, \u0026one, sizeof one); if (n != sizeof one) { LOG_ERROR \u003c\u003c \"EventLoop::wakeup() writes \" \u003c\u003c n \u003c\u003c \" bytes instead of 8\"; } } // eventfd 事件处理函数 void EventLoop::handleRead() { uint64_t one = 1; // ssize_t n = sockets::read(wakeupFd_, \u0026one, sizeof one); ssize_t n = ::read(wakeupFd_, \u0026one, sizeof one); if (n != sizeof one) { LOG_ERROR \u003c\u003c \"EventLoop::handleRead() reads \" \u003c\u003c n \u003c\u003c \" bytes instead of 8\"; } } EventLoop中非常有用的一个函数EventLoop::runInLoop：在IO线程中执行某个回调函数，该函数可以跨线程调用。 // 在I/O线程中执行某个回调函数，该函数可以跨线程调用 void EventLoop::runInLoop(const Functor \u0026cb) { if (isInLoopThread()) { // 如果是当前IO线程调用runInLoop，则同步调用cb cb(); } else { // 如果是其它线程调用runInLoop，则异步地将cb添加到队列，以便让EventLoop所在的线程执行这个回调函数 queueInLoop(cb); } } void EventLoop::queueInLoop(const Functor \u0026cb) { { MutexLockGuard lock(mutex_); pendingFunctors_.push_back(cb); } // 调用queueInLoop的线程不是IO线程需要唤醒 // 或者调用queueInLoop的线程是IO线程，并且此时正在调用pendingfunctor，需要唤醒。只有IO线程的事件回调中调用queueInLoop才不需要唤醒 if (!isInLoopThread() || callingPendingFunctors_) { wakeup(); } } 让IO线程也能执行一些计算任务，其他线程或者本线程添加的一些回调任务，IO不忙的时候，处于阻塞状态。 // 事件循环，该函数不能跨线程调用 // 只能在创建该对象的线程中调用 void EventLoop::loop() { //省略代码*************** while (!quit_) { //省略代码*************** // 让IO线程也能执行一些计算任务，IO不忙的时候，处于阻塞状态 doPendingFunctors(); // 其他线程或者本线程添加的一些回调任务 } LOG_TRACE \u003c\u003c \"EventLoop \" \u003c\u003c this \u003c\u003c \" stop looping\"; looping_ = false; } void EventLoop::doPendingFunctors() { std::vector\u003cFunctor\u003e functors; callingPendingFunctors_ = true; { MutexLockGuard lock(mutex_); functors.swap(pendingFunctors_); } for (size_t i = 0; i \u003c functors.size(); ++i) { functors[i](); } callingPendingFunctors_ = false; } 不是简单地在临界区内依次调用Functor，而是把回调列表swap到functors中，这样一方面减小了临界区的长度(意味着不会阻塞其它线程的queueInLoop())，另一方面，也避免了死锁(因为Functor可能再次调用queueInLoop())。 由于doPendingFunctors()调用的Functor可能再次调用queueInLoop(cb)，这时，queueInLoop()就必须wakeup()，否则新增的cb可能就不能及时调用了。 muduo没有反复执行doPendingFunctors()直到pendingFunctors为空，这是有意的，否则IO线程可能陷入死循环，无法处理IO事件。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:19:8","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"EchoServer类 基于对象的编程思想EchoServer ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:20:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"EventLoopThread类 Muduo库的设计是基于对象的编程思想。 任何一个线程，只要创建并运行了EventLoop，都称之为IO线程。 一个程序可以有多个IO线程，IO线程不一定是主线程。 muduo并发模型one loop per thread + threadpool。一个线程有且只有一个EventLoop，一个程序可以有多个IO线程，这些IO线程可以用IO线程池来管理。这里有两个线程池，一个IO线程池一个计算线程池主要用于计算任务。IO线程也可以执行计算任务，EventLoop中的runInLoop() 可以执行计算任务。 为了方便今后使用，定义了EventLoopThread类，该类封装了IO线程。 EventLoopThread创建了一个线程 在线程函数中创建了一个EvenLoop对象并调用EventLoop::loop ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:21:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"Socket类 Endian.h 封装了字节序转换函数(全局函数，位于muduo::net::sockets名称空间中)。 SocketsOps.h/ SocketsOps.cpp 封装了socket相关系统调用(全局函数，位于muduo::net::sockets名称空间中)。 Socket.h/Socket.cc(Socket类) 用RAII方法封装socket file descriptor。 InetAddress.h/InetAddress.cc(InetAddress类) 网际地址sockaddr_in封装 VALGRIND宏：能检测内存泄露的情况，还能检测文件描述符的状态 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:22:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"Acceptor类 Acceptor用于accept(2)接受TCP连接 Acceptor的数据成员包括Socket、Channel，Acceptor的socket是listening socket(即server socket)。Channel用于观察此socket的readable事件，并回调Accptor::handleRead()，后者调用accept(2)来接受新连接，并回调用户callback。 Acceptor 示例： #include \"Acceptor.h\" #include \"EventLoop.h\" #include \"InetAddress.h\" #include \"SocketsOps.h\" #include \u003cstdio.h\u003e using namespace muduo; using namespace muduo::net; void newConnection(int sockfd, const InetAddress \u0026peerAddr) { printf(\"newConnection(): accepted a new connection from %s\\n\", peerAddr.toIpPort().c_str()); ::write(sockfd, \"How are you?\\n\", 13); sockets::close(sockfd); } int main() { printf(\"main(): pid = %d\\n\", getpid()); InetAddress listenAddr(8888); EventLoop loop; Acceptor acceptor(\u0026loop, listenAddr); acceptor.setNewConnectionCallback(newConnection); acceptor.listen(); loop.loop(); } 模拟客户端： $ telnet 127.0.0.1 8888 Trying 127.0.0.1... Connected to 127.0.0.1. Escape character is '^]'. How are you? Connection closed by foreign host. ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:23:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"TcpServer/TcpConnection Acceptor类的主要功能是socket、bind、listen 一般来说，在上层应用程序中，我们不直接使用Acceptor，而是把它作为TcpServer的成员 TcpServer还包含了一个TcpConnection列表 TcpConnection与Acceptor类似，有两个重要的数据成员，Socket与Channel ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:24:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"TcpConnection生存期管理 第5步，在TcpSever中removeConnection 移除掉TcpConnection, 正常应该在移除后销毁掉TcpConnection，但是不能销毁，如果现在销毁了TcpConnection的Channel对象也就跟着销毁了，而这时调用Channel的handleEvent() 函数，就会出现Core Dump，所以说TcpConnection 的生命期应该长于Channel对象。 当连接到来，创建一个TcpConnection对象，立刻用share_ptr 来管理，引用计数为1， 在Channel中维护一个weak_ptr(tie_)，将这个share_ptr 对象赋值给tie_，引用计数仍为1， 当连接关闭，在handleEvent()，将tie_提升，得到一个share_ptr 对象，引用计数就变成了2。 第6步TcpServer 中erase 后引用计数变为1，第七步queueInLoop 加入bind 引用计数变为2，handleEvent 执行完引用计数减1变为1，bind执行完后引用计数变为0，自动销毁。 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:24:1","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"muduo库如何支持多线程 由EventLoopThread（IO线程类）、EventLoopThreadPool（IO线程池类）实现 IO线程池的功能是开启若干个IO线程，并让这些IO线程处于事件循环的状态 ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:25:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"Buffer类 为什么需要有应用层缓冲区？ muduo网络库使用IO复用，并且文件描述符使用非阻塞模式，如果使用阻塞模式那么read、write就会阻塞在这些系统调用之上，这样一来即使其他文件描述符的IO到来也不能立刻去处理，也就不能最大限度的使用IO线程。 考虑一个常见场景:程序想通过 TCP 连接 发送 100k 字节的数据，但是在 write() 调用中，操作系统只接受了 80k 字节(受 TCP advertised window 的控制，细节见 TCPv1)，你肯定不想在原地等待，因为不知道 会等多久(取决于对方什么时候接受数据，然后滑动 TCP 窗口)。程序应该尽快交出 控制权，返回 event loop。在这种情况下，剩余的 20k 字节数据怎么办? 所以需要一个应用层缓冲区。 接收到数据，存至input buffer，通知上层的应用程序，OnMessage(Buffer * buff) 回调，根据应用层协议判定是否是一个完整的包，codec,如果不是一条完整的消息，不会取走数据，也不会进行相应的处理，如果是一条完整的消息，将取走这条消息，并进行相应的处理。 怎么判断一条完整的消息是应用层的逻辑. Buffer 的要求 Muduo Buffer 的设计考虑了常见的网络编程需求，我试图在易用性和性能之间找一个平衡点，目前这个平衡点更偏向于易用性。 Muduo Buffer 的设计要点: 对外表现为一块连续的内存 (char*, len)，以方便客户代码的编写。 其 size() 可以自动增长，以适应不同大小的消息。它不是一个 fixed size array(即 char buf[8192])。 内部以 vector of char 来保存数据，并提供相应的访问函数。 Buffer 其实像是一个 queue，从末尾写入数据，从头部读出数据。 epoll使用LT模式的原因： 与poll兼容 LT模式不会发生漏掉事件的BUG，但POLLOUT事件不能一开始就关注，否则会出现busy loop，而应该在write无法完全写入内核缓冲区的时候才关注，将未写入内核缓冲区的数据添加到应用层output buffer，直到应用层output buffer写完，停止关注POLLOUT事件。 读写的时候不必等候EAGAIN，可以节省系统调用次数，降低延迟。（注：如果用ET模式，读的时候读到EAGAIN,写的时候直到output buffer写完或者EAGAIN） 可变类型解决方案： void*. 这种方法不是类型安全的 boost::any boost::any： 任意类型的类型安全存储以及安全的取回 在标准库容器中存放不同类型的方法，比如说vectorboost::any ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:26:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["c/c++"],"content":"TCP客户端的支持 muduo库对编写tcp客户端程序的支持： Connector：主动发起连接，带有自动重连功能 TcpClient：包含了一个Connector对象 测试程序： TcpServer_test.cpp // echo server TcpClient_test.cpp // echo client ","date":"2022-10-31","objectID":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:27:0","tags":["muduo"],"title":"大并发服务器开发","uri":"/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["计算机网络"],"content":"1. 开始前的准备 首先在cmd窗口执行ifconfig命令，查看主机ip地址： C:\\Users\\Administrator\u003eipconfig Windows IP 配置 以太网适配器 以太网: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::5c0e:5588:3612:7a99%14 IPv4 地址 . . . . . . . . . . . . : 192.168.3.28 子网掩码 . . . . . . . . . . . . : 255.255.254.0 默认网关. . . . . . . . . . . . . : 192.168.2.1 得到主机地址：192.168.3.28 然后启动wireshark工具开始在网卡(因特网)开始抓包。 继续在cmd窗口执行ping命令： C:\\Users\\Administrator\u003eping www.baidu.com 正在 Ping www.a.shifen.com [14.215.177.39] 具有 32 字节的数据: 来自 14.215.177.39 的回复: 字节=32 时间=7ms TTL=56 来自 14.215.177.39 的回复: 字节=32 时间=6ms TTL=56 来自 14.215.177.39 的回复: 字节=32 时间=6ms TTL=56 来自 14.215.177.39 的回复: 字节=32 时间=7ms TTL=56 14.215.177.39 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 6ms，最长 = 7ms，平均 = 6ms 可以清楚的知道目标主机ip地址：14.215.177.39 操作完成后相关数据包就抓取到了，可以通过在过滤栏设置过滤条件进行数据包列表过滤： //说明：只显示ICPM协议且源主机IP或者目的主机IP为192.168.3.28的数据包，协议名称icmp要小写。 ip.addr == 192.168.3.28 and icmp ","date":"2022-10-24","objectID":"/posts/wireshark/:1:0","tags":["wireshark"],"title":"wireshark抓包","uri":"/posts/wireshark/"},{"categories":["计算机网络"],"content":"2. wireshark界面 WireShark 主要分为这几个界面： Display Filter(显示过滤器)， 用于设置过滤条件进行数据包列表过滤。 Packet List Pane(数据包列表)， 显示捕获到的数据包，每个数据包包含编号，时间戳，源地址，目标地址，协议，长度，以及数据包信息。 不同协议的数据包使用了不同的颜色区分显示。 Packet Details Pane(数据包详细信息), 在数据包列表中选择指定数据包，在数据包详细信息中会显示数据包的所有详细信息内容。数据包详细信息面板是最重要的，用来查看协议中的每一个字段。各行信息分别为： Frame：物理层的数据帧概况 Ethernet II：数据链路层以太网帧头部信息 Internet Protocol Version 4：互联网层IP包头部信息 Transmission Control Protocol：传输层T的数据段头部信息，此处是TCP Hypertext Transfer Protocol：应用层的信息，此处是HTTP协议 ","date":"2022-10-24","objectID":"/posts/wireshark/:2:0","tags":["wireshark"],"title":"wireshark抓包","uri":"/posts/wireshark/"},{"categories":["计算机网络"],"content":"3. wireshark过滤器表达式的规则 ","date":"2022-10-24","objectID":"/posts/wireshark/:3:0","tags":["wireshark"],"title":"wireshark抓包","uri":"/posts/wireshark/"},{"categories":["计算机网络"],"content":"3.1 抓包过滤器语法和实例 抓包过滤器类型Type（host、net、port）、方向Dir（src、dst）、协议Proto（ether、ip、tcp、udp、http、icmp、ftp等）、逻辑运算符（\u0026\u0026 与、|| 或、！非） 1. 协议过滤 比较简单，直接在抓包过滤框中直接输入协议名即可: TCP，只显示TCP协议的数据包列表 HTTP，只查看HTTP协议的数据包列表 ICMP，只显示ICMP协议的数据包列表 2. IP过滤 host 192.168.1.104：主机IP为192.168.1.104的地址 src host 192.168.1.104：源主机IP为192.168.1.104的地址 dst host 192.168.1.104：目标主机IP为192.168.1.104的地址 3. 端口过滤 port 80：端口为80 src port 80：源端口为80 dst port 80：目标端口为80 4. 逻辑运算符\u0026\u0026 与、|| 或、！非 src host 192.168.1.104 \u0026\u0026 dst port 80：抓取主机地址为192.168.1.80、目的端口为80的数据包 host 192.168.1.104 || host 192.168.1.102：抓取主机为192.168.1.104或者192.168.1.102的数据包 ！broadcast：不抓取广播数据包 ","date":"2022-10-24","objectID":"/posts/wireshark/:3:1","tags":["wireshark"],"title":"wireshark抓包","uri":"/posts/wireshark/"},{"categories":["计算机网络"],"content":"3.2 显示过滤器语法和实例 1. 比较操作符 比较操作符有== 等于、！= 不等于、\u003e 大于、\u003c 小于、\u003e= 大于等于、\u003c=小于等于。 2. 协议过滤 比较简单，直接在Filter框中直接输入协议名即可。注意：协议名称需要输入小写。 tcp：只显示TCP协议的数据包列表 http：只查看HTTP协议的数据包列表 icmp：只显示ICMP协议的数据包列表 3. ip过滤 ip.src == 192.168.1.104：显示源地址为192.168.1.104的数据包列表 ip.dst == 192.168.1.104：显示目标地址为192.168.1.104的数据包列表 ip.addr == 192.168.1.104：显示源IP地址或目标IP地址为192.168.1.104的数据包列表 4. 端口过滤 tcp.port == 80：显示源主机或者目的主机端口为80的数据包列表。 tcp.srcport == 80：只显示TCP协议的源主机端口为80的数据包列表。 tcp.dstport == 80：只显示TCP协议的目的主机端口为80的数据包列表。 5. Http模式过滤 http.request.method == \"GET\"：只显示HTTP GET方法的。 6. 逻辑运算符为 and/or/not 过滤多个条件组合时，使用and/or。比如获取IP地址为192.168.1.104的ICMP数据包表达式为：ip.addr == 192.168.1.104 and icmp 7. 按照数据包内容过滤 假设我要以IMCP层中的内容进行过滤，可以单击选中界面中的码流，在下方进行选中数据。如下： 右键单击选中后出现如下界面： 选中Select后在过滤器中显示如下： 后面条件表达式就需要自己填写。如下我想过滤出data数据包中包含\"abcd\"内容的数据流。包含的关键词是contains 后面跟上内容： ","date":"2022-10-24","objectID":"/posts/wireshark/:3:2","tags":["wireshark"],"title":"wireshark抓包","uri":"/posts/wireshark/"},{"categories":["计算机网络"],"content":"4. 传输层 ","date":"2022-10-24","objectID":"/posts/wireshark/:4:0","tags":["wireshark"],"title":"wireshark抓包","uri":"/posts/wireshark/"},{"categories":["计算机网络"],"content":"4.1 TCP协议 TCP连接必须要经历三次握手，而释放一个TCP连接需要四次握手，这是由TCP的半关闭特性造成的。因为TCP连接时全双工的，因此，需要TCP两端要单独执行关闭。值得注意的是，主动关闭的一端在发送FIN之后，依然还能正常接收对方的数据，只是通知对方它已经没有数据需要发送了，同理，被动关闭的一端在收到FIN之后，仍然可以发送数据，直到它自身同样发出FIN之后，才停止发送数据。 TCP报文格式： Source Port和Destination Port：分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接； Sequence Number：用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题； Acknowledgment Number：32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题； Offset：给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节； TCP Flags：TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下： URG：此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据； ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0； TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1 PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队； RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包； SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手； FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。 Window：窗口大小 编写如下代码进行测试： sayHello_server.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e void error_handling(char *message); int main(int argc, char *argv[]) { int serv_sock; int clnt_sock; struct sockaddr_in serv_addr; struct sockaddr_in clnt_addr; socklen_t clnt_addr_size; char message[]=\"Hello World!\"; if(argc!=2){ printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } //创建服务端socket，通过serv_sock创建与客户端连接的socket serv_sock=socket(PF_INET, SOCK_STREAM, 0); if(serv_sock == -1) error_handling(\"socket() error\"); //设置描述的地址和端口号 memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family=AF_INET; serv_addr.sin_addr.s_addr=htonl(INADDR_ANY); serv_addr.sin_port=htons(atoi(argv[1])); //将socket_fd 和serv_addr进行绑定 if(bind(serv_sock, (struct sockaddr*) \u0026serv_addr, sizeof(serv_addr))==-1 ) error_handling(\"bind() error\"); //设置排队建立3次握手队列和刚刚建立3次握手队列的连接上限和 if(listen(serv_sock, 5)==-1) error_handling(\"listen() error\"); while(1) { //阻塞，与客户端建立连接，三次握手 =》 client_fd clnt_addr_size=sizeof(clnt_addr); clnt_sock=accept(serv_sock, (struct sockaddr*)\u0026clnt_addr,\u0026clnt_addr_size); if(clnt_sock==-1) error_handling(\"accept() error\"); //给clnt_sock客户连接发送数据: Hello World! write(clnt_sock, message, sizeof(message)); //关闭连接，close fd close(clnt_sock); } close(serv_sock); return 0; } void error_handling(char *message) { //将错误信息写入到标准错误流 fputs(message, stderr); fputc('\\n', stderr); exit(1); } 功能说明：该服务程序，每次有客户端建立了连接，将发送\"Hello World!“数据给客户端，然后主动关闭连接。 查看主机ip为：192.168.88.129 cjt@cjt-virtual-machine:~/Desktop$ ifconfig ens33: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 192.168.88.129 netmask 255.255.255.0 broadcast 192.168.88.255 inet6 fe80::8c62:ec9c:c28d:2b05 prefixlen 64 scopeid 0x20\u003clink\u003e ether 00:0c:29:94:b9:cb txqueuelen 1000 (Ethernet) RX packets 31660 bytes 41281586 (41.2 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3930 bytes 289516 (289.5 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u003cUP,LOOPBACK,RUNNING\u003e mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u003chost\u003e loop txqueuelen 1000 (Local Loopback) RX packets 6178 bytes 505457 (505.4 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 6178 bytes 505457 (505.4 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 启动服务： gcc sayHello_server.c -o sayHello_server ./sayHello_server \u0026 开始监听网卡，然后客户端连接： cjt@cjt-virtual-machine:~/Desktop$ telnet 192.168.88.129 8888 Trying 192.168.88.129... Connected to 192.168.88.129. Escape character is '^]'. Hello World!Connection closed by foreign host. 抓包数据：sayHello_tcp.pcapng ","date":"2022-10-24","objectID":"/posts/wireshark/:4:1","tags":["wireshark"],"title":"wireshark抓包","uri":"/posts/wireshark/"},{"categories":["c/c++"],"content":"1. 头文件stdio.h ","date":"2022-10-16","objectID":"/posts/c%E6%A0%87%E5%87%86%E5%BA%93/:1:0","tags":["c/c++"],"title":"C标准库","uri":"/posts/c%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["c/c++"],"content":"1.1 fopen函数 C 库函数 FILE *fopen(const char *filename, const char *mode) 使用给定的模式 mode 打开 filename 所指向的文件。 #include \u003cstdio.h\u003e FILE *fopen(const char *filename, const char *mode) 调用fopen函数，成功返回一个 FILE 指针，失败则返回 NULL，且设置全局变量 errno 来标识错误。 filename：表示要打开的文件名称。 mode：表示文件的访问模式。 文件的访问模式： 模式 描述 “r” 打开一个用于读取的文件。该文件必须存在。 “w” 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。 “a” 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。 “r+” 打开一个用于更新的文件，可读取也可写入。该文件必须存在。 “w+” 创建一个用于读写的空文件。 “a+” 打开一个用于读取和追加的文件。 写入文件file.txt：We are in 2022 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { FILE * fp; fp = fopen (\"./file/file.txt\", \"w+\"); fprintf(fp, \"%s %s %s %d\", \"We\", \"are\", \"in\", 2022); fclose(fp); return(0); } 显示文件file.txt的内容： #include \u003cstdio.h\u003e int main () { FILE *fp; int c; fp = fopen(\"file.txt\",\"r\"); while(1) { c = fgetc(fp); if( feof(fp) ) { break ; } printf(\"%c\", c); } fclose(fp); return(0); } ","date":"2022-10-16","objectID":"/posts/c%E6%A0%87%E5%87%86%E5%BA%93/:1:1","tags":["c/c++"],"title":"C标准库","uri":"/posts/c%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["c/c++"],"content":"1.2 fclose函数 C 库函数 int fclose(FILE *stream) 关闭流 stream。刷新所有的缓冲区。 调用fclose函数，如果流成功关闭，则该方法返回零。如果失败，则返回 EOF。 stream：这是指向 FILE 对象的指针，该 FILE 对象指定了要被关闭的流。 ","date":"2022-10-16","objectID":"/posts/c%E6%A0%87%E5%87%86%E5%BA%93/:1:2","tags":["c/c++"],"title":"C标准库","uri":"/posts/c%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["c/c++"],"content":"1.3 fwrite函数 C 库函数 size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 把 ptr 所指向的数组中的数据写入到给定流 stream 中。 #include \u003cstdio.h\u003e size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 调用fwrite，如果成功返回一个size_t对象，表示元素的总数(nmemb)，该对象是一个整型数据类型。 ptr：这是指向要被写入的元素数组的指针。 size：这是要被写入的每个元素的大小，以字节为单位。 nmemb：这是元素的个数，每个元素的大小为 size 字节。 stream：这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。 #include\u003cstdio.h\u003e int main () { FILE *fp; char str[] = \"This is data!\"; fp = fopen( \"./file/file.txt\" , \"w\" ); // fwrite(str, sizeof(str) , 1, fp ); //两种方式 fwrite(str, 1, sizeof(str), fp ); fclose(fp); return(0); } ","date":"2022-10-16","objectID":"/posts/c%E6%A0%87%E5%87%86%E5%BA%93/:1:3","tags":["c/c++"],"title":"C标准库","uri":"/posts/c%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["网络编程"],"content":"1. 理解网络编程和套接字 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"1.1 套接字概念 在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。套接字通信原理如下图所示： 在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应另一端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:1","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"2 网络编程和套接字 IP是Internet Protocol(网络协议)的简写，是为了收发网络数据而分配给计算机的值。端口号并非赋予计算机的值，而是为了区分程序中创建的套接字而分配给套接字的序号。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"2.1 socket函数 #include \u003csys/socket.h\u003e int socket (int domain, int type, int protocol); 调用socket函数，成功返回文件描述符，失败返回-1。 domain：套接字中使用的协议族(Protocol Family)信息。一般使用 PF_INET IPv4互联网协议族。 type： 套接字数据传输类型信息。一般使用 SOCK_STREAM 面向连接的套接字。 protocol：计算机通信中使用的协议信息。一般为 0。 头文件sys/socket.h中声明的协议族： 名称 协议族 PF_INET IPv4互联网协议族 PF_INET6 IPv6互联网协议族 PF_LOCAL 本地通信的UNIX协议族 PE_PACKET 底层套接字的协议族 PF_IPX IPX Novell协议族 套接字类型: 面向连接的套接字(SOCK_STREAM) 传输过程中数据不会消失； 按序传输数据 传输的数据不存在数据边界(Boundary) 可靠的、按序列传递的、基于字节的面向连接的数据传输方式的套接字。 面向消息的套接字(SOCK_DGRAM) 强调快速传输而非传输顺序。 传输的数据可能丢失，也可能被销毁。 传输的数据有边界。 限制每次传输的数据大小。 不可靠的、不按序传递的，以数据的高速传输为目的的套接字 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:1","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"2.2 bind函数 #include \u003csys/socket.h\u003e int bind (int sockfd, struct sockaddr *myaddr, socklen_t addrlen); 调用bind函数，成功返回0，失败返回-1。若此函数调用成功，则将第二个参数指定的地址信息分配给第一个参数中的相应套接字。 sockfd：要分配地址信息(IP地址和端口号)的套接字文件描述符。 myaddr：存有地址信息的结构体变量地址值。 addrlen：第二个结构体变量的长度。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:2","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"2.3 listen函数 #include \u003csys/socket.h\u003e int listen(int sockfd, int backlog); 调用listen函数，成功返回0，失败返回-1。 sockfd：希望进入等待请求状态的套接字文件描述符，传递的描述符套接字成为服务器端套接字(监听套接字)。 backlog：连接请求等待队列(Queue)的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:3","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"2.4 accept函数 #include \u003csys/socket.h\u003e int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 调用accept函数，成功返回文件描述符，失败返回-1。 sockfd：服务器套接字的文件描述符。 addr：保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息。 addrlen：第二个参数addr结构体的长度，但是存有长度的变量地址。就是该函数调用完成后，该变量即被填入客户端地址长度。 accept函数受理连接请求等待队列中待处理的客户端连接请求。函数调用成功时，accept函数内部将产生用于数据I/O的套接字，并返回其文件描述符。需要强调的是，套接字是自动创建的，并自动与发起连接请求的客户端建立连接。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:4","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"2.5 connect函数 #include \u003csys/socket.h\u003e int connect(int sockfd, struct sockaddr *serv_addr, socklen_t addrlen); 调用connect函数，成功返回0，失败返回-1。 sockfd：客户端套接字文件描述符。 serv_addr：保存目标服务器端地址信息的变量地址值。 addrlen：以字节为单位传递已传递给第二个结构体参数serv_addr的地址变量长度。 客户端调用connect函数后，发生以下情况之一才会返回(完成函数调用): 服务器端接收连接请求。 发生断网等异常情况而中断连接请求。 所谓的\"接收连接\"并不意味着服务器端调用accept函数，其实是服务器端把连接请求信息记录到等待队列。因此connect函数返回后并不立即进行数据交换。 基于TCP的服务端/客户端函数调用关系： ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:5","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"2.6 编写Hello world程序 hello_client.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e void error_handling(char *message); int main(int argc, char* argv[]) { int sock; struct sockaddr_in serv_addr; char message[30]; int str_len; if(argc!=3){ printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } //客户端创建一个和服务端建立连接的套接字 sock=socket(PF_INET, SOCK_STREAM, 0); if(sock == -1) error_handling(\"socket() error\"); //设置描述的地址和端口号 memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family=AF_INET; serv_addr.sin_addr.s_addr=inet_addr(argv[1]); serv_addr.sin_port=htons(atoi(argv[2])); //与服务端建立连接，三次握手 if(connect(sock, (struct sockaddr*)\u0026serv_addr, sizeof(serv_addr))==-1) error_handling(\"connect() error!\"); //阻塞，从服务端读取数据 str_len=read(sock, message, sizeof(message)-1); if(str_len==-1) error_handling(\"read() error!\"); printf(\"Message from server: %s \\n\", message); //断开与客户端的连接，四次挥手 close(sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } hello_server.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e void error_handling(char *message); int main(int argc, char *argv[]) { int serv_sock; int clnt_sock; struct sockaddr_in serv_addr; struct sockaddr_in clnt_addr; socklen_t clnt_addr_size; char message[]=\"Hello World!\"; if(argc!=2){ printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } //创建服务端socket，通过serv_sock创建与客户端连接的socket serv_sock=socket(PF_INET, SOCK_STREAM, 0); if(serv_sock == -1) error_handling(\"socket() error\"); //设置描述的地址和端口号 memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family=AF_INET; serv_addr.sin_addr.s_addr=htonl(INADDR_ANY); serv_addr.sin_port=htons(atoi(argv[1])); //将socket_fd 和serv_addr进行绑定 if(bind(serv_sock, (struct sockaddr*) \u0026serv_addr, sizeof(serv_addr))==-1 ) error_handling(\"bind() error\"); //设置排队建立3次握手队列和刚刚建立3次握手队列的连接上限和 if(listen(serv_sock, 5)==-1) error_handling(\"listen() error\"); //阻塞，与客户端建立连接，三次握手 =》 client_fd clnt_addr_size=sizeof(clnt_addr); clnt_sock=accept(serv_sock, (struct sockaddr*)\u0026clnt_addr,\u0026clnt_addr_size); if(clnt_sock==-1) error_handling(\"accept() error\"); //给clnt_sock客户连接发送数据 write(clnt_sock, message, sizeof(message)); //关闭连接，close fd close(clnt_sock); close(serv_sock); return 0; } void error_handling(char *message) { //将错误信息写入到标准错误流 fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:6","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"3 基于Linux的文件操作 在Linux中，socket也被认为是文件的一种，因此在网络传输过程中可以使用文件I/O的相关函数。 文件描述符是系统分配给文件或套接字的一个整数。每当生成文件或套接字，操作系统将返回分配给它们的整数，这个整数将成为程序员与操作系统之间良好沟通的渠道。实际上，文件描述符只不过是未来方便称呼操作系统创建的文件或套接字而赋予的数值而已。 标准输入输入及错误的文件描述符： 文件描述符 对象 0 标准输入: Standard Input 1 标准输出: Standard Output 2 标准错误: Standard Error 文件和套接字一般经过创建过程才会被分配文件描述符。而上述对象即使未经过特殊的创建过程，程序开始运行后也会被自动分配文件描述符。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"3.1 open函数 #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e int open(const char *path, int flag); 调用open函数，成功时返回文件描述符，失败返回-1。 path：文件名的字符串地址。 flag：文件打开的模式信息。 文件打开模式： 打开模式 含义 O_CREAT 必要时创建文件 O_TRUNC 删除全部现有数据 O_APPEND 维持现有数据，保存到其后面 O_RDONLY 只读打开 O_WRONLY 只写打开 ORDWR 读写打开 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:1","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"3.2 close函数 #include \u003cunistd.h\u003e int close(int fd); 调用close函数，成功返回0，失败返回-1。 fd：需要关闭的文件或套接字的文件描述符。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:2","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"3.3 write函数 #include \u003cunistd.h\u003e ssize_t write(int fd, const void *buf, size_t nbytes); 调用write函数，成功时返回写入的字节数，失败返回-1。 fd：数据传输对象的文件描述符 buf：要传输数据的起始地址 nbytes：要传输数据的字节数 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:3","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"3.4 read函数 #include \u003cunistd.h\u003e ssize_t read(int fd, void *buf, size_t nbytes); 调用read函数，成功时返回接收的字节数(但遇到文件结尾则返回0)，失败时返回-1。 fd：数据接收对象的文件描述符 buf：要接收数据的起始地址 nbytes：要接收数据的最大字节数 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:4","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"4. 地址族与数据序列 端口号就是在同一操作系统内为区分不同套接字而设置的，因此无法将1个端口号分配给不同的套接字。总之，数据传输目标地址同时包含IP地址和端口号，只有这样，数据才会被传输到最终的目的应用程序(应用程序套接字)。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"4.1 网络地址(Internet Address) 为使计算机连接到网络并收发数据，必须向其分配IP地址。IP地址分为两类。 IPv4(Internet Protocol version 4) 4字节地址族 IPv6(Internet Protocol version 6) 6字节地址族 IPv4地址的结构体 struct sockaddr_in { sa_family_t sin_family; //地址族(Address Family) uint16_t sin_port; //16位TCP/UDP端口号 struct in_addr sin_addr; //32位IP地址 char sin_zero[8]; //不使用，设置为0 } sockaddr_in结构体中的另一个结构体struct in_addr，它是用来存放32位的IP地址 struct in_addr { In_addr_t s_addr; //32位IPv4的地址 } 结构体sockaddr_in的成员分析： 成员sin_family 地址族(Address Family) 含义 AF_INET | IPv4网络协议中使用的地址族 | AF_INET6 | IPv6网络协议中使用的地址族 | AF_LOCAL | 本地通信中采用的UNIX协议的地址族 | AF_LOCAL只是为了说明具有多种地址族而添加的。 成员sin_port 该成员保存16位端口号，它以网络字节序保存。 成员sin_addr 该成员保存32位IP地址信息，它以网络字节序保存。 成员sin_zero 无特殊含义。只是为了使用结构体sockaddr_in的大小与sockaddr结构体保持一致而插入的成员。必须填充为0，否则无法得到想要的结果。 bind函数的第二个参数期望得到sockaddr结构体变量地址值，包括地址族、端口号、IP地址等。 struct sockaddr { sa_family_t sin_family; //地址族(Address Family) char sa_data[14]; //地址信息 } 此结构体成员sa_data保存的地址信息中需包含IP地址和端口号，剩余部分应该填充为0，这也是bind函数要求的。而对于包含地址信息来讲非常麻烦，继而就有了新的结构体sockaddr_in。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:1","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"4.2 网络字节序与地址转换 CPU向内存保存数据的方式有两种，这意味着CPU解析数据的方式也分为两种。 大端序(Big Endian)：高位字节存放地位地址。网络字节序(Network Byte Order)，统一为大端序。 小端序(Little Endian)：高位字节存放到高位地址。主机字节序一般采取的形式。 int n = 0x12345678; 小端存储：78 56 34 12 大端存储：12 34 56 78 转换字节序的函数： unsigned short htons(unsigned short); 把short型数据从主机字节序转换为网络字节序。 unsigned short ntohs(unsigned short); 把short型数据从网络字节序转换为主机字节序。 unsigned long htonl(unsigned short); 把long型数据从主机字节序转换为网络字节序。 unsigned long ntohl(unsigned short); 把long型数据从网络字节序转换为主机字节序。 通过函数名可以了解其功能： 函数名中的h代表主机(host)字节序。 函数名中的n代表网络(network)字节序。 函数名中的s指的是short。 函数名中的l指的是long。(Linux中的long类型占用4个字节) 小端运行环境的例子： #include \u003cstdio.h\u003e #include \u003carpa/inet.h\u003e int main(int argc, char *argv[]) { unsigned short host_port=0x1234; //该值按照小端的方式进行存储 unsigned short net_port; unsigned long host_addr=0x12345678; //该值按照小端的方式进行存储 unsigned long net_addr; net_port=htons(host_port); net_addr=htonl(host_addr); printf(\"Host ordered port: %#x \\n\", host_port); printf(\"Network ordered port: %#x \\n\", net_port); printf(\"Host ordered address: %#lx \\n\", host_addr); printf(\"Network ordered address: %#lx \\n\", net_addr); return 0; } 对于IP地址的表示，我们熟悉的是点分十进制表示法(Dotted Decimal Notation)，而非整数型数据的表示法。 通过inet_addr函数，我们可以将字符串式的IP地址转换为32位整数型数据，而且可以检测无效的IP地址。此函数在转换类型的同时进行网络字节序的转换。 #include \u003carpa/inet.h\u003e in_add_t inet_addr(const char *string); 调用inet_addr函数，成功返回32位大端序整数型值，失败时返回INADDR_NONE。 #include \u003cstdio.h\u003e #include \u003carpa/inet.h\u003e int main(int argc, char *argv[]) { char *addr1=\"127.212.124.78\"; char *addr2=\"127.212.124.256\"; unsigned long conv_addr=inet_addr(addr1); if(conv_addr==INADDR_NONE) printf(\"Error occured! \\n\"); else printf(\"Network ordered integer addr: %#lx \\n\", conv_addr); conv_addr=inet_addr(addr2); if(conv_addr==INADDR_NONE) printf(\"Error occureded \\n\"); else printf(\"Network ordered integer addr: %#lx \\n\\n\", conv_addr); return 0; } inet_aton函数与inet_addr函数功能是一样的，只不过该函数利用了in_addr结构体，且使用频率更高。 #include \u003carpa/inet.h\u003e int inet_aton(const char *string, struct in_addr *addr); 调用inet_aton函数，成功返回1，失败返回0。 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003carpa/inet.h\u003e void error_handling(char *message); int main(int argc, char *argv[]) { char *addr=\"127.232.124.79\"; struct sockaddr_in addr_inet; if(!inet_aton(addr, \u0026addr_inet.sin_addr)) error_handling(\"Conversion error\"); else printf(\"Network ordered integer addr: %#x \\n\", addr_inet.sin_addr.s_addr); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } inet_ntoa函数可以把网络字节序整数型IP地址转换成我们熟悉的字符串形式。 #include \u003carpa/inet.h\u003e char * inet_ntoa(struct in_addr adr); 调用inet_ntoa函数，成功时返回转换的字符串地址值，失败时返回-1。 该函数的返回类型为char指针，意味着调用该函数会在内部申请了内存并保存了这个字符串。所以调用完该函数，应立即将字符串内容复制保存起来，因为下次调用inet_ntoa函数，则有可能覆盖之前保存的字符串信息。 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003carpa/inet.h\u003e int main(int argc, char *argv[]) { struct sockaddr_in addr1, addr2; char *str_ptr; char str_arr[20]; addr1.sin_addr.s_addr=htonl(0x1020304); addr2.sin_addr.s_addr=htonl(0x1010101); str_ptr=inet_ntoa(addr1.sin_addr); strcpy(str_arr, str_ptr); printf(\"Dotted-Decimal notation1: %s \\n\", str_ptr); inet_ntoa(addr2.sin_addr); printf(\"Dotted-Decimal notation2: %s \\n\", str_ptr); printf(\"Dotted-Decimal notation3: %s \\n\", str_arr); return 0; } /* root@com:/home/swyoon/tcpip# gcc inet_ntoa.c -o ntoa root@com:/home/swyoon/tcpip# ./ntoa Dotted-Decimal notation1: 1.2.3.4 Dotted-Decimal notation2: 1.1.1.1 Dotted-Decimal notation3: 1.2.3.4 */ 网络地址初始化 struct sockaddr_in addr; char *serv_ip = \"127.0.0.1\"; //声明IP地址字符串 char *ser_port = \"9190\"; //声明端口号字符串 memset(\u0026addr, 0, sizeof(addr)); 结构体变量addr的所有成员初始化为0 addr.sin_family = AF_INET; //指定IPv4协议族 addr.sin_addr.s_addr = inet_addr(serv_ip); //基于字符串的IP地址初始化 addr.sin_port = htons(atoi(serv_port)); //基于字符串的端口号初始化 每次创建服务端套接字都要输入IP地址，可以利用INADDR_ANY分配服务端的IP地址。采用这种方式，则可以自动获取服务端的计算机IP地址。 addr.sin_addr.s_addr = htonl(INADDR_ANY); ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:2","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"5. 基于TCP的服务端/客户端 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"5.1 缺陷的echo版本 echo_server.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 1024 void error_handling(char *message); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; char message[BUF_SIZE]; int str_len, i; struct sockaddr_in serv_adr; struct sockaddr_in clnt_adr; socklen_t clnt_adr_sz; if(argc!=2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } serv_sock=socket(PF_INET, SOCK_STREAM, 0); if(serv_sock==-1) error_handling(\"socket() error\"); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=htonl(INADDR_ANY); serv_adr.sin_port=htons(atoi(argv[1])); if(bind(serv_sock, (struct sockaddr*)\u0026serv_adr, sizeof(serv_adr))==-1) error_handling(\"bind() error\"); if(listen(serv_sock, 5)==-1) error_handling(\"listen() error\"); clnt_adr_sz=sizeof(clnt_adr); while(1) { clnt_sock=accept(serv_sock, (struct sockaddr*)\u0026clnt_adr, \u0026clnt_adr_sz); if(clnt_sock==-1) error_handling(\"accept() error\"); else printf(\"Connected client %d \\n\", i+1); //接收客户端的数据，然后再原封不动的发回给客户端 while((str_len=read(clnt_sock, message, BUF_SIZE))!=0) { write(clnt_sock, message, str_len); } close(clnt_sock); } close(serv_sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } echo_cilent.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 1024 void error_handling(char *message); int main(int argc, char *argv[]) { int sock; char message[BUF_SIZE]; int str_len; struct sockaddr_in serv_adr; if(argc!=3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } sock=socket(PF_INET, SOCK_STREAM, 0); if(sock==-1) error_handling(\"socket() error\"); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=inet_addr(argv[1]); serv_adr.sin_port=htons(atoi(argv[2])); if(connect(sock, (struct sockaddr*)\u0026serv_adr, sizeof(serv_adr))==-1) error_handling(\"connect() error!\"); else puts(\"Connected...........\"); while(1) { fputs(\"Input message(Q to quit): \", stdout); fgets(message, BUF_SIZE, stdin); if(!strcmp(message,\"q\\n\") || !strcmp(message,\"Q\\n\")) break; //发生数据给服务端 write(sock, message, strlen(message)); //阻塞接收服务端的数据 str_len=read(sock, message, BUF_SIZE-1); message[str_len]=0; printf(\"Message from server: %s\", message); } close(sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } 上面的程序存在很大的问题，因为TCP是基于流的，但保证数据能够完整的传输。write函数的调用只是把数据放入到发送缓冲区中，至于何时发送，发送大小是多少，这些都是不确定的；read函数从接收缓存区中拿数据，每次能拿多少也是不确定的。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:1","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"5.2 简易的echo版本 在收发数据过程中，我们可以简单规范一下应用层协议：每发送一次数据，都在数据前4字节存放数据的大小，这样接收端就能明确的知道每次的接收数据的大小(每条消息的长度)。 echo_server.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 1024 void error_handling(char *message); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; char message[BUF_SIZE]; int str_len, i = 0; struct sockaddr_in serv_adr; struct sockaddr_in clnt_adr; socklen_t clnt_adr_sz; if(argc!=2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } serv_sock=socket(PF_INET, SOCK_STREAM, 0); if(serv_sock==-1) error_handling(\"socket() error\"); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=htonl(INADDR_ANY); serv_adr.sin_port=htons(atoi(argv[1])); if(bind(serv_sock, (struct sockaddr*)\u0026serv_adr, sizeof(serv_adr))==-1) error_handling(\"bind() error\"); if(listen(serv_sock, 5)==-1) error_handling(\"listen() error\"); clnt_adr_sz=sizeof(clnt_adr); //没开启多线程，只处理一个客户端；可以通过one loop思想处理多个客户 while(1) { clnt_sock=accept(serv_sock, (struct sockaddr*)\u0026clnt_adr, \u0026clnt_adr_sz); if(clnt_sock==-1) error_handling(\"accept() error\"); else printf(\"Connected client %d \\n\", ++i); int quit = 0; while(!quit) { //接收客户端的数据，然后再原封不动的发回给客户端 //先接受数据的长度 int size = 0; while(size != 4) { int len = read(clnt_sock, message + size, 4 - size); if(len == -1) { error_handling(\"read() error!\"); } if(len == 0) { quit = 1; break; } size += len; } int str_size = (message[0] \u003c\u003c 24) + (message[1] \u003c\u003c 16) + (message[2] \u003c\u003c 8) + (message[3] \u003c\u003c 0); // printf(\"%d %d %d %d\\n\", message[0],message[1],message[2],message[3]); // printf(\"%d\\n\", str_size); str_len = 0; while(str_len != str_size) { int len = read(clnt_sock, message + size + str_len, str_size - str_len); if(len == -1) { error_handling(\"read() error!\"); } if(len == 0) { quit = 1; break; } str_len += len; } if(!quit) { write(clnt_sock, message, str_size + 4); message[str_size + 4] = 0; printf(\"Send Message to client(%d): %s\", clnt_sock, message + 4); } } close(clnt_sock); } close(serv_sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } echo_cilent.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 1024 void error_handling(char *message); int main(int argc, char *argv[]) { int sock; char message[BUF_SIZE]; int str_len; struct sockaddr_in serv_adr; if(argc!=3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } sock=socket(PF_INET, SOCK_STREAM, 0); if(sock==-1) error_handling(\"socket() error\"); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=inet_addr(argv[1]); serv_adr.sin_port=htons(atoi(argv[2])); if(connect(sock, (struct sockaddr*)\u0026serv_adr, sizeof(serv_adr))==-1) error_handling(\"connect() error!\"); else puts(\"Connected...........\"); while(1) { fputs(\"Input message(Q to quit): \", stdout); fgets(message + 4, BUF_SIZE - 4 - 1, stdin); if(!strcmp(message + 4,\"q\\n\") || !strcmp(message + 4,\"Q\\n\")) break; // *((int *)message) = strlen(message + 4); int message_len = strlen(message + 4); message[0] = (message_len \u003e\u003e 24) \u0026 0xFF; message[1] = (message_len \u003e\u003e 16) \u0026 0xFF; message[2] = (message_len \u003e\u003e 8) \u0026 0xFF; message[3] = (message_len \u003e\u003e 0) \u0026 0xFF; //发生数据给服务端 write(sock, message, message_len + 4); // printf(\"%d %d %d %d\\n\", message[0],message[1],message[2],message[3]); // printf(\"%s\\n\", message + 4); //先接收客户端一次发送的数据长度 int size = 0; while(size != 4) { int len = read(sock, message + size, 4 - size); if(len == -1) { error_handling(\"read() error!\"); } size += len; } int str_size = (message[0] \u003c\u003c 24) + (message[1] \u003c\u003c 16) + (message[2] \u003c\u003c 8) + (message[3] \u003c\u003c 0); str_len = 0; while(str_len != str_size) { int len = read(sock, message + size + str_len, str_size - str_len); if(len == -1) { error_handling(\"read() error!\"); } str_len += len; } message[str_size + 4] = 0; printf(\"Message from server: %s\", mess","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:2","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"5.3 简单的操作运算 客户端连接到服务端后以1字节整数形式转递待算数个数。 客户端向服务器端传递的每个整数型数据占用4个字节空间。 传递整数型数据后接着传递运算符。运算符信息占用1字节。 目前支持操作符：+、-、*。 服务端以4个字节整数型向客户端传回运算结果。 客户端得到运算结果后终止与服务端的连接。 调用close函数将向对方传递EOF。 op_client.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 1024 #define RLT_SIZE 4 #define OPSZ 4 void error_handling(char *message); int main(int argc, char *argv[]) { int sock; char opmsg[BUF_SIZE]; int result, opnd_cnt, i; struct sockaddr_in serv_adr; if(argc!=3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } sock=socket(PF_INET, SOCK_STREAM, 0); if(sock==-1) error_handling(\"socket() error\"); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=inet_addr(argv[1]); serv_adr.sin_port=htons(atoi(argv[2])); if(connect(sock, (struct sockaddr*)\u0026serv_adr, sizeof(serv_adr))==-1) error_handling(\"connect() error!\"); else puts(\"Connected...........\"); fputs(\"Operand count: \", stdout); scanf(\"%d\", \u0026opnd_cnt); opmsg[0]=(char)opnd_cnt;//先获得操作数的个数 for(i=0; i\u003copnd_cnt; i++) { printf(\"Operand %d: \", i+1); scanf(\"%d\", (int*)\u0026opmsg[i*OPSZ+1]);//保存操作数 } fgetc(stdin);//删掉缓冲中的字符 =》 scanf函数产生的 fputs(\"Operator: \", stdout); scanf(\"%c\", \u0026opmsg[opnd_cnt*OPSZ+1]);//获取操作符 write(sock, opmsg, opnd_cnt*OPSZ+2); //获取服务端计算的结果(4字节) int len = 0; while(len \u003c RLT_SIZE) { len = read(sock, (char *)\u0026result + len, RLT_SIZE - len); } printf(\"Operation result: %d \\n\", result); close(sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } op_server.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 1024 #define OPSZ 4 void error_handling(char *message); int calculate(int opnum, int opnds[], char oprator); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; char opinfo[BUF_SIZE]; int result, opnd_cnt, i; int recv_cnt, recv_len; struct sockaddr_in serv_adr, clnt_adr; socklen_t clnt_adr_sz; if(argc!=2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } serv_sock=socket(PF_INET, SOCK_STREAM, 0); if(serv_sock==-1) error_handling(\"socket() error\"); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=htonl(INADDR_ANY); serv_adr.sin_port=htons(atoi(argv[1])); if(bind(serv_sock, (struct sockaddr*)\u0026serv_adr, sizeof(serv_adr))==-1) error_handling(\"bind() error\"); if(listen(serv_sock, 5)==-1) error_handling(\"listen() error\"); clnt_adr_sz=sizeof(clnt_adr); for(i=0; i\u003c5; i++) { clnt_sock=accept(serv_sock, (struct sockaddr*)\u0026clnt_adr, \u0026clnt_adr_sz); //先获取操作数的数量 opnd_cnt=0; int len = 0; while(len \u003c 1) { len = read(clnt_sock, (char *)\u0026opnd_cnt + len, 1 - len); } //获取全部数据 recv_len = len - 1; while((opnd_cnt*OPSZ+1)\u003erecv_len) { //BUF_SIZE - recv_len - 1: 因为操作符已经占用一个字节了 recv_cnt = read(clnt_sock, \u0026opinfo[recv_len], BUF_SIZE - recv_len - 1); recv_len += recv_cnt; } result=calculate(opnd_cnt, (int*)opinfo, opinfo[recv_len-1]); write(clnt_sock, (char*)\u0026result, sizeof(result)); close(clnt_sock); } close(serv_sock); return 0; } int calculate(int opnum, int opnds[], char op) { int result=opnds[0], i; switch(op) { case '+': for(i=1; i\u003copnum; i++) result+=opnds[i]; break; case '-': for(i=1; i\u003copnum; i++) result-=opnds[i]; break; case '*': for(i=1; i\u003copnum; i++) result*=opnds[i]; break; } return result; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:3","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"5.4 TCP原理 TCP套接字的数据收发无边界。实际上，write函数调用后并非立即传输数据，read函数调用后也非马上接收数据。更准确地说，write函数调用瞬间，数据将移至输出缓冲；read函数调用瞬间，从输入缓冲读取数据。 调用write函数时，数据将移动到输出缓冲，在适当的时候(不管是分别传送还是一次性传送)传向对方的输入缓冲。这时对方将调用read函数从输入缓冲读取数据。这些I/O缓冲特性可整理如下： I/O缓冲在每个TCP套接字中单独存在。 I/O缓冲在创建套接字时自动生成。 即使关闭套接字也会继续传递输入缓冲中遗留的数据。(调用close时) 关闭套接字将丢失缓冲中的数据。(调用close完成后) ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:4","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"6. 基于UDP的服务器端/客户端 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:6:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"7. 优雅地断开套接字连接 调用Linux的close函数意味着完全断开连接。完全断开不仅指无法传输数据，而且也不能接收数据。为了解决这类问题，“只关闭一部分数据交换中使用的流”(Half-close)的方法应运而生。断开一部分连接是指，可以传输数据但无法接收，或可以接收数据但无法传输。顾名思义就是只关闭流的一半。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"7.1 套接字和流(Stream) 两台主机通过套接字建立连接后进入可交换数据的状态，又称“流形成的状态”。也就是把建立套接字后可交换数据的状态看作一种流。 此处的流可以比作水流。水朝着一个方向流动，同样，在套接字的流中，数据也只能向一个方向移动。因此，为了进行双向通信，需要2个流。如下图所示： 一旦两台主机间建立了套接字连接，每个主机就会拥有单独的输入流和输出流。当然，其中一个主机的输入流与另一主机的输出流相连，而输出流则与另一主机的输入流相连。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:1","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"7.2 shutdown函数 #include \u003csys/socket.h\u003e int shutdown(int sock, int howto); 调用shutdown函数，成功时返回0，失败时返回-1。 sock：需要断开的套接字文件描述符。 howto：传递断开方式信息。 第二个参数(howto)参数决定断开连接的方式： SHUT_RD：断开输入流 SHUT_WR：断开输出流 SHUT_RDWR：同时断开I/O流。 若向shutdown的第二个参数传递SHUT_RD，则断开输入流，套接字无法接收数据。即使输入缓冲收到数据也会抹去，而且无法调用输入相关函数(read等)。 如果shutdown函数的第二个参数传递SHUT_WR，则中断输出流，也就无法传输数据(write等)。但如果输出缓冲还留有未传输的数据，则将传递至目标主机。 最后，若传入SHUT)RDWR，则同时中断I/O流(相当于调用close函数)。这相当于分2次调用shutdown，其中一次以SHUT_RD为参数，另一次以SHUT_WR为参数。 断开输出流时，会向对方主机传输EOF。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:2","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"7.3 基于半关闭的文件传输程序 file_server.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 30 void error_handling(char *message); int main(int argc, char *argv[]) { int serv_sd, clnt_sd; FILE * fp; char buf[BUF_SIZE]; int read_cnt; struct sockaddr_in serv_adr, clnt_adr; socklen_t clnt_adr_sz; if(argc!=2) { printf(\"Usage: %s \u003cport\u003e\\n\", argv[0]); exit(1); } //rb：以二进制方式读入 fp = fopen(\"file_server.c\", \"rb\"); serv_sd = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=htonl(INADDR_ANY); serv_adr.sin_port=htons(atoi(argv[1])); bind(serv_sd, (struct sockaddr*)\u0026serv_adr, sizeof(serv_adr)); listen(serv_sd, 5); clnt_adr_sz=sizeof(clnt_adr); clnt_sd=accept(serv_sd, (struct sockaddr*)\u0026clnt_adr, \u0026clnt_adr_sz); // while(1) // { // read_cnt=fread((void*)buf, 1, BUF_SIZE, fp); // if(read_cnt\u003cBUF_SIZE) // { // write(clnt_sd, buf, read_cnt); // break; // } // write(clnt_sd, buf, BUF_SIZE); // } //将fp文件描述符指向的文件数据发送给客户端(clnt_sd描述符) while(read_cnt = fread((void*)buf, 1, BUF_SIZE, fp)) { write(clnt_sd, buf, read_cnt); } //关闭输出流，及发送EOF。 shutdown(clnt_sd, SHUT_WR); //输入流仍然可以使用 read(clnt_sd, buf, BUF_SIZE); printf(\"Message from client: %s \\n\", buf); fclose(fp); close(clnt_sd); close(serv_sd); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } file_cilent.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 30 void error_handling(char *message); int main(int argc, char *argv[]) { int sd; FILE *fp; char buf[BUF_SIZE]; int read_cnt; struct sockaddr_in serv_adr; if(argc!=3) { printf(\"Usage: %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } //wb：是二进制方式写入 fp = fopen(\"./file/receive.dat\", \"wb\"); sd = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=inet_addr(argv[1]); serv_adr.sin_port=htons(atoi(argv[2])); connect(sd, (struct sockaddr*)\u0026serv_adr, sizeof(serv_adr)); //通过sd接收服务端发送的数据，并存放到buf中 while((read_cnt=read(sd, buf, BUF_SIZE ))!=0) { //把服务端接收的数据(buf)，流向fp文件描述符指定的文件receive.dat fwrite((void*)buf, 1, read_cnt, fp); } puts(\"Received file data\"); write(sd, \"Thank you\", 10); fclose(fp); close(sd); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:7:3","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"8. 域名及网络地址 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:8:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"9. 套接字的多种可选项 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:9:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"10. 多进程服务器端 可以同ps指令查看当前运行的所有进程：ps au ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"10.1 fork函数 通过fork函数创建进程： #include \u003cunistd.h\u003e pid_t fork(void); 调用fork函数，成功时返回进程ID，失败时返回-1。 fork函数将创建的进程副本，复制正在运行的、调用fork函数的进程。这两个进程都执行fork函数调用后的语句(fork函数返回后)。 利用fork函数的特点区别程序执行流程： 父进程：fork函数返回子进程ID。 子进程：fork函数返回0。 fork.c #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e int gval=10; int main(int argc, char *argv[]) { pid_t pid; int lval=20; gval++, lval+=5; pid=fork(); if(pid==0) // if Child Process gval+=2, lval+=2; else // if Parent Process gval-=2, lval-=2; if(pid==0) printf(\"Child Proc: [%d, %d] \\n\", gval, lval); else printf(\"Parent Proc: [%d, %d] \\n\", gval, lval); return 0; } ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:1","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"10.2 进程和僵尸进程 应该向创建子进程的而父进程传递子进程的exit参数值或return语句的返回值。 操作系统不会主动把这些值传递给父进程。只有父进程主动发起请求(函数调用)时，操作系统才会传递该值。换言之，如果父进程未主动要求获得子进程的结束值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态。也就是说，父进程要负责创建的子进程。 僵尸进程示例： zombie.c #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e int main(int argc, char *argv[]) { pid_t pid=fork(); if(pid==0) // if Child Process { puts(\"Hi I'am a child process\"); } else { printf(\"Child Process ID: %d \\n\", pid); sleep(30); // Sleep 30 sec. } if(pid==0) puts(\"End child process\"); else puts(\"End parent process\"); return 0; } 可以看到pid(6922)，就是僵尸进程。经过30秒的等待时间后，pid为6921的父进程和之前的僵尸进程同时销毁。 后台处理是指将控制台窗口的指令放到后台运行的方式，如：./zombie \u0026 cjt@DESKTOP-10IHDHO:~/c++/socket$ ps au USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND cjt 6921 0.0 0.0 10536 568 pts/1 S 18:20 0:00 ./zombie cjt 6922 0.0 0.0 0 0 pts/1 Z 18:20 0:00 [zombie] \u003cdefunct\u003e ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:2","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"10.3 wait函数 #include \u003csys/wait.h\u003e pid_t wait(int *statloc); 调用wait函数，成功时返回终止的子进程ID，失败时返回-1。 调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值(exit函数的参数值、main函数的return返回值)将保存到该函数的参数所指向内存空间。但函数参数指向的单元中还包括含其他信息，因此需要通过下列宏进行分离。 WIFEXITED进程正常终止时返回\"真\"(true)。 WEXITSTATUS返回子进程的返回值。 也就是说，向wait函数传递变量status的地址时，调用wait函数后应编写如下代码： //是否时正常终止的？ if(WIFEXITED(status)) { puts(\"Normal termination!\"); //打印进程终止的返回值 printf(\"Child pass num: %d\", WEXITSTATUS(status)); } wait.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003csys/wait.h\u003e int main(int argc, char *argv[]) { int status; pid_t pid = fork(); if (pid == 0) { //子线程的执行流程 return 3; } else { printf(\"Child1 PID: %d \\n\", pid); pid = fork(); if (pid == 0) { //子线程的执行流程 exit(7); } else { printf(\"Child2 PID: %d \\n\", pid); wait(\u0026status); if (WIFEXITED(status)) printf(\"Child send one: %d \\n\", WEXITSTATUS(status)); wait(\u0026status); if (WIFEXITED(status)) printf(\"Child send two: %d \\n\", WEXITSTATUS(status)); sleep(30); // Sleep 30 sec. } } return 0; } ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:10:3","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"11. 进程间通信 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:11:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"12. I/O复用 复用： 在1个通信频道中传递多个数据(信号)的技术。 为了提高物理设备的效率，用最少的物理要素传递最多数据时使用的技术。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:12:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"12.1 select函数 select函数的调用过程： 设置文件描述符 利用select函数可以同时监视多个文件描述符。当然，监视文件描述符可以视为监视套接字。首先需要将要监视的文件描述符集中到一起，按照监视项(接收、传输、异常)进行区分，将上述3种监视项分成3类。 使用fd_set数组变量执行此项操作，数组是存有0和1的位数组。 最左端的位表示文件描述符0(所在位置)。如果该位设置为1，则表示该文件描述符是监视对象。上图中，文件描述符1和3就是要监控的对象。 在fd_set变量中注册或更改值的操作都是由下列宏完成的： FD_ZERO(fd_set *fdest)：将fd_set变量的所有位初始化为0。 FD_SET(int fd, fd_set *fdset)：在参数fdset指向的变量中注册文件描述符fd的信息。 FD_CLR(int fd, fd_set *fdset)：从参数fdset指向的变量中清除文件描述符fd的信息。 FD_ISSET(int fd, fd_set *fdset)若参数fdset指向的变量中包含文件描述符fd的信息，则返回\"真\"。 #include \u003csys/select.h\u003e #include \u003csys/time.h\u003e int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); 调用select函数，成功时返回大于0的值，失败时返回-1。 maxfd：监视对象文件描述符数量。 readset：将所有关注 “是否存在待读取数据” 的文件描述符注册到fd_set型变量，并传递其地址值。 writeset：将所有关注 “是否可传输无阻塞数据” 的文件描述符注册到fd_set型变量，并传递其地址值。 exceptset：将所有关注 “是否发生异常” 的文件描述符注册到fd_set型变量，并传递其地址值。 timeout：调用select函数后，为防止陷入无限阻塞的状态，传递超时(time-out)信息。 返回值：发生错误时返回-1，超时返回时返回0。因发生关注的事件返回时，返回大于0的值，该值是发生事件的文件描述符数。 timeval结构体定义如下： struct timeval { long tv_sec; //seconds long tv_usec; //microseconds } 本例select函数只有在监视的文件描述符发生变化时才返回。如果未发生变化，就会进入阻塞状态。指定超时时间就是为了防止这种情况的发生。通过声明上述结构体变量，将秒数填入tv_sec成员，将毫秒数填入tv_usec成员，然后将结构体的地址值传递到select函数的最后一个参数。此时，即使文件秒师傅中未发生变化，只要过了指定时间，也可以从函数中返回。不过这种情况下，select函数返回0。因此，可以通过返回值了解返回原因。如果不想设置超时，则传递NULL作为参数。 select函数示例： select.c #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003csys/time.h\u003e #include \u003csys/select.h\u003e #define BUF_SIZE 30 int main(int argc, char *argv[]) { fd_set reads, temps; int result, str_len; char buf[BUF_SIZE]; struct timeval timeout; FD_ZERO(\u0026reads); FD_SET(0, \u0026reads); // 0 is standard input(console) /* timeout.tv_sec=5; timeout.tv_usec=5000; */ while(1) { temps = reads; timeout.tv_sec=5; timeout.tv_usec=0; //设置监听文件描述符0(标准输入)的可读事件，并设置超时时间 result = select(1, \u0026temps, 0, 0, \u0026timeout); if(result==-1) { puts(\"select() error!\"); break; } else if(result==0) { puts(\"Time-out!\"); } else { if(FD_ISSET(0, \u0026temps)) { //从标准输入流中去读数据，并打印 str_len = read(0, buf, BUF_SIZE); buf[str_len]=0; printf(\"message from console: %s\", buf); } } } return 0; } ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:12:1","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"12.2 基于select的I/O复用实例 echo_selectserv.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #include \u003csys/time.h\u003e #include \u003csys/select.h\u003e #define BUF_SIZE 100 void error_handling(char *buf); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; struct timeval timeout; fd_set reads, cpy_reads; socklen_t adr_sz; int fd_max, str_len, fd_num, i; char buf[BUF_SIZE]; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) error_handling(\"bind() error\"); if (listen(serv_sock, 5) == -1) error_handling(\"listen() error\"); FD_ZERO(\u0026reads); FD_SET(serv_sock, \u0026reads); fd_max = serv_sock; while (1) { cpy_reads = reads; timeout.tv_sec = 5; timeout.tv_usec = 5000; //只监听了可读事件 if ((fd_num = select(fd_max + 1, \u0026cpy_reads, 0, 0, \u0026timeout)) == -1) break; //超时未得到可读事件 if (fd_num == 0) continue; //需要进一步优化 for (i = 0; i \u003c fd_max + 1; i++) { if (FD_ISSET(i, \u0026cpy_reads)) { //发生建立连接的事件 if (i == serv_sock) // connection request! { adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026adr_sz); FD_SET(clnt_sock, \u0026reads); if (fd_max \u003c clnt_sock) fd_max = clnt_sock; printf(\"connected client: %d \\n\", clnt_sock); } //可读事件 else // read message! { str_len = read(i, buf, BUF_SIZE); if (str_len == 0) // close request! { FD_CLR(i, \u0026reads); close(i); printf(\"closed client: %d \\n\", i); } else { write(i, buf, str_len); // echo! } } } } } close(serv_sock); return 0; } void error_handling(char *buf) { fputs(buf, stderr); fputc('\\n', stderr); exit(1); } echo.server.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 1024 void error_handling(char *message); int main(int argc, char *argv[]) { int sock; char message[BUF_SIZE]; int str_len; struct sockaddr_in serv_adr; if(argc!=3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } sock=socket(PF_INET, SOCK_STREAM, 0); if(sock==-1) error_handling(\"socket() error\"); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=inet_addr(argv[1]); serv_adr.sin_port=htons(atoi(argv[2])); if(connect(sock, (struct sockaddr*)\u0026serv_adr, sizeof(serv_adr))==-1) error_handling(\"connect() error!\"); else puts(\"Connected...........\"); while(1) { fputs(\"Input message(Q to quit): \", stdout); fgets(message, BUF_SIZE, stdin); if(!strcmp(message,\"q\\n\") || !strcmp(message,\"Q\\n\")) break; write(sock, message, strlen(message)); str_len=read(sock, message, BUF_SIZE-1); message[str_len]=0; printf(\"Message from server: %s\", message); } close(sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:12:2","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"13. 多种I/O函数 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:13:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"14. 多播与广播 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:14:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"15. 套接字和标准I/O 使用标准I/O函数时会得到额外的缓冲支持。创建套接字时，操作系统将生成用于套接字的缓冲。此缓冲在执行TCP协议时发挥着非常重要的作用。若此时使用标准I/O函数，将得到额外的另一缓冲的支持。 如上图，使用标准I/O函数传输数据时，经过2个缓冲。设置缓冲的主要目的是为了提高性能，但套接字中的缓冲主要是为了实现TCP协议而设立的。例如，TCP传输中丢失数据时将再次传递，而再次发生数据则保存在套接字的输出缓冲中。与之相反，使用标准I/O函数缓冲的主要目的是为了提高性能。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:15:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"15.1 标准I/O函数 创建套接字时返回文件描述符，而为了使用标准I/O函数，只能将其转换为FILE结构体指针。 #include \u003cstdio.h\u003e FILE *fdopen(int fildes, const char *mode); 调用fdopen函数，成功时返回转换的FILE结构体指针，失败时返回NULL。 fildes：需要转换的文件描述符。 mode：将要创建的FILE结构体指针的模式(mode)信息。 desto.c #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e //open函数的头文件 int main(void) { FILE *fp; int fd = open(\"./file/file.txt\", O_WRONLY | O_CREAT | O_TRUNC); if (fd == -1) { fputs(\"file open error\", stdout); return -1; } //将fd文件描述符转换为写模式的FILE指针 fp = fdopen(fd, \"w\"); fputs(\"Network C programming \\n\", fp); fclose(fp); return 0; } 也可以利用fileno函数将FILE指针转换为文件描述符 #include \u003cstdio.h\u003e int fileno(FILE *stream); 调用fileno函数，成功时返回转换后的文件描述符，失败时返回-1。 todes.c #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e int main(void) { FILE *fp; int fd = open(\"data.dat\", O_WRONLY | O_CREAT | O_TRUNC); if (fd == -1) { fputs(\"file open error\", stdout); return -1; } printf(\"First file descriptor: %d \\n\", fd); fp = fdopen(fd, \"w\"); fputs(\"TCP/IP SOCKET PROGRAMMING \\n\", fp); printf(\"Second file descriptor: %d \\n\", fileno(fp)); fclose(fp); return 0; } ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:15:1","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"15.2 基于套接字的标准I/O函数使用 标准I/O函数为了提高性能，内部提供额外的缓冲。因此，若不调用fflush函数则无法保证立即将数据传输到客户端。 echo_stdserv.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 1024 void error_handling(char *message); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; char message[BUF_SIZE]; int str_len, i; struct sockaddr_in serv_adr; struct sockaddr_in clnt_adr; socklen_t clnt_adr_sz; FILE * readfp; FILE * writefp; if(argc!=2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } serv_sock=socket(PF_INET, SOCK_STREAM, 0); if(serv_sock==-1) error_handling(\"socket() error\"); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=htonl(INADDR_ANY); serv_adr.sin_port=htons(atoi(argv[1])); if(bind(serv_sock, (struct sockaddr*)\u0026serv_adr, sizeof(serv_adr))==-1) error_handling(\"bind() error\"); if(listen(serv_sock, 5)==-1) error_handling(\"listen() error\"); clnt_adr_sz=sizeof(clnt_adr); for(i=0; i\u003c5; i++) { clnt_sock=accept(serv_sock, (struct sockaddr*)\u0026clnt_adr, \u0026clnt_adr_sz); if(clnt_sock==-1) error_handling(\"accept() error\"); else printf(\"Connected client %d \\n\", i+1); readfp=fdopen(clnt_sock, \"r\"); writefp=fdopen(clnt_sock, \"w\"); while(!feof(readfp)) { fgets(message, BUF_SIZE, readfp); fputs(message, writefp); fflush(writefp); } fclose(readfp); fclose(writefp); } close(serv_sock); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } echo_stdclnt.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 1024 void error_handling(char *message); int main(int argc, char *argv[]) { int sock; char message[BUF_SIZE]; int str_len; struct sockaddr_in serv_adr; FILE * readfp; FILE * writefp; if(argc!=3) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e\\n\", argv[0]); exit(1); } sock=socket(PF_INET, SOCK_STREAM, 0); if(sock==-1) error_handling(\"socket() error\"); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=inet_addr(argv[1]); serv_adr.sin_port=htons(atoi(argv[2])); if(connect(sock, (struct sockaddr*)\u0026serv_adr, sizeof(serv_adr))==-1) error_handling(\"connect() error!\"); else puts(\"Connected...........\"); readfp=fdopen(sock, \"r\"); writefp=fdopen(sock, \"w\"); while(1) { fputs(\"Input message(Q to quit): \", stdout); fgets(message, BUF_SIZE, stdin); if(!strcmp(message,\"q\\n\") || !strcmp(message,\"Q\\n\")) break; fputs(message, writefp); fflush(writefp); fgets(message, BUF_SIZE, readfp); printf(\"Message from server: %s\", message); } fclose(writefp); fclose(readfp); return 0; } void error_handling(char *message) { fputs(message, stderr); fputc('\\n', stderr); exit(1); } ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:15:2","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"16. 分离I/O流 前面已经介绍的基于文件描述符的分离流(shutdown函数)的目的： 通过分开输入过程(代码)和输出过程降低实现难度。 与输入无关的输出操作可以提高速度。 基于FILE指针的分离流的目的： 为了将FILE指针按读模式和写模式加以区分。 可以通过区分读写模式降低实现难度。 通过区分I/O缓冲提高缓冲性能。 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:16:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"16.1 文件描述符的复制和半关闭 sep_serv.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 1024 int main(int argc, char *argv[]) { int serv_sock, clnt_sock; FILE * readfp; FILE * writefp; struct sockaddr_in serv_adr, clnt_adr; socklen_t clnt_adr_sz; char buf[BUF_SIZE]={0,}; serv_sock=socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=htonl(INADDR_ANY); serv_adr.sin_port=htons(atoi(argv[1])); bind(serv_sock, (struct sockaddr*) \u0026serv_adr, sizeof(serv_adr)); listen(serv_sock, 5); clnt_adr_sz=sizeof(clnt_adr); clnt_sock=accept(serv_sock, (struct sockaddr*)\u0026clnt_adr,\u0026clnt_adr_sz); //通过同一文件描述符(clnt_sock)，创建读和写模式的FILE指针。 readfp=fdopen(clnt_sock, \"r\"); writefp=fdopen(clnt_sock, \"w\"); fputs(\"FROM SERVER: Hi~ client? \\n\", writefp); fputs(\"I love all of the world \\n\", writefp); fputs(\"You are awesome! \\n\", writefp); fflush(writefp);//通过fflush发生完写缓冲区的数据 fclose(writefp);//看着像是关闭写的流，其实不是 fgets(buf, sizeof(buf), readfp); fputs(buf, stdout); fclose(readfp);//看着像是关闭读的流，其实不是 return 0; } sep_clnt.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 1024 int main(int argc, char *argv[]) { int sock; char buf[BUF_SIZE]; struct sockaddr_in serv_addr; FILE * readfp; FILE * writefp; sock=socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family=AF_INET; serv_addr.sin_addr.s_addr=inet_addr(argv[1]); serv_addr.sin_port=htons(atoi(argv[2])); connect(sock, (struct sockaddr*)\u0026serv_addr, sizeof(serv_addr)); readfp=fdopen(sock, \"r\"); writefp=fdopen(sock, \"w\"); while(1) { if(fgets(buf, sizeof(buf), readfp)==NULL) break; fputs(buf, stdout); fflush(stdout); } fputs(\"FROM CLIENT: Thank you! \\n\", writefp); fflush(writefp); fclose(writefp); fclose(readfp); return 0; } 通过上述代码可以知道，调用fclose函数完全终止了套接字，而不是半关闭。 上述示例sep_serv.c中的读模式FILE指针和写模式FILE指针都是基于同一个文件描述符创建的。因此，针对任意一个FILE指针调用fclose函数时都会关闭文件描述符，也就是终止套接字。 可以通过复制创建另外一个文件描述符，然后利用各自的文件描述符生成读模式和写模式的FILE指针。如此套接字和文件描述符之间具有关系：销毁所有文件描述符后才能销毁套接字。 下面给出文件描述符的复制方法，通过下列2个函数之一完成： #include \u003cunistd.h\u003e int dup(int fildes); int dup2(int fildes, int fildes2); 调用上述任意一个函数，成功时返回复制的文件描述符，失败时返回-1。 fildes：需要复制的文件描述符。 fildes2：明确指定的文件描述符整数值。 dup2函数明确指定复制的文件描述符整数值。向其传递大于0且小于进程生成的最大文件描述符值时，该值将成为复制出的文件描述符值。 dup.c #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e int main(int argc, char *argv[]) { int cfd1, cfd2; char str1[]=\"Hi~ \\n\"; char str2[]=\"It's nice day~ \\n\"; cfd1=dup(1);//标准输出 cfd2=dup2(cfd1, 7); printf(\"fd1=%d, fd2=%d \\n\", cfd1, cfd2); write(cfd1, str1, sizeof(str1)); write(cfd2, str2, sizeof(str2)); close(cfd1); close(cfd2); //继续向标准输出流写数据 write(1, str1, sizeof(str1)); close(1);//关闭，此时已经关闭所有的标准输出流的套接字了 //关闭后，继续向标准输入流中写数据，不起效果了 write(1, str2, sizeof(str2)); return 0; } 复制文件描述符后\"流\"的分离，修改sep_serv.c。 sep_serv2.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #define BUF_SIZE 1024 int main(int argc, char *argv[]) { int serv_sock, clnt_sock; FILE * readfp; FILE * writefp; struct sockaddr_in serv_adr, clnt_adr; socklen_t clnt_adr_sz; char buf[BUF_SIZE]={0,}; serv_sock=socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family=AF_INET; serv_adr.sin_addr.s_addr=htonl(INADDR_ANY); serv_adr.sin_port=htons(atoi(argv[1])); bind(serv_sock, (struct sockaddr*) \u0026serv_adr, sizeof(serv_adr)); listen(serv_sock, 5); clnt_adr_sz=sizeof(clnt_adr); clnt_sock=accept(serv_sock, (struct sockaddr*)\u0026clnt_adr,\u0026clnt_adr_sz); readfp=fdopen(clnt_sock, \"r\"); writefp=fdopen(dup(clnt_sock), \"w\"); fputs(\"FROM SERVER: Hi~ client? \\n\", writefp); fputs(\"I love all of the world \\n\", writefp); fputs(\"You are awesome! \\n\", writefp); fflush(writefp); //针对fileno函数返回的文件描述符调用shutdown函数，服务器端进入半关闭状态，并向客户端发送EOF。 shutdown(fileno(writefp), SHUT_WR); /** * 针对上述操作，调用close函数EOF不能成功发送到客户端。 * 原因：销毁所有文件描述符后才能销毁套接字；","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:16:1","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"17. 优于select的epoll ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:17:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"17.1 实现epoll时必要的函数和结构体 epoll_create：创建保存epoll文件描述符的空间。 epoll_ctl：向空间注册并注销文件描述符。 epoll_wait：与select函数类似，等待文件描述符发送变化。 epoll_create函数： #include \u003csys/epoll.h\u003e int epoll_create(int size); 调用epoll_create函数，成功时返回epoll文件描述符，失败返回-1。 size：epoll实例的大小。 调用epoll_create函数时创建的文件描述符保存空间称为\"epoll例程\"。通过参数size传递的值决定epoll例程的大小，但该值只是向操作系统提的建议。换言之，size并非用来决定epoll例程的大小，而仅供操作系统参考。 epoll_create函数创建的资源与套接字相同，也由操作系统管理。因此，该函数和创建套接字的情况相同，也会返回文件描述符。也就是说，该函数返回的文件描述符主要与于区别epoll例程。需要终止时，与其他文件描述符相同，也要调用close函数。 epoll_ctl函数： 生成epoll例程后，应在其内部注册监视对象文件描述符，此时使用epoll_ctl函数。 #include \u003csys/epoll.h\u003e int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 调用epoll_ctl函数，成功时返回0，失败返回-1。 epfd：用于注册监视器对象的epoll例程的文件描述符。 op：用于指定监视对象的添加、删除或更改等操作。 fd：需要注册的监视对象文件描述符。 event：监视对象的事件类型。 epoll_ctl函数，第二个参数op传递的常量及含义： EPOLL_CTL_ADD：将文件描述符注册到epoll例程。 EPOLL_CTL_DEL：从epoll例程中删除文件描述符。 EPOLL_CTL_MOD：更改注册的文件描述符的关注事件发生情况。 epoll_event的成员events中可以保存的常量及所指的事件类型： EPOLLIN：需要读取数据的情况。 EPOLLOUT：输出缓冲为空，可以立即发送数据的情况。 EPOLLPRI：收到OOB数据的情况 EPOLLRDHUP：断开连接或半关闭的情况，这在边缘触发方式下非常有用。 EPOLLERR：发送错误的情况。 EPOLLET：以边缘触发的方式得到事件通知。 EPOLLONESHOT：发生一次事件后，相关文件描述符不再收到事件通知。因此需要向epoll_ctl函数的第二个参数传递EPOLL_CTL_MOD，再次设置事件。 epoll通过结构体epoll_event将发送变化的(发生事件的)文件描述符单独集中到一起。 struct epoll_event { __uint32_t events; epoll_data_t data; } typedef union epoll_data { void *ptr; int fd; __uint32_t u32; __uint64_t u64; } epoll_data_t; 声明足够大的epoll_event结构体数组后，传递给epoll_wait函数时，发生变化的文件描述符信息将被填入该数组。 epoll_wait函数： #include \u003csys/epoll.h\u003e int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 调用epoll_wait函数，成功时返回发生事件的文件描述符数量，失败时返回-1。 epfd：表示事件发生监视范围的epoll例程的文件描述符。 events：保存发生事件的文件描述符集合的结构体地址值。 maxevents：第二个参数中可以保存的最大事件数。 timeout：以1/1000秒为单位的等待时间，传递-1时，一直等待直到发生事件。 基于epoll的回声服务器端： echo_epollserv.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #include \u003csys/epoll.h\u003e #define BUF_SIZE 100 #define EPOLL_SIZE 50 void error_handling(char *buf); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; socklen_t adr_sz; int str_len, i; char buf[BUF_SIZE]; struct epoll_event *ep_events; struct epoll_event event; int epfd, event_cnt; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) error_handling(\"bind() error\"); if (listen(serv_sock, 5) == -1) error_handling(\"listen() error\"); //创建epoll例程 epfd = epoll_create(EPOLL_SIZE); //监听的事件个数 ep_events = malloc(sizeof(struct epoll_event) * EPOLL_SIZE); //注册serv_sock的可读事件(建立连接的请求) event.events = EPOLLIN; event.data.fd = serv_sock; epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, \u0026event); while (1) { //一直等待直到发生事件才返回 event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, -1); if (event_cnt == -1) { puts(\"epoll_wait() error\"); break; } //处理发生的事件 for (i = 0; i \u003c event_cnt; i++) { //建立连接事件 if (ep_events[i].data.fd == serv_sock) { adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026adr_sz); //注册刚建立连接的客户端的可读事件 event.events = EPOLLIN; event.data.fd = clnt_sock; epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, \u0026event); printf(\"connected client: %d \\n\", clnt_sock); } //客户端(clnt_sock)的可读事件 else { str_len = read(ep_events[i].data.fd, buf, BUF_SIZE); if (str_len == 0) // close request! { //将clnt_sock从epoll例程中移除 epoll_ctl( epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, NULL); close(ep_events[i].data.fd); printf(\"closed client: %d \\n\", ep_events[i].data.fd); } else { write(ep_events[i].data.fd, buf, str_len); // echo! } } } } //移除serv_sock，没必要 epoll_ctl(epfd, EPOLL_CTL_DEL, serv_sock, NULL); close(serv_sock); close(epfd); return 0; } void error_handling(char *buf) { fputs(buf, stderr); fputc('\\n', stderr); exit(1); } 客户端继续使用之前的。 echo_client.c #include \u003cstdio.h\u003e #include \u003cstd","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:17:1","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"17.2 条件触发和边缘触发 假设监听的是某个文件描述符的可读事件，在条件触发方式中，只要输入缓冲中还剩有数据，就将以事件方式再次注册；而在边缘触发中输入缓冲收到到数据时仅注册1次该事件，即使输入缓冲中还留由数据，也不会再进行注册。 epoll默认以条件触发方式工作。 条件触发方式工作： echo_EPLTserv.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003cfcntl.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #include \u003csys/epoll.h\u003e #define BUF_SIZE 4 #define EPOLL_SIZE 50 void error_handling(char *buf); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; socklen_t adr_sz; int str_len, i; char buf[BUF_SIZE]; struct epoll_event *ep_events; struct epoll_event event; int epfd, event_cnt; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) error_handling(\"bind() error\"); if (listen(serv_sock, 5) == -1) error_handling(\"listen() error\"); epfd = epoll_create(EPOLL_SIZE); ep_events = malloc(sizeof(struct epoll_event) * EPOLL_SIZE); event.events = EPOLLIN; //默认条件触发 event.data.fd = serv_sock; epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, \u0026event); while (1) { event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, -1); if (event_cnt == -1) { puts(\"epoll_wait() error\"); break; } puts(\"return epoll_wait\"); for (i = 0; i \u003c event_cnt; i++) { if (ep_events[i].data.fd == serv_sock) { adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026adr_sz); event.events = EPOLLIN; event.data.fd = clnt_sock; epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, \u0026event); printf(\"connected client: %d \\n\", clnt_sock); } else { /** * 减小缓冲大小，阻止一次性读取接收的数据； * 这个就不会一次性把读缓冲区的数据处理完 */ str_len = read(ep_events[i].data.fd, buf, BUF_SIZE); if (str_len == 0) // close request! { epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, NULL); close(ep_events[i].data.fd); printf(\"closed client: %d \\n\", ep_events[i].data.fd); } else { write(ep_events[i].data.fd, buf, str_len); // echo! } } } } close(serv_sock); close(epfd); free(ep_events); return 0; } void error_handling(char *buf) { fputs(buf, stderr); fputc('\\n', stderr); exit(1); } 边缘触发方式工作： echo_EPETserv.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003cfcntl.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #include \u003csys/epoll.h\u003e #define BUF_SIZE 4 #define EPOLL_SIZE 50 void error_handling(char *buf); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; socklen_t adr_sz; int str_len, i; char buf[BUF_SIZE]; struct epoll_event *ep_events; struct epoll_event event; int epfd, event_cnt; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) error_handling(\"bind() error\"); if (listen(serv_sock, 5) == -1) error_handling(\"listen() error\"); epfd = epoll_create(EPOLL_SIZE); ep_events = malloc(sizeof(struct epoll_event) * EPOLL_SIZE); event.events = EPOLLIN; //默认条件触发 event.data.fd = serv_sock; epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, \u0026event); while (1) { event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, -1); if (event_cnt == -1) { puts(\"epoll_wait() error\"); break; } puts(\"return epoll_wait\"); for (i = 0; i \u003c event_cnt; i++) { if (ep_events[i].data.fd == serv_sock) { adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026adr_sz); event.events = EPOLLIN | EPOLLET; //设置客户端为边缘触发 event.data.fd = clnt_sock; epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, \u0026event); printf(\"connected client: %d \\n\", clnt_sock); } else { /** * 减小缓冲大小，阻止一次性读取接收的数据； * 这个就不会一次性把读缓冲区的数据处理完 */ str_len = read(ep_even","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:17:2","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"17.3 基于边缘触发的回声服务器端 实现边缘触发的必知内容： 通过errno变量验证错误原因。 为了完成非阻塞(Non-blocking)I/O，更改套接字特性。 Linux的套接字相关函数一般公共返回-1通知发生了错误。虽然知道发生了错误，但仅凭这些内容无法得知产生错误的原因。因此，为了在发生错误时提供额外的信息，Linux声明了一个全局变量：int errno; 为了访问该变量，需要引用error.h头文件，因为此头文件中有变量extern的声明。每种函数发生错误时，保存到errno变量中的值都不同。如： “read函数发现输入缓冲中没有数据可读时，返回-1，同时在errno中保存EAGAIN变量。” Linux提供更改或读取文件属性的方法： #include \u003cfcntl.h\u003e int fcntl(int filedes, int cmd, ...); 调用fcntl函数，成功时返回cmd参数相关值，失败返回-1。 filedes：属性更改目标的文件描述符。 cmd：表示函数调用的目的。 从上述声明中可以看到，fcntl具有可变参数的新式。如果向第二个参数传递F_GETFL，可以获得第一个参数所指向的文件描述符属性(int类型)。反之，如果传递F_SETFL，可以更改文件描述符属性。如下，将文件(套接字)改成非阻塞模式： int flag = fcntl(fd, F_GETFL, 0); //获取之前设置的属性信息 fcntl(fd, F_SETFL, flag | O_NONBLCOK); //在原有的属性(flag)的基础上加上非阻塞(O_NONBLCOK)标记 实现边缘触发的回声服务器端： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003cfcntl.h\u003e #include \u003cerrno.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #include \u003csys/epoll.h\u003e #define BUF_SIZE 4 //为了验证边缘触发的工作方式，将缓冲区设置小一点 #define EPOLL_SIZE 50 void setnonblockingmode(int fd); void error_handling(char *buf); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; socklen_t adr_sz; int str_len, i; char buf[BUF_SIZE]; struct epoll_event *ep_events; struct epoll_event event; int epfd, event_cnt; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) error_handling(\"bind() error\"); if (listen(serv_sock, 5) == -1) error_handling(\"listen() error\"); epfd = epoll_create(EPOLL_SIZE); ep_events = malloc(sizeof(struct epoll_event) * EPOLL_SIZE); setnonblockingmode(serv_sock); event.events = EPOLLIN; event.data.fd = serv_sock; epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, \u0026event); while (1) { event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, -1); if (event_cnt == -1) { puts(\"epoll_wait() error\"); break; } puts(\"return epoll_wait\"); for (i = 0; i \u003c event_cnt; i++) { if (ep_events[i].data.fd == serv_sock) { adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026adr_sz); setnonblockingmode(clnt_sock); //将客户端描述符(clnt_sock)设置为非阻塞 event.events = EPOLLIN | EPOLLET;//设置为可读的边缘触发方式 event.data.fd = clnt_sock; epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sock, \u0026event); printf(\"connected client: %d \\n\", clnt_sock); } else { //每次触发边缘可读事件，都发客户端描述符(clnt_sock)中缓冲区的数据读完(read() \u003c 0) while (1) { str_len = read(ep_events[i].data.fd, buf, BUF_SIZE); if (str_len == 0) // close request! { epoll_ctl(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, NULL); close(ep_events[i].data.fd); printf(\"closed client: %d \\n\", ep_events[i].data.fd); break; } else if (str_len \u003c 0) { //read函数返回-1，变量errno中的值为EAGAIN时，说明没有数据可读。 if (errno == EAGAIN) break; } else { write(ep_events[i].data.fd, buf, str_len); // echo! } } } } } close(serv_sock); close(epfd); return 0; } void setnonblockingmode(int fd) { int flag = fcntl(fd, F_GETFL, 0); fcntl(fd, F_SETFL, flag | O_NONBLOCK); } void error_handling(char *buf) { fputs(buf, stderr); fputc('\\n', stderr); exit(1); } 边缘触发方式可以做到：“可以分离接收数据和处理数据的时间点！” ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:17:3","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"18. 多线程服务器端的实现 ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:18:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"18.1 线程的创建即运行 pthread_create函数： #include \u003cpthread.h\u003e int pthread_create( pthread_t * restrict thread, const pthread_attr_t * restrict attr, void * (* start_routine)(void *), void * restrict arg ); 调用pthread_create函数，成功时返回0，失败时返回其他值。 thread：保存新创建线程ID的变量地址值。线程与进程相同，也需要用于区别不同线程的ID。 attr：用于传递进程属性的参数，传递NULL时，创建默认属性的线程。 start_routine：先当与线程main函数的、在单独执行流中执行的函数地址值(函数指针)。 arg：通过第三个参数传递调用函数时包含传递参数信息的变量地址值。 简单示例： thread1.c #include \u003cstdio.h\u003e #include \u003cpthread.h\u003e void *thread_main(void *arg); int main(int argc, char *argv[]) { pthread_t t_id; int thread_param = 5; if (pthread_create(\u0026t_id, NULL, thread_main, (void *)\u0026thread_param) != 0) { puts(\"pthread_create() error\"); return -1; }; sleep(10); puts(\"end of main\"); return 0; } void *thread_main(void *arg) { int i; int cnt = *((int *)arg); for (i = 0; i \u003c cnt; i++) { sleep(1); puts(\"running thread\"); } return NULL; } 由于pthread库不是标准linux库，所有线程线管代码在编译时需要添加-lpthread选项声明需要连接线程库，只有这样才能调用头文件pthread.h中声明的函数。 pthread_join函数： 可以通过调用pthread函数，调用函数的进程(或线程)将进入等待状态，知道第一个参数为ID的线程终止为止。 #include \u003cpthread.h\u003e int pthread_join(pthread_t thread, void **status); 调用pthread_join函数，成功时返回0，失败时返回其他值。 thread：该参数值ID的线程终止后才会从该函数返回。 status：保存线程的main函数返回值的指针变量地址值。 thread2.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cpthread.h\u003e void* thread_main(void *arg); int main(int argc, char *argv[]) { pthread_t t_id; int thread_param=5; void * thr_ret; if(pthread_create(\u0026t_id, NULL, thread_main, (void*)\u0026thread_param)!=0) { puts(\"pthread_create() error\"); return -1; }; //thr_ret保存的是线程函数thread_main的返回值 if(pthread_join(t_id, \u0026thr_ret)!=0) { puts(\"pthread_join() error\"); return -1; }; printf(\"Thread return message: %s \\n\", (char*)thr_ret); free(thr_ret); return 0; } void* thread_main(void *arg) { int i; int cnt=*((int*)arg); char * msg=(char *)malloc(sizeof(char)*50); strcpy(msg, \"Hello, I'am thread~ \\n\"); for(i=0; i\u003ccnt; i++) { sleep(1); puts(\"running thread\"); } return (void*)msg; } ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:18:1","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"18.2 线程同步 需要同步的情况可以从如下两个方面考虑： 同时访问同一内存空间时发生的情况。 需要指定访问同一内存空间的线程执行顺序的情况。 互斥量： 同时访问的线程同步。 #include \u003cpthread.h\u003e int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); 调用上面两个函数，成功时返回0，失败时返回其他值。 mutex：创建互斥量时传递保护互斥量的变量地址值，销毁时传递需要销毁的互斥量地址值。 attr：传递即将创建的互斥量属性，没有特别需要指定的属性时传递NULL。 从上述函数声明中可以看出，为了创建相当于锁系统的互斥量，需要声明pthread_mutex_t型变量：pthread_mutex_t mutex; 该变量的地址将传递给pthread_mutex_init函数，用来保存操作系统创建的互斥量(锁系统)。调用pthread_mutex_destroy函数时同样需要该信息。如果不需要配置特殊的互斥量属性，则向第二个参数传递NULL时，可以利用PTHREAD_MUTEX_INITLALIZER宏进行声明：pthread_mutex_t mutex = PTHREAD_MUTEX_INITLALIZER; 推荐使用pthread_mutex_init函数进行初始化，因为通过宏进行初始化时很难发现发生的错误。 #include \u003cpthread.h\u003e int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); 调用上面两个函数，成功时返回0，失败时返回其他值。 进入临界区前调用的函数就是pthread_mutex_lock。调用该函数时，发现其他线程进入临界区，则pthread_mutex_lock函数不会返回，直到里面的线程调用pthread_mutex_unlock函数退出临界区为止。 创建好互斥量的前提下，可以通过如下结构保护临界区： pthread_mutex_lock(\u0026mutex); //临界区的开始 //...... //临界区的结束 pthread_mutex_unlock(\u0026mutex); 如果未能即使的调用pthread_mutex_unlock函数，那么其他为了进入临界区而调用pthread_mutex_lock函数的线程就无法摆脱阻塞状态。这种情况称为\"死锁\"(Dead-lock)。 mutex.c #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e #include \u003cpthread.h\u003e #define NUM_THREAD 100 void *thread_inc(void *arg); void *thread_des(void *arg); long long num = 0; pthread_mutex_t mutex;//互斥量 int main(int argc, char *argv[]) { //创建NUM_THREAD个线程id pthread_t thread_id[NUM_THREAD]; int i; //初始化互斥量(mutex) pthread_mutex_init(\u0026mutex, NULL); for (i = 0; i \u003c NUM_THREAD; i++) { if (i % 2) pthread_create(\u0026(thread_id[i]), NULL, thread_inc, NULL); else pthread_create(\u0026(thread_id[i]), NULL, thread_des, NULL); } for (i = 0; i \u003c NUM_THREAD; i++) pthread_join(thread_id[i], NULL); printf(\"result: %lld \\n\", num); pthread_mutex_destroy(\u0026mutex); return 0; } void *thread_inc(void *arg) { pthread_mutex_lock(\u0026mutex); for (int i = 0; i \u003c 50000000; i++) { num += 1; } pthread_mutex_unlock(\u0026mutex); return NULL; } void *thread_des(void *arg) { pthread_mutex_lock(\u0026mutex); for (int i = 0; i \u003c 50000000; i++) { num -= 1; } pthread_mutex_unlock(\u0026mutex); return NULL; } 互斥量lock、unlock函数的调用过程要比想象中花费更长时间。最大限度减少互斥量lock、unlock函数的调用次数。 信号量： 控制顺序的线程同步。 #include \u003csemaphore.h\u003e int sem_init(sem_t *sem, int pshared, unsigned int value); int sem_destroy(sem_t *sem); 调用上面两个函数，成功时返回0，失败时返回其他值。 sem：创建信号量时传递保存信号量的变量地址值，销毁时传递需要销毁的信号量变量地址值。 pshared：传递其他值时，创建可由多个进程共享的信号量；传递0时，创建只允许1个进程内部使用的信号量。我们需要完成同一进程内的线程同步，故传递0。 value：指定新创建的信号量初始值。 #include \u003csemaphore.h\u003e int sem_post(sem_t *sem); int sem_wait(sem_t *sem); 调用上面两个函数时，成功返回0，失败时返回其他值。 sem：传递保存信号量读取值的变量地址值，传递给sem_post时信号量增1，传递给sem_wait时信号量减1。 调用sem_init函数时，操作系统将创建信号量对象，此对象中记录着\"信号量值\"(Semaphore Value)整数。该值在调用sem_post函数时曾1，调用sem_wait函数时减1。但信号量的值不能小于0，因此，在信号量为0的情况下调用sem_wait函数时，调用函数的线程将进入阻塞状态(因为函数未返回)。当然，此时如果有其他线程调用sem_post函数，信号量的值将变为1，而原本阻塞的线程可以将该信号量重新减为0并跳出阻塞状态。 sem_wait(\u0026sem); //信号量变为0... //临界区的开始 //.... //临界区的结束 sem_post(\u0026sem); //信号量变为1... 示例场景如下： “线程A从用户输入得到值后存入全局变量num，此时线程B将取走该值并累加。该过程共进行5次，完成后输出总和并退出程序。” semaphore.c #include \u003cstdio.h\u003e #include \u003cpthread.h\u003e #include \u003csemaphore.h\u003e void * read(void * arg); void * accu(void * arg); static sem_t sem_put; static sem_t sem_get; static int num; int main(int argc, char *argv[]) { pthread_t id_t1, id_t2; sem_init(\u0026sem_put, 0, 0); sem_init(\u0026sem_get, 0, 1); pthread_create(\u0026id_t1, NULL, read, NULL); pthread_create(\u0026id_t2, NULL, accu, NULL); pthread_join(id_t1, NULL); pthread_join(id_t2, NULL); sem_destroy(\u0026sem_put); sem_destroy(\u0026sem_get); return 0; } void * read(void * arg) { int i; for(i=0; i\u003c5; i++) { fputs(\"Input num: \", stdout); sem_wait(\u0026sem_get); //减1 scanf(\"%d\", \u0026num); sem_post(\u0026sem_put); //加1 } return NULL; } void * accu(void * arg) { int sum=0, i; for(i=0; i\u003c5; i++) { sem_wait(\u0026sem_put);//减1 sum+=num; sem_post(\u0026sem_get);//加1 } printf(\"Result: %d \\n\", sum); return NULL; } ","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:18:2","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"18.3 线程的销毁和多线程并发服务器端的实现 通常通过如下函数进行引导线程销毁： #include \u003cpthread.h\u003e int pthread_detach(pthread_t thread); 调用pthread_detach函数，成功时返回0，失败时返回其他值。 thread：终止的同时需要销毁的线程ID。 调用pthread_detach函数不会引起线程终止或进入阻塞状态，可以通过该函数引导销毁线程创建的内存空间。调用该函数后，不能再针对相应线程调用pthread_join函数 将线程的状态设置为detached，则该线程运行结束后会自动释放所有资源。 多线程并发的实现： chat_server.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #include \u003cpthread.h\u003e #define BUF_SIZE 100 #define MAX_CLNT 256 void *handle_clnt(void *arg); void send_msg(char *msg, int len, int clnt_sock); void error_handling(char *msg); int clnt_cnt = 0; int clnt_socks[MAX_CLNT]; pthread_mutex_t mutx; int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; int clnt_adr_sz; pthread_t t_id; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } pthread_mutex_init(\u0026mutx, NULL); serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) error_handling(\"bind() error\"); if (listen(serv_sock, 5) == -1) error_handling(\"listen() error\"); while (1) { clnt_adr_sz = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026clnt_adr_sz); //保存clnt_sock pthread_mutex_lock(\u0026mutx); clnt_socks[clnt_cnt++] = clnt_sock; pthread_mutex_unlock(\u0026mutx); pthread_create(\u0026t_id, NULL, handle_clnt, (void *)\u0026clnt_sock); pthread_detach(t_id); printf(\"Connected client IP: %s \\n\", inet_ntoa(clnt_adr.sin_addr)); } close(serv_sock); return 0; } void *handle_clnt(void *arg) { int clnt_sock = *((int *)arg); int str_len = 0, i; char msg[BUF_SIZE]; while ((str_len = read(clnt_sock, msg, sizeof(msg))) != 0) send_msg(msg, str_len, clnt_sock); pthread_mutex_lock(\u0026mutx); for (i = 0; i \u003c clnt_cnt; i++) // remove disconnected client { if (clnt_sock == clnt_socks[i]) { while (i++ \u003c clnt_cnt - 1) clnt_socks[i] = clnt_socks[i + 1]; break; } } clnt_cnt--; pthread_mutex_unlock(\u0026mutx); close(clnt_sock); return NULL; } void send_msg(char *msg, int len, int clnt_sock) // send to all { int i; pthread_mutex_lock(\u0026mutx); for (i = 0; i \u003c clnt_cnt; i++) { if(clnt_socks[i] != clnt_sock) { write(clnt_socks[i], msg, len); } } pthread_mutex_unlock(\u0026mutx); } void error_handling(char *msg) { fputs(msg, stderr); fputc('\\n', stderr); exit(1); } chat_clnt.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #include \u003cpthread.h\u003e #define BUF_SIZE 100 #define NAME_SIZE 20 void *send_msg(void *arg); void *recv_msg(void *arg); void error_handling(char *msg); char name[NAME_SIZE] = \"[DEFAULT]\"; char msg[BUF_SIZE]; int main(int argc, char *argv[]) { int sock; struct sockaddr_in serv_addr; pthread_t snd_thread, rcv_thread; void *thread_return; if (argc != 4) { printf(\"Usage : %s \u003cIP\u003e \u003cport\u003e \u003cname\u003e\\n\", argv[0]); exit(1); } sprintf(name, \"[%s]\", argv[3]); sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = inet_addr(argv[1]); serv_addr.sin_port = htons(atoi(argv[2])); if (connect(sock, (struct sockaddr *)\u0026serv_addr, sizeof(serv_addr)) == -1) error_handling(\"connect() error\"); //开启两个线程，一个用于读数据，一个用于写数据 pthread_create(\u0026snd_thread, NULL, send_msg, (void *)\u0026sock); pthread_create(\u0026rcv_thread, NULL, recv_msg, (void *)\u0026sock); pthread_join(snd_thread, \u0026thread_return); pthread_join(rcv_thread, \u0026thread_return); close(sock); return 0; } void *send_msg(void *arg) // send thread main { int sock = *((int *)arg); char name_msg[NAME_SIZE + BUF_SIZE]; while (1) { fgets(msg, BUF_SIZE, stdin); if (!strcmp(msg, \"q\\n\") || !strcmp(msg, \"Q\\n\")) { close(sock); exit(0); } sprintf(name_msg, \"%s：%s\", name, msg); write(sock, name_msg, strlen(name_msg)); } return NULL; } void *recv_msg(vo","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:18:3","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["网络编程"],"content":"19. 制作HTTP服务器端 请求消息的结构： 请求信息： GET /index.html HTTP/1.1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cache-Control: max-age=0 Connection: keep-alive DNT: 1 Host: localhost:8088 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 sec-ch-ua: \"Chromium\";v=\"106\", \"Google Chrome\";v=\"106\", \"Not;A=Brand\";v=\"99\" sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \"Windows\" 响应消息的结构： 响应信息： HTTP/1.1 200 OK Server:Linux Web Server Content-length:2048 Content-type:text/html 一个简单的HTTP服务器： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #include \u003cpthread.h\u003e #define BUF_SIZE 1024 #define SMALL_BUF 100 void *request_handler(void *arg); void send_data(FILE *fp, char *ct, char *file_name); char *content_type(char *file); void send_error(FILE *fp); void error_handling(char *message); int main(int argc, char *argv[]) { int serv_sock, clnt_sock; struct sockaddr_in serv_adr, clnt_adr; int clnt_adr_size; char buf[BUF_SIZE]; pthread_t t_id; if (argc != 2) { printf(\"Usage : %s \u003cport\u003e\\n\", argv[0]); exit(1); } serv_sock = socket(PF_INET, SOCK_STREAM, 0); memset(\u0026serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); if (bind(serv_sock, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) == -1) error_handling(\"bind() error\"); if (listen(serv_sock, 20) == -1) error_handling(\"listen() error\"); while (1) { clnt_adr_size = sizeof(clnt_adr); clnt_sock = accept(serv_sock, (struct sockaddr *)\u0026clnt_adr, \u0026clnt_adr_size); printf(\"Connection Request : %s:%d\\n\", inet_ntoa(clnt_adr.sin_addr), ntohs(clnt_adr.sin_port)); pthread_create(\u0026t_id, NULL, request_handler, \u0026clnt_sock); pthread_detach(t_id); } close(serv_sock); return 0; } void *request_handler(void *arg) { int clnt_sock = *((int *)arg); char req_line[SMALL_BUF] = {0}; FILE *clnt_read; FILE *clnt_write; char method[10]; char ct[15]; char file_name[30]; clnt_read = fdopen(clnt_sock, \"r\"); clnt_write = fdopen(dup(clnt_sock), \"w\"); fgets(req_line, SMALL_BUF, clnt_read); //会阻塞 if (strstr(req_line, \"HTTP/\") == NULL) { printf(\"1111\\n\"); send_error(clnt_write); fclose(clnt_read); fclose(clnt_write); return; } printf(\"%s\", req_line); strcpy(method, strtok(req_line, \" /\")); strcpy(file_name, strtok(NULL, \" /\")); strcpy(ct, content_type(file_name)); if (strcmp(method, \"GET\") != 0) { send_error(clnt_write); fclose(clnt_read); fclose(clnt_write); return; } fclose(clnt_read); send_data(clnt_write, ct, file_name); } void send_data(FILE *fp, char *ct, char *file_name) { char protocol[] = \"HTTP/1.1 200 OK\\r\\n\"; char server[] = \"Server:Linux Web Server \\r\\n\"; char cnt_len[] = \"Content-length:2048\\r\\n\"; char cnt_type[SMALL_BUF]; char buf[BUF_SIZE]; FILE *send_file; sprintf(cnt_type, \"Content-type:%s\\r\\n\\r\\n\", ct); send_file = fopen(file_name, \"r\"); if (send_file == NULL) { send_error(fp); return; } //发送状态行、消息头和空行 fputs(protocol, fp); fputs(server, fp); fputs(cnt_len, fp); fputs(cnt_type, fp); //发送消息体(index.html) while (fgets(buf, BUF_SIZE, send_file) != NULL) { fputs(buf, fp); fflush(fp); } fflush(fp); fclose(fp); } //确认要发送的文件格式 char *content_type(char *file) { char extension[SMALL_BUF]; char file_name[SMALL_BUF]; strcpy(file_name, file); strtok(file_name, \".\"); strcpy(extension, strtok(NULL, \".\")); if (!strcmp(extension, \"html\") || !strcmp(extension, \"htm\")) return \"text/html\"; else return \"text/plain\"; } //错误页面 void send_error(FILE *fp) { char protocol[] = \"HTTP/1.1 400 Bad Request\\r\\n\"; char server[] = \"Server:Linux Web Server \\r\\n\"; char cnt_len[] = \"Content-length:2048\\r\\n\"; char cnt_type[] = \"Conte","date":"2022-10-09","objectID":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:19:0","tags":["c/c++"],"title":"TCP/IP网络编程","uri":"/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"categories":["Git"],"content":"1. 配置 git config --global user.name \"Your Name\" git config --global user.email \"email@example.com\" #设置远程仓库 git remote add origin git@github.com:vstk771/gitTest.git 注意： git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 ","date":"2022-09-29","objectID":"/posts/git/:1:0","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"2.创建版本库 通过git init命令把这个目录变成Git可以管理的仓库： git init ","date":"2022-09-29","objectID":"/posts/git/:2:0","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"3. 时光穿梭机 ","date":"2022-09-29","objectID":"/posts/git/:3:0","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"3.1 版本回退 在仓库创建一个文件test.txt hello world git add test.txt git commit -m \"first commit\" 提交之后，我们修改test.txt的内容: Hello World!!! git status命令可以让我们时刻掌握仓库当前的状态 git status git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，先对比暂存区，如果暂存区是空的，再对比版本库的。 git diff test.txt 在Git中，我们用git log命令查看提交日志(只显示到HEAD的)： git log 现在，我们要把当前版本回退到上一个版本，就可以使用git reset命令： git reset --hard HEAD^ Git提供了一个命令git reflog用来记录你的每一次命令： git reflog 通过 git reflog 查看命令历史，以便确定要回到未来的哪个版本 $ git reflog 5a14f64 (HEAD -\u003e master) HEAD@{0}: reset: moving to HEAD^ 6507263 HEAD@{1}: commit: second commit 5a14f64 (HEAD -\u003e master) HEAD@{2}: commit (initial): first commit $ git reset --hard 6507263 ","date":"2022-09-29","objectID":"/posts/git/:3:1","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"3.2 工作区与暂存区 工作区（Working Directory） 就是版本库的文件夹目录 版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 ","date":"2022-09-29","objectID":"/posts/git/:3:2","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"3.3 管理修改 第一次修改 -\u003e git add -\u003e 第二次修改 -\u003e git commit Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 总结：每次修改，如果不用git add到暂存区，那就不会加入到commit中； ","date":"2022-09-29","objectID":"/posts/git/:3:3","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"3.4 撤销修改 命令git checkout – test.txt意思就是，把test.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是test.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是test.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 第一种情况： 版本库的test.txt文件的内容 : Hello World!!!1111 暂存区是空的 工作区的内容：Hello World!!!2222 git checkout -- test.txt 现在，撤销修改就回到和版本库一模一样的状态； 第二种情况 版本库的test.txt文件的内容：Hello World!!!1111 暂存区的test.text文件的内容：Hello World!!!2222 工作区的内容：Hello World!!!3333 git checkout -- test.txt 现在，撤销修改就回到添加到暂存区后的状态，但暂存区的数据不会撤销。 用命令git reset HEAD \u003cfile\u003e可以把暂存区的修改撤销掉（unstage），重新放回工作区： git reset HEAD test.txt ","date":"2022-09-29","objectID":"/posts/git/:3:4","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"3.5 删除文件 删除工作区的文件 rm -rf test.txt 将删除版本库的文件 方式1: rm -rf test.txt #删除工作区的文件 # 现在可以恢复删除的文件到工作区：git checkout -- test.txt git add test.txt #相当于将删除指令放入暂存区 # 现在可以恢复删除的文件到暂存区：git reset HEAD test.txt git commit ..... #提交版本库 git rm -rf test.txt #相当于删除工作区的文件，并且执行了git add # 现在可以恢复删除的文件到暂存区：git reset HEAD test.txt git commit ..... #提交版本库 ","date":"2022-09-29","objectID":"/posts/git/:3:5","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"4. 远程仓库 创建SSH Key ： ssh-keygen -t rsa -C \"youremail@example.com\" 可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 ","date":"2022-09-29","objectID":"/posts/git/:4:0","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"4.1 添加远程仓库 添加后，远程库的名字就是origin，这是Git默认的叫法 git remote add origin git@github.com:your.git 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 git push -u origin master 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； git remote -v 查看远程库信息： git remote -v git remote rm \u003cname\u003e 删除远程库： git remote rm origin 此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。 ","date":"2022-09-29","objectID":"/posts/git/:4:1","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"4.2 远程克隆 git clone [远程仓库地址] git clone origin.git ","date":"2022-09-29","objectID":"/posts/git/:4:2","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"5. 分支管理 ","date":"2022-09-29","objectID":"/posts/git/:5:0","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"5.1 创建与合并分支 在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点； 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上； Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变； 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并； 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支； 首先，我们创建dev分支，然后切换到dev分支： git checkout -b dev git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： git branch dev git checkout dev 然后，用git branch命令查看当前分支： git branch git branch命令会列出所有分支，当前分支前面会标一个*号。 在dev分支上我们修改test.txt文件：Hello World!!!qqqq 提交之后，再切换为master分支 git checkout master 切换回master分支后，再查看一个test.txt文件，dev分支的修改内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： git merge命令用于合并指定分支到当前分支。现在，我们把dev分支的工作成果合并到master分支上： $ git merge dev Updating 728a081..a28a0c4 Fast-forward test.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 合并完成后，就可以放心地删除dev分支了： git branch -d dev 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 switch切换分支 创建并切换到新的dev分支，可以使用： git switch -c dev 直接切换到已有的master分支，可以使用： git switch master ","date":"2022-09-29","objectID":"/posts/git/:5:1","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"5.2 解决冲突 准备新的feature1分支： git switch -c feature1 修改test.txt文件的内容并在feature1分支上提交：Hello World!!!feature1 切换到master分支：git switch master 修改test.txt文件的内容并在master分支上提交：Hello World!!!master 现在，master分支和feature1分支各自都分别有新的提交，这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突： $ git merge feature1 Auto-merging test.txt CONFLICT (content): Merge conflict in test.txt Automatic merge failed; fix conflicts and then commit the result. Git告诉我们，test.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： $ git status On branch master You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge) Unmerged paths: (use \"git add \u003cfile\u003e...\" to mark resolution) both modified: test.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 我们可以直接查看readme.txt的内容： \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD Hello World!!!master ======= Hello World!!!feature1 \u003e\u003e\u003e\u003e\u003e\u003e\u003e feature1 Git用«««\u003c，=======，»»»\u003e标记出不同分支的内容，我们修改如下后保存：Hello World!!!master and feature1 再添加提交： git add test.txt git commit -m \"master and feature1\" 用带参数的git log也可以看到分支的合并情况： $ git log --graph --pretty=oneline --abbrev-commit * 3a2834f (HEAD -\u003e master) master and feature1 |\\ | * 63a8de3 (feature1) feature1 * | a0e7929 master |/ * a28a0c4 four commit * 728a081 commit 4 * eb2f88b three commit * 6507263 second commit * 5a14f64 first commit 合并成功，最后，删除feature1分支：git branch -d feature1 小结： 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log --graph命令可以看到分支合并图。 ","date":"2022-09-29","objectID":"/posts/git/:5:2","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"5.3 分支管理策略 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下–no-ff方式的git merge： 这里的–no–ff 模式其实就是相当于master指针new了一个跟dev指针一样的空间并且放了相同的内容然后指向这个空间。而原来的快速模式，就是简单将master指针指向dev指针指向的内容而已，并没有自己创造空间。 首先，仍然创建并切换dev分支：git switch -c dev 修改readme.txt文件，并提交一个新的commit，test.txt：Hello World!!!dev111 切换回master：git switch master 准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward： $ git merge --no-ff -m \"merge dev with no-ff\" dev Merge made by the 'recursive' strategy. test.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： $ git log --graph --pretty=oneline --abbrev-commit * 6cc7985 (HEAD -\u003e master) merge dev with no-ff |\\ | * f38baab (dev) dev |/ * 3a2834f master and feature1 |\\ | * 63a8de3 feature1 * | a0e7929 master |/ * a28a0c4 four commit * 728a081 commit 4 * eb2f88b three commit * 6507263 second commit * 5a14f64 first commit 分支策略 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 小结： 合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 ","date":"2022-09-29","objectID":"/posts/git/:5:3","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"5.4 Bug分支 每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除； 当你接到一个修复一个代号101的bug的任务时，当前正在dev上进行的工作还没有提交： $ git status On branch dev Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: test.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") dev工作只进行到一半，还没法提交，但是，必须先修复这个bug；当前的dev分支的test.txt：Hello World!!! dev doing Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： git stash 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 $ git status On branch dev nothing to commit, working tree clean 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支(bug-101)： git checkout master git checkout -b bug-101 #修改test.txt：Hello World!!! he bug has been fixed!!! git add test.txt git commit -m \"fixed bug-101\" 修复完成后，切换到master分支，并完成合并，最后删除bug-101分支： git switch master git merge --no-ff -m \"merged bug fix 101\" bug-101 现在回到dev分支继续工作： git switch dev git stash list查看工作现场 $ git stash list stash@{0}: WIP on dev: f38baab dev 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： git stash pop `` 查看工作现场 ```git $ git stash list stash@{0}: WIP on dev: 731abfd fixed bug-101 stash@{1}: WIP on dev: 731abfd fixed bug-101 恢复 #默认栈顶 git stash apply #栈顶 git stash apply stash@{0} `` 为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支： ```git $ git cherry-pick 731abfd197 [master f54cc87] fixed bug-101 Date: Wed Sep 28 17:02:43 2022 +0800 1 file changed, 1 insertion(+), 1 deletion(-) 小结 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场； 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick \u003ccommit\u003e命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 ","date":"2022-09-29","objectID":"/posts/git/:5:4","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"5.5 Feature分支 删除一个已提交还未合并的分支。 首先创建一个分支，并提交修改 git switch -c feature # test.txt：Hello World!!! feature git add test.txt git commit -m \"feature\" 切回dev，准备合并：git switch dev，现在突然要删除这个feature分支 $ git branch -d feature error: The branch 'feature' is not fully merged. If you are sure you want to delete it, run 'git branch -D feature'. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。 现在我们强行删除： $ git branch -D feature Deleted branch feature (was 246cd76). 小结： 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D \u003cname\u003e强行删除。 ","date":"2022-09-29","objectID":"/posts/git/:5:5","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"5.6 多人协作 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： $ git remote origin 或者，用git remote -v显示更详细的信息： $ git remote -v origin git@github.com:vstk771/notes.git (fetch) origin git@github.com:vstk771/notes.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：git push origin master 如果要推送其他分支，比如dev，就改成：git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。可以用git branch命令看看： $ git branch * master 在dev分支上开发，就必须创建远程origin的dev分支到本地，即：远程仓库存在dev分支，用这个命令创建本地dev分支(可自由切换)：git checkout -b dev origin/dev git switch -c dev $ git checkout -b dev origin/dev Switched to a new branch 'dev' Branch 'dev' set up to track remote branch 'dev' from 'origin'. //在dev分支开发，修改test.txt：Hello dev git add test.txt git commit -m \"first commit dev\" git push origin dev 也可以在本地创建分支dev2,然后做一些工作再提交远程仓库： git switch -c dev2 git add dev2_test.txt git commit -m \"first commit dev2\" $ git push origin dev2 Enumerating objects: 4, done. Counting objects: 100% (4/4), done. Delta compression using up to 6 threads Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 295 bytes | 295.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 remote: remote: Create a pull request for 'dev2' on GitHub by visiting: remote: https://github.com/vstk771/gitTest/pull/new/dev2 remote: To github.com:vstk771/gitTest.git * [new branch] dev2 -\u003e dev2 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：git pull git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： git branch --set-upstream-to=origin/dev dev 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： git commit -m \"fix and merge\" git push origin dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin \u003cbranch-name\u003e推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin \u003cbranch-name\u003e推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to \u003cbranch-name\u003e origin/\u003cbranch-name\u003e。 小结： 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 ","date":"2022-09-29","objectID":"/posts/git/:5:6","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"5.7 Rebase git rebase ：把分叉的提交历史“整理”成一条直线，看上去更直观 ","date":"2022-09-29","objectID":"/posts/git/:5:7","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"6. 标签管理 ","date":"2022-09-29","objectID":"/posts/git/:6:0","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["Git"],"content":"7. 自定义Git 忽略某些文件时，需要编写.gitignore； .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ .gitignore文件： # 排除所有.开头的隐藏文件: .* # 排除所有.xlsx文件 *.xlsx #排除xxx/这个文件夹 xxx/ # 不排除.gitignore !.gitignore ","date":"2022-09-29","objectID":"/posts/git/:7:0","tags":["Git"],"title":"Git","uri":"/posts/git/"},{"categories":["c++","反汇编"],"content":"1.类型大小 ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:1:0","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"1. 基本数据类型 printf(\"%d\\n\", sizeof(char)); //1 printf(\"%d\\n\", sizeof(short int)); //2 printf(\"%d\\n\", sizeof(int)); //4 printf(\"%d\\n\", sizeof(long int)); //4 printf(\"%d\\n\", sizeof(__int64)); //8 printf(\"%d\\n\", sizeof(float)); //4 printf(\"%d\\n\", sizeof(double)); //8 ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:1:1","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"2. 数组类型 char arr1[10] = { 0 }; short arr2[10] = { 0 }; int arr3[10] = { 0 }; printf(\"%d\\n\", sizeof(arr1)); //10 printf(\"%d\\n\", sizeof(arr2)); //20 printf(\"%d\\n\", sizeof(arr3)); //40 printf(\"%d\\n\", sizeof(arr1[10])); //sizeof(char) 1 printf(\"%d\\n\", sizeof(arr2[10])); //sizeof(short) 2 printf(\"%d\\n\", sizeof(arr3[10])); //sizeof(int) 4 ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:1:2","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"3. 数据对齐 为什么要有数据对齐？ 本质：效率还是空间，二选一的结果； #pragma pack的基本用法为： #pragma pack( n ) 结构体... #pragma pack( ) 对齐参数：n为字节对齐数，其取值为1、2、4、8，默认是8。如果这个值比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准， 即是说，结构体成员的偏移量应该取二者的最小值. 结构对齐大小 如果这个值比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准，即是说，结构体成员的偏移量应该取二者的最小值； 对齐原则： 原则一：数据成员对齐规则：结构的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始(比如int在32位机为４字节，则要从4的整数倍地址开始存储). 原则二：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。 原则三：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。 (struct a里存有struct b，b里有char，int，double等元素，那b应该从8的整数倍开始存储.) 原则四：对齐参数如果比结构体成员的sizeof值小，该成员的偏移量应该以此值为准.也就是说，结构体成员的偏移量应该取二者的最小值 建议： 按照数据类型由小到大的顺序进行书写 实例 //16 struct S1 { char c; //8 double i; //8 }; //40 struct S2 { char c1; //8 S1 s; //16 =\u003e char c; double i; char c2; //8 double c3; //8 }; //32 struct S3 { char c1; //8 S1 s; //16 =\u003e char c; double i; char c2; // =\u003e sizeof(c2) + sizeof(c3) = 2 + 6 = 8 char c3; }; //12 struct S4 { int c1; //sizeof(int) + sizeof(char) * 5 =》 4 + 4 + 1 + 3(填充) = 12 char c2[5]; }; //16 struct S5 { int c1; //sizeof(int) + sizeof(char) * 10 =》 4 + (4 * 2 + 2 + 2(填充)) = 16 char c2[10]; }; int main() { int a = sizeof(S1); int b = sizeof(S2); int c = sizeof(S3); int d = sizeof(S4); int e = sizeof(S5); return 0; } ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:1:3","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"2. 面向对象 ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:2:0","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"2.1 对象 绕过编译器，修改对象的私有成员： #include \u003ciostream\u003e class Test { public: Test(int x, int y) { this-\u003ex = x; this-\u003ey = y; } void pri() { std::cout \u003c\u003c \"x : \" \u003c\u003c x \u003c\u003c \"\\ny : \" \u003c\u003c y \u003c\u003c std::endl;; } private: int x; int y; }; int main() { Test t(1, 2); int* p = (int*)\u0026t; int n = *p; int m = *(p + 1); *p = 3; *(p + 1) = 4; std::cout \u003c\u003c \"n : \" \u003c\u003c n \u003c\u003c \"\\nm : \" \u003c\u003c m \u003c\u003c std::endl;; t.pri(); system(\"pause\"); return 0; } 绕过编译器，调用对象的私有成员函数： #include \u003ciostream\u003e struct Base { private: virtual void Function_1() { printf(\"Base:Function_1...\\n\"); } virtual void Function_2() { printf(\"Base:Function_2...\\n\"); } virtual void Function_3() { printf(\"Base:Function_3...\\n\"); } }; int main() { Base b; Base* ptr = \u0026b; void(*f1)(void) = (void(*)(void))(*((int*)(*(int*)\u0026b + 0))); void(*f2)(void) = (void(*)(void))(*((int*)(*(int*)\u0026b + 4))); void(*f3)(void) = (void(*)(void))(*((int*)(*(int*)\u0026b + 8))); /* 0. 函数指针：(void(*)(void)) 1. 指向虚表的地址：(*(int *)\u0026b) 2. 虚函数的地址(或第一个虚函数的地址)：(*((int*)(*(int *)\u0026b + 0))) */ f1(); f2(); f3(); system(\"pause\"); return 0; } 总结： private修饰的成员与普通的成员没有区别 只是编译器会检测。 private修饰的成员只有自己的其他成员才能访问； struct 与 class 编译器默认class中的成员为private，而struct中的成员为public class 默认private继承，struct 默认public继承 指针与引用 #include \u003ciostream\u003e int main() { int a = 12; int* ptr = \u0026a; int\u0026 ref = a; system(\"pause\"); return 0; } int a = 12; 008F1728 mov dword ptr [ebp-0Ch],0Ch int* ptr = \u0026a; 008F172F lea eax,[ebp-0Ch] 008F1732 mov dword ptr [ebp-18h],eax int\u0026 ref = a; 008F1735 lea eax,[ebp-0Ch] 008F1738 mov dword ptr [ebp-24h],eax 总结：指针与引用在汇编层次，没有任何区别； ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:2:1","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"2.2 虚表 继承 父类中的私有成员是会被继承的 只是编译器不允许直接进行访问 当类中有虚函数时，会多一个属性，4个字节(单一继承) 多出的属性是一个地址，指向一张表，里面存储了所有虚函数的地址 在x86中，指针类型大小都为4个字节 ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:3:0","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"2.2.1 非继承虚函数表 //普通继承，非覆盖 struct Base { public: virtual void Function_1() { printf(\"Base:Function_1...\\n\"); } virtual void Function_2() { printf(\"Base:Function_2...\\n\"); } virtual void Function_3() { printf(\"Base:Function_3...\\n\"); } }; int main() { Base base; Base* ptr = \u0026base; //断点到此处 ptr-\u003eFunction_1(); ptr-\u003eFunction_2(); ptr-\u003eFunction_3(); system(\"pause\"); return 0; } 汇编如下: Base base; 009D51D8 lea ecx,[ebp-0Ch] 009D51DB call 009D103C Base* ptr = \u0026base; 009D51E0 lea eax,[ebp-0Ch] ;获得base的地址 009D51E3 mov dword ptr [ebp-18h],eax //断点到此处 ptr-\u003eFunction_1(); 009D51E6 mov eax,dword ptr [ebp-18h] ;\u0026base 009D51E9 mov edx,dword ptr [eax] ;base的虚表地址 009D51EB mov esi,esp 009D51ED mov ecx,dword ptr [ebp-18h] 009D51F0 mov eax,dword ptr [edx] ;第一个函数的地址 009D51F2 call eax 009D51F4 cmp esi,esp 009D51F6 call 009D1140 ptr-\u003eFunction_2(); 009D51FB mov eax,dword ptr [ebp-18h] 009D51FE mov edx,dword ptr [eax] 009D5200 mov esi,esp 009D5202 mov ecx,dword ptr [ebp-18h] 009D5205 mov eax,dword ptr [edx+4] ;第二个函数的地址，偏移4个字节 009D5208 call eax 009D520A cmp esi,esp 009D520C call 009D1140 ptr-\u003eFunction_3(); 009D5211 mov eax,dword ptr [ebp-18h] 009D5214 mov edx,dword ptr [eax] 009D5216 mov esi,esp 009D5218 mov ecx,dword ptr [ebp-18h] 009D521B mov eax,dword ptr [edx+8] ;第三个函数的地址，偏移8个字节 009D521E call eax 009D5220 cmp esi,esp 009D5222 call 009D1140 验证： void TestMethod() { //查看 Sub 的虚函数表 Base base; Base* ptr = \u0026base; //包含一个虚表指针 printf(\"base 的地址为：%x\\n\", \u0026base); //对象的前四个字节就是虚函数表 printf(\"base 的虚函数表地址为：%x\\n\", *(int*)\u0026base); for (int i = 0; i \u003c 3; i++) { printf(\"虚函数%d的地址：%x\\n\", i + 1, *((int*)(*(int*)\u0026base) + i)); } //通过函数指针调用函数，验证正确性 typedef void(*pFunction)(void); pFunction pFn; for (int i = 0; i \u003c 3; i++) { int temp = *((int*)(*(int*)\u0026base) + i); pFn = (pFunction)temp; pFn(); } } ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:3:1","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"2.2.2 继承非覆盖虚函数表 父类的虚函数表和子类不相同，每个类都独有自己的一份虚函数表； 通过调试不难发现，Sub子类的的虚表就是：Function_1、Function_2、Function_3、Function_4、Function_5、Function_6 这个6个函数的地址；Base基类的虚表就是：Function_1、Function_2、Function_3 这个3个函数地址； #include \u003ciostream\u003e //普通继承，非覆盖 struct Base { public: virtual void Function_1() { printf(\"Base:Function_1...\\n\"); } virtual void Function_2() { printf(\"Base:Function_2...\\n\"); } virtual void Function_3() { printf(\"Base:Function_3...\\n\"); } }; struct Sub :Base { public: virtual void Function_4() { printf(\"Sub:Function_4...\\n\"); } virtual void Function_5() { printf(\"Sub:Function_5...\\n\"); } virtual void Function_6() { printf(\"Sub:Function_6...\\n\"); } }; void TestMethod() { //查看 Sub， Base 的虚函数表 Sub sub; Base base; Base* ptr1 = \u0026sub; //包含一个虚表指针 Base* ptr2 = \u0026base; printf(\"base 的地址为：%x\\n\", \u0026base); //对象的前四个字节就是虚函数表 printf(\"base 的虚函数表地址为：%x\\n\", *(int*)\u0026base); for (int i = 0; i \u003c 3; i++) { printf(\"Base虚函数%d的地址：%x\\n\", i + 1, *((int*)(*(int*)\u0026base) + i)); } //通过函数指针调用函数，验证正确性 typedef void(*pFunction)(void); pFunction p1Fn; for (int i = 0; i \u003c 3; i++) { int temp = *((int*)(*(int*)\u0026base) + i); p1Fn = (pFunction)temp; p1Fn(); } std::cout \u003c\u003c std::endl; printf(\"Sub 的地址为：%x\\n\", \u0026sub); //对象的前四个字节就是虚函数表 printf(\"Sub 的虚函数表地址为：%x\\n\", *(int*)\u0026sub); for (int i = 0; i \u003c 6; i++) { printf(\"Sub虚函数%d的地址：%x\\n\", i + 1, *((int*)(*(int*)\u0026sub) + i)); } //通过函数指针调用函数，验证正确性 pFunction p2Fn; for (int i = 0; i \u003c 6; i++) { int temp = *((int*)(*(int*)\u0026sub) + i); p2Fn = (pFunction)temp; p2Fn(); } } int main() { TestMethod(); system(\"pause\"); return 0; } ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:3:2","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"2.2.3 继承覆盖虚函数表 子类优先按照基类声明的顺序添加虚函数； #include \u003ciostream\u003e //普通继承，覆盖 struct Base { public: virtual void Function_1() { printf(\"Base:Function_1...\\n\"); } virtual void Function_2() { printf(\"Base:Function_2...\\n\"); } virtual void Function_3() { printf(\"Base:Function_3...\\n\"); } }; struct Sub :Base { public: virtual void Function_1() { printf(\"Sub:Function_1...\\n\"); } virtual void Function_5() { printf(\"Sub:Function_5...\\n\"); } virtual void Function_3() { printf(\"Sub:Function_3...\\n\"); } }; //查看 Sub， Base 的虚函数表 void TestMethod() { //查看 Sub， Base 的虚函数表 Sub sub; Base base; Base* ptr1 = \u0026sub; //包含一个虚表指针 Base* ptr2 = \u0026base; printf(\"base 的地址为：%x\\n\", \u0026base); //对象的前四个字节就是虚函数表 printf(\"base 的虚函数表地址为：%x\\n\", *(int*)\u0026base); for (int i = 0; i \u003c 3; i++) { printf(\"Base虚函数%d的地址：%x\\n\", i + 1, *((int*)(*(int*)\u0026base) + i)); } //通过函数指针调用函数，验证正确性 typedef void(*pFunction)(void); pFunction p1Fn; for (int i = 0; i \u003c 3; i++) { int temp = *((int*)(*(int*)\u0026base) + i); p1Fn = (pFunction)temp; p1Fn(); } std::cout \u003c\u003c std::endl; printf(\"Sub 的地址为：%x\\n\", \u0026sub); //对象的前四个字节就是虚函数表 printf(\"Sub 的虚函数表地址为：%x\\n\", *(int*)\u0026sub); for (int i = 0; i \u003c 4; i++) { printf(\"Sub虚函数%d的地址：%x\\n\", i + 1, *((int*)(*(int*)\u0026sub) + i)); } //通过函数指针调用函数，验证正确性 pFunction p2Fn; for (int i = 0; i \u003c 4; i++) { int temp = *((int*)(*(int*)\u0026sub) + i); p2Fn = (pFunction)temp; p2Fn(); } } int main() { TestMethod(); system(\"pause\"); return 0; } ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:3:3","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"2.2.4 多继承非覆盖虚函数表 #include \u003ciostream\u003e struct Base1 { public: virtual void Fn_1() { printf(\"Base1:Fn_1...\\n\"); } virtual void Fn_2() { printf(\"Base1:Fn_2...\\n\"); } }; struct Base2 { public: virtual void Fn_3() { printf(\"Base2:Fn_3...\\n\"); } virtual void Fn_4() { printf(\"Base2:Fn_4...\\n\"); } }; struct Sub :Base1, Base2 { public: virtual void Fn_5() { printf(\"Sub:Fn_5...\\n\"); } virtual void Fn_6() { printf(\"Sub:Fn_6...\\n\"); } }; int main() { //查看 Sub 的虚函数表 Sub sub; //通过函数指针调用函数，验证正确性 typedef void(*pFunction)(void); //对象的前四个字节是第一个虚表: 经过编译器优化：Base1 + Sub 的虚函数组成的表 printf(\"Sub的第一个虚表的虚函数表地址为：%x\\n\", *(int*)\u0026sub); pFunction pFn; for (int i = 0; i \u003c 4; i++) { int temp = *((int*)(*(int*)\u0026sub) + i); if (temp == 0) { break; } pFn = (pFunction)temp; pFn(); } //对象的第二个四字节是第二个虚表, 根据编译器的优化 =》 Base2的虚表 printf(\"Sub的第二个虚表的虚函数表地址为：%x\\n\", *(int*)((int*)\u0026sub + 4)); pFunction pFn1; for (int k = 0; k \u003c 2; k++) { int temp = *((int*)(*(int*)((int)\u0026sub + 4)) + k); pFn1 = (pFunction)temp; pFn1(); } system(\"pause\"); return 0; } 结论：Sub的虚表由两个虚表组成： Base1 + Sub 的虚函数组成的虚表; Base2组成的虚表 猜测：之后的继承的每个类有单独的虚表，如Base2一样； ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:3:4","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"2.2.5 多继承覆盖虚函数表 #include \u003ciostream\u003e struct Base1 { public: virtual void Fn_1() { printf(\"Base1:Fn_1...\\n\"); } virtual void Fn_2() { printf(\"Base1:Fn_2...\\n\"); } }; struct Base2 { public: virtual void Fn_3() { printf(\"Base2:Fn_3...\\n\"); } virtual void Fn_4() { printf(\"Base2:Fn_4...\\n\"); } }; struct Base3 { public: virtual void Fn_6() { printf(\"Base3:Fn_6...\\n\"); } virtual void Fn_7() { printf(\"Base3:Fn_7...\\n\"); } }; struct Sub :Base1, Base2, Base3 { public: virtual void Fn_1() { printf(\"Sub:Fn_1...\\n\"); } virtual void Fn_3() { printf(\"Sub:Fn_3...\\n\"); } virtual void Fn_5() { printf(\"Sub:Fn_5...\\n\"); } virtual void Fn_6() { printf(\"Sub:Fn_6...\\n\"); } virtual void Fn_8() { printf(\"Sub:Fn_8...\\n\"); } }; int main() { //查看 Sub 的虚函数表 Sub sub; //通过函数指针调用函数，验证正确性 typedef void(*pFunction)(void); //对象的前四个字节是第一个虚表: 经过编译器优化：Base1 + Sub 的虚函数组成的表 printf(\"第一个虚表 的虚函数表地址为：%x\\n\", *(int*)\u0026sub); pFunction pFn; for (int i = 0; i \u003c 4; i++) { int temp = *((int*)(*(int*)\u0026sub) + i); if (temp == 0) { break; } pFn = (pFunction)temp; pFn(); } //对象的第二个四字节是第二个虚表, 根据编译器的优化 =》 Base2的虚表 printf(\"第二个虚表 的虚函数表地址为：%x\\n\", *(int*)((int)\u0026sub + 4)); pFunction pFn1; for (int k = 0; k \u003c 2; k++) { int temp = *((int*)(*(int*)((int)\u0026sub + 4)) + k); pFn1 = (pFunction)temp; pFn1(); } //对象的第三个四字节是第三个虚表, 根据编译器的优化 =》 Base3的虚表 printf(\"第三个虚表 的虚函数表地址为：%x\\n\", *(int*)((int)\u0026sub + 8)); for (int k = 0; k \u003c 2; k++) { int temp = *((int*)(*(int*)((int)\u0026sub + 8)) + k); pFn1 = (pFunction)temp; pFn1(); } system(\"pause\"); return 0; } 结论：Sub的虚表由三个虚表组成，按照继承顺序组合： Base1 + Sub 的虚函数组成的虚表：Sub::Fn_1(), Base1::Fn_2(), Sub::Fn_5(), Sub::Fn_8(); Base2 + Sub 的虚函数组成的虚表：Sub::Fn_3(), Base2::Fn_4(); Base3 + Sub 的虚函数组成的虚表：Sub::Fn_6(), Base3::Fn_7(); ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:3:5","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"2.2.6 单一连续继承，无函数覆盖 #include \u003ciostream\u003e struct Base1 { public: virtual void Fn_1() { printf(\"Base1:Fn_1...\\n\"); } virtual void Fn_2() { printf(\"Base1:Fn_2...\\n\"); } }; struct Base2 :Base1 { public: virtual void Fn_3() { printf(\"Base2:Fn_3...\\n\"); } virtual void Fn_4() { printf(\"Base2:Fn_4...\\n\"); } }; struct Sub :Base2 { public: virtual void Fn_5() { printf(\"Sub:Fn_5...\\n\"); } virtual void Fn_6() { printf(\"Sub:Fn_6...\\n\"); } }; int main(int argc, char* argv[]) { //查看 Sub 的虚函数表 Sub sub; //观察大小：虚函数表只有一个 printf(\"%x\\n\", sizeof(sub)); //通过函数指针调用函数，验证正确性 typedef void(*pFunction)(void); //对象的前四个字节是就是虚函数表 printf(\"Sub 的虚函数表地址为：%x\\n\", *(int*)\u0026sub); pFunction pFn; for (int i = 0; i \u003c 6; i++) { int temp = *((int*)(*(int*)\u0026sub) + i); if (temp == 0) { break; } pFn = (pFunction)temp; pFn(); } return 0; } 结论：单一继承，虚表只有一个； ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:3:6","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"2.2.7 单一连续继承，有函数覆盖 #include \u003ciostream\u003e struct Base1 { public: virtual void Fn_1() { printf(\"Base1:Fn_1...\\n\"); } virtual void Fn_2() { printf(\"Base1:Fn_2...\\n\"); } }; struct Base2 :Base1 { public: virtual void Fn_1() { printf(\"Base2:Fn_1...\\n\"); } virtual void Fn_3() { printf(\"Base2:Fn_3...\\n\"); } }; struct Sub :Base2 { public: virtual void Fn_1() { printf(\"Sub:Fn_1...\\n\"); } virtual void Fn_5() { printf(\"Sub:Fn_5...\\n\"); } }; int main(int argc, char* argv[]) { //查看 Sub 的虚函数表 Sub sub; //观察大小：虚函数表只有一个 printf(\"%x\\n\", sizeof(sub)); //通过函数指针调用函数，验证正确性 typedef void(*pFunction)(void); //对象的前四个字节是就是虚函数表 printf(\"Sub 的虚函数表地址为：%x\\n\", *(int*)\u0026sub); pFunction pFn; for (int i = 0; i \u003c 6; i++) { int temp = *((int*)(*(int*)\u0026sub) + i); if (temp == 0) { break; } pFn = (pFunction)temp; pFn(); } return 0; } 结论：单一继承，虚表只有一个； ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:3:7","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++","反汇编"],"content":"2.2.8 例子 定义一个父类：Base 有两个成员X,Y 有一个函数Print(非virtul) 能够打印X,Y的值。 #include \u003ciostream\u003e class Base { public: Base(int x, int y) : x(x), y(y) { }; private: int x, y; }; void prt(void* ptr) { printf(\"X: %d Y: %d\\n\", *((int*)ptr), *((int*)ptr + 1)); } int main() { Base base(1, 2); prt(\u0026base); system(\"pause\"); return 0; } 定义3个子类：Sub1有一个成员A, Sub2有一个成员B, Sub3 有一个成员C; 每个子类有一个函数Print(非virtul)，打印所有成员。 Sub1:打印X Y A Sub2:打印X Y B Sub3:打印X Y C #include \u003ciostream\u003e class Base { public: Base(int x, int y) : x(x), y(y) { }; private: int x, y; }; class Sub1 : public Base { public: Sub1(int x, int y, int n) : Base(x, y), a(n) { } void prt(void* ptr) { printf(\"X: %d Y: %d #: %d\\n\", *((int*)ptr), *((int*)ptr + 1), *((int*)ptr + 2)); } private: int a; }; class Sub2 : public Base { public: Sub2(int x, int y, int n) : Base(x, y), b(n) { } void prt(void* ptr) { printf(\"X: %d Y: %d #: %d\\n\", *((int*)ptr), *((int*)ptr + 1), *((int*)ptr + 2)); } private: int b; }; class Sub3 : public Base { public: Sub3(int x, int y, int n) : Base(x, y), c(n) { } void prt(void* ptr) { printf(\"X: %d Y: %d #: %d\\n\", *((int*)ptr), *((int*)ptr + 1), *((int*)ptr + 2)); } private: int c; }; int main() { Sub1 sub1(1, 2, 3); Sub1 sub2(4, 5, 6); Sub1 sub3(7, 8, 9); sub1.prt(\u0026sub1); sub2.prt(\u0026sub2); sub3.prt(\u0026sub3); system(\"pause\"); return 0; } 总结：子类的成员 = 基类的成员 + 子类的成员 将上面所有的Print函数改成virtul 继续观察效果. #include \u003ciostream\u003e class Base { public: Base(int x, int y) : x(x), y(y) { }; private: int x, y; }; class Sub1 : public Base { public: Sub1(int x, int y, int n) : Base(x, y), a(n) { } virtual void prt(void* ptr) { printf(\"X: %d Y: %d #: %d\\n\", *((int*)ptr + 1), *((int*)ptr + 2), *((int*)ptr + 3)); } private: int a; }; class Sub2 : public Base { public: Sub2(int x, int y, int n) : Base(x, y), b(n) { } virtual void prt(void* ptr) { printf(\"X: %d Y: %d #: %d\\n\", *((int*)ptr + 1), *((int*)ptr + 2), *((int*)ptr + 3)); } private: int b; }; class Sub3 : public Base { public: Sub3(int x, int y, int n) : Base(x, y), c(n) { } virtual void prt(void* ptr) { printf(\"X: %d Y: %d #: %d\\n\", *((int*)ptr + 1), *((int*)ptr + 2), *((int*)ptr + 3)); } private: int c; }; int main() { Sub1 sub1(1, 2, 3); Sub1 sub2(4, 5, 6); Sub1 sub3(7, 8, 9); sub1.prt(\u0026sub1); sub2.prt(\u0026sub2); sub3.prt(\u0026sub3); system(\"pause\"); return 0; } 总结：子类成员在对象的前4字节(虚表地址)之后，子类的成员 = 基类的成员 + 子类的成员 ","date":"2022-09-24","objectID":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/:3:8","tags":["反汇编"],"title":"c++反汇编(x86)","uri":"/posts/c++%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"categories":["c++"],"content":"前言 CMake是一个跨平台的安装编译工具，可以用简单的语句来描述所有平台的安装(编译过程)。 CMake可以说已经成为大部分C++开源项目标配 ","date":"2022-09-15","objectID":"/posts/cmake/:0:0","tags":["CMake"],"title":"CMake","uri":"/posts/cmake/"},{"categories":["c++"],"content":"1. 语法特性介绍 基本语法格式：指令(参数 1 参数 2…) 参数使用括弧括起 参数之间使用空格或分号分开 指令是大小写无关的，参数和变量是大小写相关的 set(HELLO hello.cpp) add_executable(hello main.cpp hello.cpp) ADD_EXECUTABLE(hello main.cpp ${HELLO}) 变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名 ","date":"2022-09-15","objectID":"/posts/cmake/:1:0","tags":["CMake"],"title":"CMake","uri":"/posts/cmake/"},{"categories":["c++"],"content":"2. 重要指令和CMake常用变量 cmake_minimum_required - 指定CMake的最小版本要求 语法： cmake_minimum_required(VERSION versionNumber [FATAL_ERROR]) # CMake最小版本要求为2.8.3 cmake_minimum_required(VERSION 2.8.3) project - 定义工程名称，并可指定工程支持的语言 语法： project(projectname [CXX] [C] [Java]) # 指定工程名为HELLOWORLD project(HELLOWORLD) set - 显式的定义变量 语法：set(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) # 定义SRC变量，其值为sayHello.cpp hello.cpp set(SRC sayHello.cpp hello.cpp) include_directories - 向工程添加多个特定的头文件搜索路径 —\u003e相当于指定g++编译器的-I参数 语法： include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...) # 将/usr/include/myincludefolder 和 ./include 添加到头文件搜索路径 include_directories(/usr/include/myincludefolder ./include) link_directories - 向工程添加多个特定的库文件搜索路径 —\u003e相当于指定g++编译器的-L参数 语法： link_directories(dir1 dir2 ...) # 将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径 link_directories(/usr/lib/mylibfolder ./lib) add_library - 生成库文件 语法： add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN) # 通过变量 SRC 生成 libhello.so 共享库 add_library(hello SHARED ${SRC}) add_compile_options - 添加编译参数 语法：add_compile_options() # 添加编译参数 -Wall -std=c++11 -O2 add_compile_options(-Wall -std=c++11 -O2) add_executable - 生成可执行文件 语法：add_executable(exename source1 source2 ... sourceN) # 编译main.cpp生成可执行文件main add_executable(main main.cpp) target_link_libraries - 为 target 添加需要链接的共享库 —\u003e相同于指定g++编译器-l参数 语法： target_link_libraries(target library1\u003cdebug | optimized\u003e library2...) # 将hello动态库文件链接到可执行文件main target_link_libraries(main hello) add_subdirectory - 向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制 存放的位置 语法： add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) # 添加src子目录，src中需有一个CMakeLists.txt add_subdirectory(src) aux_source_directory - 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表 语法： aux_source_directory(dir VARIABLE) # 定义SRC变量，其值为当前目录下所有的源代码文件 aux_source_directory(. SRC) # 编译SRC变量所代表的源代码文件，生成main可执行文件 add_executable(main ${SRC}) ","date":"2022-09-15","objectID":"/posts/cmake/:2:0","tags":["CMake"],"title":"CMake","uri":"/posts/cmake/"},{"categories":["c++"],"content":"3. CMake常用变量 CMAKE_C_FLAGS gcc编译选项 CMAKE_CXX_FLAGS g++编译选项 # 在CMAKE_CXX_FLAGS编译选项后追加-std=c++11 set( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\") CMAKE_BUILD_TYPE 编译类型(Debug, Release) # 设定编译类型为debug，调试时需要选择debug set(CMAKE_BUILD_TYPE Debug) # 设定编译类型为release，发布时需要选择release set(CMAKE_BUILD_TYPE Release) CMAKE_BINARY_DIR PROJECT_BINARY_DIR _BINARY_DIR 1. 这三个变量指代的内容是一致的。 2. 如果是 in source build，指的就是工程顶层目录。 3. 如果是 out-of-source 编译,指的是工程编译发生的目录。 4. PROJECT_BINARY_DIR 跟其他指令稍有区别，不过现在，你可以理解为他们是一致的。 CMAKE_SOURCE_DIR PROJECT_SOURCE_DIR _SOURCE_DIR 1. 这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录。 2. 也就是在 in source build时,他跟 CMAKE_BINARY_DIR 等变量一致。 3. PROJECT_SOURCE_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。 CMAKE_C_COMPILER：指定C编译器 CMAKE_CXX_COMPILER：指定C++编译器 EXECUTABLE_OUTPUT_PATH：可执行文件输出的存放路径 LIBRARY_OUTPUT_PATH：库文件输出的存放路径 ","date":"2022-09-15","objectID":"/posts/cmake/:3:0","tags":["CMake"],"title":"CMake","uri":"/posts/cmake/"},{"categories":["c++"],"content":"4. CMake编译工程 CMake目录结构：项目主目录存在一个CMakeLists.txt文件 两种方式设置编译规则： 包含源文件的子文件夹包含CMakeLists.txt文件，主目录的CMakeLists.txt通过add_subdirectory 添加子目录即可； 包含源文件的子文件夹未包含CMakeLists.txt文件，子目录编译规则体现在主目录的CMakeLists.txt中； ","date":"2022-09-15","objectID":"/posts/cmake/:4:0","tags":["CMake"],"title":"CMake","uri":"/posts/cmake/"},{"categories":["c++"],"content":"4.1 编译流程 在 linux 平台下使用 CMake 构建C/C++工程的流程如下: 手动编写 CMakeLists.txt。 执行命令 cmake PATH 生成 Makefile ( PATH 是顶层CMakeLists.txt 所在的目录 )。 执行命令 make 进行编译。 # important tips . # 表示当前目录 ./ # 表示当前目录 .. # 表示上级目录 ../ # 表示上级目录 ","date":"2022-09-15","objectID":"/posts/cmake/:4:1","tags":["CMake"],"title":"CMake","uri":"/posts/cmake/"},{"categories":["c++"],"content":"4.2 两种构建方式 内部构建(in-source build)：不推荐使用 内部构建会在同级目录下产生一大堆中间文件，这些中间文件并不是我们最终所需要的，和工程源文件放在一起会显得杂乱无章。 ## 内部构建 # 在当前目录下，编译本目录的CMakeLists.txt，生成Makefile和其他文件 cmake . # 执行make命令，生成target make 外部构建(out-of-source build)：推荐使用 将编译输出文件与源文件放到不同目录中 ## 外部构建 # 1. 在当前目录下，创建build文件夹 mkdir build # 2. 进入到build文件夹 cd build # 3. 编译上级目录的CMakeLists.txt，生成Makefile和其他文件 cmake .. # 4. 执行make命令，生成target make ","date":"2022-09-15","objectID":"/posts/cmake/:4:2","tags":["CMake"],"title":"CMake","uri":"/posts/cmake/"},{"categories":["c++"],"content":"5. CMake代码实践 ","date":"2022-09-15","objectID":"/posts/cmake/:5:0","tags":["CMake"],"title":"CMake","uri":"/posts/cmake/"},{"categories":["c++"],"content":"5.1 简单CMake工程 test.cpp #include \u003ciostream\u003e int main() { std::cout \u003c\u003c \"hello world!!!\" \u003c\u003c std::endl; return 0; } CMakeLists.txt # Set the minimum version of CMake that can be used cmake_minimum_required(VERSION 3.0) # Set the project name project (TEST) # Add an executable add_executable(test_cmake test.cpp) ","date":"2022-09-15","objectID":"/posts/cmake/:5:1","tags":["CMake"],"title":"CMake","uri":"/posts/cmake/"},{"categories":["c++"],"content":"5.2 多级目录工程 - 直接编译 say.h #pragma once //防止重复编译 #include \u003ciostream\u003e #include \u003cstring\u003e class Say { public: Say(std::string name) : name(name) { } void sayHello(); private: std::string name; }; say.cpp #include \"say.h\" void Say::sayHello() { std::cout \u003c\u003c name \u003c\u003c \": say hello!!!\" \u003c\u003c endl; } main.cpp #include \"say.h\" int main(int argc, char **argv) { bool wall = 1; //未使用的变量 Say say(\"cjt\"); say.sayHello(); return 0; } CMakeLists.txt # Set the minimum version of CMake that can be used cmake_minimum_required(VERSION 3.0) #project name project(SAYHELLO) #head file pat include_directories(include) #生成可执行文件 add_executable(sayHello main.cpp src/say.cpp) ","date":"2022-09-15","objectID":"/posts/cmake/:5:2","tags":["CMake"],"title":"CMake","uri":"/posts/cmake/"},{"categories":["c++"],"content":"5.3 多级目录工程 - 生成库编译 # Set the minimum version of CMake that can be used cmake_minimum_required(VERSION 3.0) #project name project(SAYHELLO_LIBRARY) #add compile options - 添加编译参数 add_compile_options(-std=c++11 -Wall) #set CMAKE_BUILD_TYPE 编译类型(Debug) set(CMAKE_BUILD_TYPE Debug) # set output binary path set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin) ############################################################ # Create a library ############################################################ #Generate the static library from the library sources add_library(say_lib STATIC src/say.cpp) target_include_directories(say_lib PUBLIC ${PROJECT_SOURCE_DIR}/include) ############################################################ # Create an executable ############################################################ # Add an executable with the above sources add_executable(sayHello main.cpp) # link the new sayHello target with the say_lib target target_link_libraries(sayHello say_lib) ","date":"2022-09-15","objectID":"/posts/cmake/:5:3","tags":["CMake"],"title":"CMake","uri":"/posts/cmake/"},{"categories":["c++"],"content":"6. 搭配 vs code . ├── CMakeLists.txt ├── build ├── include │ └── say.h ├── main.cpp └── src └── say.cpp 3 directories, 4 files launch.json { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"(gdb) Attach\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/c++/build/bin/sayHello\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ], \"preLaunchTask\": \"Build\", \"miDebuggerPath\": \"/usr/bin/gdb\" } ] } tasks.json { \"version\": \"2.0.0\", \"options\": { \"cwd\": \"${workspaceFolder}/c++/build\" }, \"tasks\": [ { \"type\": \"shell\", \"label\": \"cmake\", \"command\": \"cmake\", \"args\":[ \"..\" ] }, { \"label\": \"make\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"command\": \"make\", \"args\": [ ] }, { \"label\": \"Build\", \"dependsOrder\": \"sequence\", \"dependsOn\": [ \"cmake\", \"make\" ] } ], } ","date":"2022-09-15","objectID":"/posts/cmake/:6:0","tags":["CMake"],"title":"CMake","uri":"/posts/cmake/"},{"categories":["c++"],"content":" 使用gcc指令编译c代码 使用g++指令编译c++代码 ","date":"2022-09-14","objectID":"/posts/gcc%E7%BC%96%E8%AF%91%E5%99%A8/:0:0","tags":["GCC"],"title":"GCC编译器","uri":"/posts/gcc%E7%BC%96%E8%AF%91%E5%99%A8/"},{"categories":["c++"],"content":"1.编译过程 test.cpp #include \u003ciostream\u003e int main() { #ifdef DEBUG std::cout \u003c\u003c \"DEBUG ...\" \u003c\u003c std::endl; #else std::cout \u003c\u003c \"hello world!!!\" \u003c\u003c std::endl; #endif return 0; } 预处理(Pre-Processing) -E 选项指示编译器仅对输入文件进行预处理 g++ -E test.cpp -o test.i //.i文件 编译(Compiling) -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译 g++ 产生的汇编语言文件的缺省扩展名是 .s g++ -S test.i -o test.s //.s文件 汇编(Assmebling) -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码 缺省时 g++ 建立的目标代码文件有一个 .o 的扩展名。 g++ -c test.s -o test.o //.o文件 链接(Linking) -o 编译选项来为将产生的可执行文件用指定的文件名 g++ test.o -o test.bin //.bin文件 ","date":"2022-09-14","objectID":"/posts/gcc%E7%BC%96%E8%AF%91%E5%99%A8/:1:0","tags":["GCC"],"title":"GCC编译器","uri":"/posts/gcc%E7%BC%96%E8%AF%91%E5%99%A8/"},{"categories":["c++"],"content":"2.g++编译参数 -g 编译带调试信息的可执行文件 # -g 选项告诉 GCC 产生能被 GNU 调试器GDB使用的调试信息，以调试程序。 # 产生带调试信息的可执行文件test g++ -g test.cpp -O[n] 优化源代码 ## 所谓优化，例如省略掉代码中从未使用过的变量、直接将常量表达式用结果值代替等等，这些操作 会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。 # -O 选项告诉 g++ 对源代码进行基本优化。这些优化在大多数情况下都会使程序执行的更快。 -O2 选项告诉 g++ 产生尽可能小和尽可能快的代码。 如-O2，-O3，-On（n 常为0–3） # -O 同时减小代码的长度和执行时间，其效果等价于-O1 # -O0 表示不做优化 # -O1 为默认优化 # -O2 除了完成-O1的优化之外，还进行一些额外的调整工作，如指令调整等。 # -O3 则包括循环展开和其他一些与处理特性相关的优化工作。 # 选项将使编译的速度比使用 -O 时慢， 但通常产生的代码执行速度会更快。 # 使用 -O2优化源代码，并输出可执行文件 g++ -O2 test.cpp -l 和 -L 指定库文件 | 指定库文件路径 # -l参数(小写)就是用来指定程序要链接的库，-l参数紧接着就是库名 # 在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接 # 链接glog库 g++ -lglog test.cpp # 如果库文件没放在上面三个目录里，需要使用-L参数(大写)指定库文件所在目录 # -L参数跟着的是库文件所在的目录名 # 链接mytest库，libmytest.so在/home/bing/mytestlibfolder目录下 g++ -L/home/bing/mytestlibfolder -lmytest test.cpp -l 指定头文件搜索目录 # -I # /usr/include目录一般是不用指定的，gcc知道去那里找，但 是如果头文件不在/usr/icnclude 里我们就要用-I参数指定了，比如头文件放在/myinclude目录里，那编译命令行就要加上- I/myinclude 参数了，如果不加你会得到一个”xxxx.h: No such file or directory”的错 误。-I参数可以用相对路径，比如头文件在当前 目录，可以用-I.来指定。上面我们提到的–cflags参 数就是用来生成-I参数的。 g++ -I/myinclude test.cpp -Wall 打印警告信息 # 打印出gcc提供的警告信息 g++ -Wall test.cpp -w 关闭警告信息 # 关闭所有警告信息 g++ -w test.cpp -std=c++11 设置编译标准 # 使用 c++11 标准编译 test.cpp g++ -std=c++11 test.cpp -o 指定输出文件名 # 指定即将产生的文件名 # 指定输出可执行文件名为test g++ test.cpp -o test -D 定义宏 # 在使用gcc/g++编译的时候定义宏 # 常用场景： # -DDEBUG 定义DEBUG宏，可能文件中有DEBUG宏部分的相关信息，用个DDEBUG来选择开启或关闭 DEBUG g++ test.cpp -DDEBUG -o test ","date":"2022-09-14","objectID":"/posts/gcc%E7%BC%96%E8%AF%91%E5%99%A8/:2:0","tags":["GCC"],"title":"GCC编译器","uri":"/posts/gcc%E7%BC%96%E8%AF%91%E5%99%A8/"},{"categories":["c++"],"content":"3.g++命令编译 . ├── include │ └── say.h ├── main.cpp └── src └── say.cpp 2 directories, 3 files say.h #pragma once //防止重复编译 #include \u003ciostream\u003e #include \u003cstring\u003e class Say { public: Say(std::string name) : name(name) { } void sayHello(); private: std::string name; }; say.cpp #include \"say.h\" void Say::sayHello() { std::cout \u003c\u003c name \u003c\u003c \": say hello!!!\" \u003c\u003c endl; } main.cpp #include \"say.h\" int main(int argc, char **argv) { bool wall = 1; //未使用的变量 Say say(\"cjt\"); say.sayHello(); return 0; } ","date":"2022-09-14","objectID":"/posts/gcc%E7%BC%96%E8%AF%91%E5%99%A8/:3:0","tags":["GCC"],"title":"GCC编译器","uri":"/posts/gcc%E7%BC%96%E8%AF%91%E5%99%A8/"},{"categories":["c++"],"content":"1. 直接编译 编译，生成可执行文件 g++ main.cpp src/say.cpp -Iinclude -o sayHello 增加参数编译，生成可执行文件 g++ main.cpp src/say.cpp -Iinclude -std=c++11 -o2 -Wall -o sayHello ","date":"2022-09-14","objectID":"/posts/gcc%E7%BC%96%E8%AF%91%E5%99%A8/:3:1","tags":["GCC"],"title":"GCC编译器","uri":"/posts/gcc%E7%BC%96%E8%AF%91%E5%99%A8/"},{"categories":["c++"],"content":"2.生成库文件并编译 可参考： C++静态库与动态库 、 C语言静态库VS动态库 静态库VS动态库 静态库和动态库的载入时间是不一样的。 静态库的代码在编译的过程中已经载入到可执行文件中，所以最后生成的可执行文件相对较大。 动态库的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，所以最后生成的可执行文件相对较小。 静态库和动态库的最大区别是，静态库链接的时候把库直接加载到程序中,而动态库链接的时候，它只是保留接口，将动态库与程序代码独立，这样就可以提高代码的可复用度和降低程序的耦合度。 静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。 无论静态库，还是动态库，都是由.o文件创建的。因此，我们必须将源程序.cpp通过g++先编译成.o文件。 1. 链接静态库生成可执行文件 #汇编生成sayHello.o文件 g++ src/say.cpp -Iinclude -c -o sayHello.o #生成静态库libsayHello.o ar rs libsayHello.a sayHello.o #链接，生成可执行文件 main 说明：-L.(静态库的所在目录，.代表当前目录)、 -lsayHello(静态库的名字sayHello) g++ main.cpp -Iinclude -L. -lsayHello -o main #运行可执行文件 ./main 2. 链接动态库生成可执行文件 #生成动态库libsayHello.so g++ src/say.cpp -Iinclude -fPIC -shared -o libsayHello.so #链接，生成可执行文件 main g++ main.cpp -Iinclude -L. -lsayHello -o main #运行可执行文件 说明: 需要指定动态库的路径 LD_LIBRARY_PATH=. ./main ","date":"2022-09-14","objectID":"/posts/gcc%E7%BC%96%E8%AF%91%E5%99%A8/:3:2","tags":["GCC"],"title":"GCC编译器","uri":"/posts/gcc%E7%BC%96%E8%AF%91%E5%99%A8/"},{"categories":["c++"],"content":"前言: GDB(GNU Debugger)是一个用来调试C/C++程序的功能强大的调试器，是Linux系统开发 C/C++最常用的调试器 程序员可以使用GDB来跟踪程序中的错误，从而减少程序员的工作量。 Linux 开发C/C++ 一定要熟悉 GDB VSCode是通过调用GDB调试器来实现C/C++的调试工作的； Windows 系统中，常见的集成开发环境（IDE），如 VS、VC等，它们内部已经嵌套了相应的调试 器 GDB主要功能： 设置断点(断点可以是条件表达式) 使程序在指定的代码行上暂停执行，便于观察 单步执行程序，便于调试 查看程序中变量值的变化 动态改变程序的执行环境 分析崩溃程序产生的core文件 ","date":"2022-09-14","objectID":"/posts/gdb%E8%B0%83%E8%AF%95%E5%99%A8/:0:0","tags":["GDB"],"title":"GDB调试器","uri":"/posts/gdb%E8%B0%83%E8%AF%95%E5%99%A8/"},{"categories":["c++"],"content":"1.常用调试命令参数 调试开始：执行gdb [exefilename]，进入gdb调试程序，其中exefilename为要调试的可执行文件名 ## 以下命令后括号内为命令的简化使用，比如run（r），直接输入命令 r 就代表命令run $(gdb)help(h) # 查看命令帮助，具体命令查询在gdb中输入help + 命令 $(gdb)run(r) # 重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文 件） $(gdb)start # 单步执行，运行程序，停在第一行执行语句 $(gdb)list(l) # 查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函 数） $(gdb)set # 设置变量的值 $(gdb)next(n) # 单步调试（逐过程，函数直接执行） $(gdb)step(s) # 单步调试（逐语句：跳入自定义函数内部执行） $(gdb)backtrace(bt) # 查看函数的调用的栈帧和层级关系 $(gdb)frame(f) # 切换函数的栈帧 $(gdb)info(i) # 查看函数内部局部变量的数值 $(gdb)finish # 结束当前函数，返回到函数调用点 $(gdb)continue(c) # 继续运行 $(gdb)print(p) # 打印值及地址 $(gdb)quit(q) # 退出gdb $(gdb)break+num(b) # 在第num行设置断点 $(gdb)info breakpoints # 查看当前设置的所有断点 $(gdb)delete breakpoints num(d) # 删除第num个断点 $(gdb)display # 追踪查看具体变量值 $(gdb)undisplay # 取消追踪观察变量 $(gdb)watch # 被设置观察点的变量发生修改时，打印显示 $(gdb)i watch # 显示观察点 $(gdb)enable breakpoints # 启用断点 $(gdb)disable breakpoints # 禁用断点 $(gdb)x # 查看内存x/20xw 显示20个单元，16进制，4字节每单元 $(gdb)run argv[1] argv[2] # 调试时命令行传参 $(gdb)set follow-fork-mode child#Makefile项目管理：选择跟踪父子进程（fork() Tips: 编译程序时需要加上-g，之后才能用gdb进行调试：g++ -g main.cpp -o main 回车键：重复上一命令 ","date":"2022-09-14","objectID":"/posts/gdb%E8%B0%83%E8%AF%95%E5%99%A8/:1:0","tags":["GDB"],"title":"GDB调试器","uri":"/posts/gdb%E8%B0%83%E8%AF%95%E5%99%A8/"},{"categories":["Markdown"],"content":"1.标题 # h1 标题 ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 ","date":"2022-09-14","objectID":"/posts/markdown/:1:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"2.注释 \u003c!-- 这是一段注释 --\u003e ","date":"2022-09-14","objectID":"/posts/markdown/:2:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"3.水平线 ___:三个连续的下划线 下面两个警告：MD035/hr-style: Horizontal rule style [Expected: ___; Actual: ---]markdownlintMD035 ---:三个连续的破折号 ***:三个连续的星号 效果如下： ","date":"2022-09-14","objectID":"/posts/markdown/:3:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"4.段落 Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 可以通过两个回车进行换行 ","date":"2022-09-14","objectID":"/posts/markdown/:4:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"5.内联 HTML 元素 ","date":"2022-09-14","objectID":"/posts/markdown/:5:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"6.强调 字符**加粗** 字符*斜体* 字符~~删除线~~ 效果如下： 字符加粗 字符斜体 字符删除线 ","date":"2022-09-14","objectID":"/posts/markdown/:6:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"7.引用 \u003e 引用内容 \u003e\u003e 多层引用 引用内容 多层引用 ","date":"2022-09-14","objectID":"/posts/markdown/:7:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"8.列表 a. 无序列表 * 一项内容 - 一项内容 + 一项内容 效果如下： 1 2 b. 有序列表 1. .... 2. .... 3. .... 效果如下： 1 2 c. 任务列表 任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。 Write the press release Update the website Contact the media ","date":"2022-09-14","objectID":"/posts/markdown/:8:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"9.代码 a.行内代码 c++ `c++` b.缩进代码 line 1 line 2 c.围栏代码块 ","date":"2022-09-14","objectID":"/posts/markdown/:9:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"10.表格 ","date":"2022-09-14","objectID":"/posts/markdown/:10:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"11.链接 ","date":"2022-09-14","objectID":"/posts/markdown/:11:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"a.基本链接 \u003chttps://www.baidu.com\u003e \u003cxxx@xx.com\u003e [百度](https://www.baidu.com) 效果如下： https://www.baidu.com xxx@xx.com 百度 加入鼠标悬浮提示: 百度 ","date":"2022-09-14","objectID":"/posts/markdown/:11:1","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"b.定位标记 ","date":"2022-09-14","objectID":"/posts/markdown/:11:2","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"12.脚注 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2022-09-14","objectID":"/posts/markdown/:12:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"13.图片 ![图片alt](图片链接 \"图片title\")。 ![Minion](https://octodex.github.com/images/minion.png) 或者 ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") Alt text 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚 ","date":"2022-09-14","objectID":"/posts/markdown/:13:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":["Markdown"],"content":"14.首航缩进 全角缩进：\u0026emsp; 半角缩进：\u0026ensp; 这是一个数字脚注 ↩︎ 这是一个带标签的脚 ↩︎ ","date":"2022-09-14","objectID":"/posts/markdown/:14:0","tags":["Markdown"],"title":"Markdown基础语法","uri":"/posts/markdown/"},{"categories":null,"content":"hello ","date":"2022-09-12","objectID":"/posts/first_post/:0:0","tags":null,"title":"First_post","uri":"/posts/first_post/"}]