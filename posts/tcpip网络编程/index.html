<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>TCP/IP网络编程 - vstk的网站</title><meta name="Description" content="This is my cool site"><meta property="og:title" content="TCP/IP网络编程" />
<meta property="og:description" content="1. 理解网络编程和套接字 1.1 套接字概念 在TCP/IP协议中，“IP地址&#43;TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址&#43;端口号”" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cui-jiang-tao.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" />
<meta property="article:published_time" content="2022-10-09T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-10-09T00:00:00+00:00" /><meta property="og:site_name" content="My cool site" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TCP/IP网络编程"/>
<meta name="twitter:description" content="1. 理解网络编程和套接字 1.1 套接字概念 在TCP/IP协议中，“IP地址&#43;TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址&#43;端口号”"/>
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://cui-jiang-tao.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" /><link rel="prev" href="https://cui-jiang-tao.github.io/posts/git/" /><link rel="next" href="https://cui-jiang-tao.github.io/posts/c%E6%A0%87%E5%87%86%E5%BA%93/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "TCP/IP网络编程",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/cui-jiang-tao.github.io\/posts\/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\/"
        },"genre": "posts","keywords": "c\/c\x2b\x2b","wordcount":  10888 ,
        "url": "https:\/\/cui-jiang-tao.github.io\/posts\/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\/","datePublished": "2022-10-09T00:00:00+00:00","dateModified": "2022-10-09T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "cjt"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="vstk的网站"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="vstk的网站"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">TCP/IP网络编程</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>cjt</a></span>&nbsp;<span class="post-category">included in <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>网络编程</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-10-09">2022-10-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;10888 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;22 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-理解网络编程和套接字">1. 理解网络编程和套接字</a>
      <ul>
        <li><a href="#11-套接字概念">1.1 套接字概念</a></li>
        <li><a href="#12-网络编程和套接字">1.2 网络编程和套接字</a></li>
        <li><a href="#13-基于linux的文件操作">1.3 基于Linux的文件操作</a></li>
      </ul>
    </li>
    <li><a href="#2-地址族与数据序列">2. 地址族与数据序列</a>
      <ul>
        <li><a href="#21-网络地址internet-address">2.1 网络地址(Internet Address)</a></li>
        <li><a href="#22-网络字节序与地址转换">2.2 网络字节序与地址转换</a></li>
      </ul>
    </li>
    <li><a href="#3-基于tcp的服务端客户端">3. 基于TCP的服务端/客户端</a>
      <ul>
        <li><a href="#31-缺陷的echo版本">3.1 缺陷的echo版本</a></li>
        <li><a href="#32-简易的echo版本">3.2 简易的echo版本</a></li>
        <li><a href="#33-简单的操作运算">3.3 简单的操作运算</a></li>
        <li><a href="#34-tcp原理">3.4 TCP原理</a></li>
      </ul>
    </li>
    <li><a href="#4-基于udp的服务器端客户端">4. 基于UDP的服务器端/客户端</a></li>
    <li><a href="#5-优雅地断开套接字连接">5. 优雅地断开套接字连接</a>
      <ul>
        <li><a href="#51-套接字和流stream">5.1 套接字和流(Stream)</a></li>
        <li><a href="#52-shutdown函数">5.2 shutdown函数</a></li>
        <li><a href="#53-基于半关闭的文件传输程序">5.3 基于半关闭的文件传输程序</a></li>
      </ul>
    </li>
    <li><a href="#6-域名及网络地址">6. 域名及网络地址</a></li>
    <li><a href="#7-套接字的多种可选项">7. 套接字的多种可选项</a></li>
    <li><a href="#8-多进程服务器端">8. 多进程服务器端</a></li>
    <li><a href="#9-进程间通信">9. 进程间通信</a></li>
    <li><a href="#10-io复用">10. I/O复用</a>
      <ul>
        <li><a href="#101-select函数">10.1 select函数</a></li>
        <li><a href="#102-基于select的io复用实例">10.2 基于select的I/O复用实例</a></li>
      </ul>
    </li>
    <li><a href="#11-多种io函数">11. 多种I/O函数</a></li>
    <li><a href="#12-多播与广播">12. 多播与广播</a></li>
    <li><a href="#13-套接字和标准io">13. 套接字和标准I/O</a>
      <ul>
        <li><a href="#131-标准io函数">13.1 标准I/O函数</a></li>
        <li><a href="#132-基于套接字的标准io函数使用">13.2 基于套接字的标准I/O函数使用</a></li>
      </ul>
    </li>
    <li><a href="#14-分离io流">14. 分离I/O流</a>
      <ul>
        <li><a href="#141-文件描述符的复制和半关闭">14.1 文件描述符的复制和半关闭</a></li>
      </ul>
    </li>
    <li><a href="#15-优于select的epoll">15. 优于select的epoll</a></li>
    <li><a href="#16-多线程服务器端的实现">16. 多线程服务器端的实现</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="1-理解网络编程和套接字">1. 理解网络编程和套接字</h2>
<h3 id="11-套接字概念">1.1 套接字概念</h3>
<p>在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p>
<p>套接字通信原理如下图所示：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/socket/0.1.png"
        data-srcset="../../imgs/socket/0.1.png, ../../imgs/socket/0.1.png 1.5x, ../../imgs/socket/0.1.png 2x"
        data-sizes="auto"
        alt="../../imgs/socket/0.1.png"
        title="套接字通信原理图" /></p>
<p>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应另一端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。</p>
<h3 id="12-网络编程和套接字">1.2 网络编程和套接字</h3>
<p>IP是Internet Protocol(网络协议)的简写，是为了收发网络数据而分配给计算机的值。端口号并非赋予计算机的值，而是为了区分程序中创建的套接字而分配给套接字的序号。</p>
<h4 id="121-socket函数">1.2.1 socket函数</h4>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">socket</span> <span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span>
</code></pre></div><p>调用socket函数，成功返回文件描述符，失败返回-1。</p>
<ul>
<li>domain：套接字中使用的协议族(Protocol Family)信息。一般使用 <code>PF_INET</code> IPv4互联网协议族。</li>
<li>type： 套接字数据传输类型信息。一般使用 <code>SOCK_STREAM</code> 面向连接的套接字。</li>
<li>protocol：计算机通信中使用的协议信息。一般为 <code>0</code>。</li>
</ul>
<p>头文件sys/socket.h中声明的协议族：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">协议族</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">PF_INET</td>
<td align="center">IPv4互联网协议族</td>
</tr>
<tr>
<td align="left">PF_INET6</td>
<td align="center">IPv6互联网协议族</td>
</tr>
<tr>
<td align="left">PF_LOCAL</td>
<td align="center">本地通信的UNIX协议族</td>
</tr>
<tr>
<td align="left">PE_PACKET</td>
<td align="center">底层套接字的协议族</td>
</tr>
<tr>
<td align="left">PF_IPX</td>
<td align="center">IPX Novell协议族</td>
</tr>
</tbody>
</table>
<p>套接字类型:</p>
<ol>
<li>
<p>面向连接的套接字(SOCK_STREAM)</p>
<ul>
<li>传输过程中数据不会消失；</li>
<li>按序传输数据</li>
<li>传输的数据不存在数据边界(Boundary)</li>
</ul>
<blockquote>
<p>可靠的、按序列传递的、基于字节的面向连接的数据传输方式的套接字。</p>
</blockquote>
</li>
<li>
<p>面向消息的套接字(SOCK_DGRAM)</p>
<ul>
<li>强调快速传输而非传输顺序。</li>
<li>传输的数据可能丢失，也可能被销毁。</li>
<li>传输的数据有边界。</li>
<li>限制每次传输的数据大小。</li>
</ul>
<blockquote>
<p>不可靠的、不按序传递的，以数据的高速传输为目的的套接字</p>
</blockquote>
</li>
</ol>
<h4 id="122-bind函数">1.2.2 bind函数</h4>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">bind</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">myaddr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
</code></pre></div><p>调用bind函数，成功返回0，失败返回-1。若此函数调用成功，则将第二个参数指定的地址信息分配给第一个参数中的相应套接字。</p>
<ul>
<li>sockfd：要分配地址信息(IP地址和端口号)的套接字文件描述符。</li>
<li>myaddr：存有地址信息的结构体变量地址值。</li>
<li>addrlen：第二个结构体变量的长度。</li>
</ul>
<h4 id="123-listen函数">1.2.3 listen函数</h4>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>
</code></pre></div><p>调用listen函数，成功返回0，失败返回-1。</p>
<ul>
<li>sock：希望进入等待请求状态的套接字文件描述符，传递的描述符套接字成为服务器端套接字(监听套接字)。</li>
<li>backlog：连接请求等待队列(Queue)的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列。</li>
</ul>
<h4 id="124-accept函数">1.2.4 accept函数</h4>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span>
</code></pre></div><p>调用accept函数，成功返回文件描述符，失败返回-1。</p>
<ul>
<li>sock：服务器套接字的文件描述符。</li>
<li>addr：保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息。</li>
<li>addrlen：第二个参数addr结构体的长度，但是存有长度的变量地址。就是该函数调用完成后，该变量即被填入客户端地址长度。</li>
</ul>
<p>accept函数受理连接请求等待队列中待处理的客户端连接请求。函数调用成功时，accept函数内部将产生用于数据I/O的套接字，并返回其文件描述符。需要强调的是，套接字是自动创建的，并自动与发起连接请求的客户端建立连接。</p>
<h4 id="125-connect函数">1.2.5 connect函数</h4>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">.</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">serv_addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
</code></pre></div><p>调用connect函数，成功返回0，失败返回-1。</p>
<ul>
<li>sock：客户端套接字文件描述符。</li>
<li>serv_addr：保存目标服务器端地址信息的变量地址值。</li>
<li>addrlen：以字节为单位传递已传递给第二个结构体参数serv_addr的地址变量长度。</li>
</ul>
<p>客户端调用connect函数后，发生以下情况之一才会返回(完成函数调用)。</p>
<ul>
<li>服务器端接收连接请求。</li>
<li>发生断网等异常情况而中断连接请求。</li>
</ul>
<blockquote>
<p>所谓的&quot;接收连接&quot;并不意味着服务器端调用accept函数，其实是服务器端把连接请求信息记录到等待队列。因此connect函数返回后并不立即进行数据交换。</p>
</blockquote>
<p>基于TCP的服务端/客户端函数调用关系：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/socket/4.10.png"
        data-srcset="../../imgs/socket/4.10.png, ../../imgs/socket/4.10.png 1.5x, ../../imgs/socket/4.10.png 2x"
        data-sizes="auto"
        alt="../../imgs/socket/4.10.png"
        title="函数调用关系" /></p>
<h4 id="126-编写hello-world程序">1.2.6 编写Hello world程序</h4>
<p>hello_client.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_addr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">str_len</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">3</span><span class="p">){</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage : %s &lt;IP&gt; &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="c1">//客户端创建一个和服务端建立连接的套接字
</span><span class="c1"></span>	<span class="n">sock</span><span class="o">=</span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">sock</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;socket() error&#34;</span><span class="p">);</span>
	
	<span class="c1">//设置描述的地址和端口号
</span><span class="c1"></span>	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">));</span>
	<span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">inet_addr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>

	<span class="c1">//与服务端建立连接，三次握手
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> 
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;connect() error!&#34;</span><span class="p">);</span>
	
	<span class="c1">//阻塞，从服务端读取数据
</span><span class="c1"></span>	<span class="n">str_len</span><span class="o">=</span><span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">str_len</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;read() error!&#34;</span><span class="p">);</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Message from server: %s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>  

	<span class="c1">//断开与客户端的连接，四次挥手
</span><span class="c1"></span>	<span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>hello_server.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">serv_sock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">clnt_sock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">clnt_addr</span><span class="p">;</span>
	<span class="n">socklen_t</span> <span class="n">clnt_addr_size</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">message</span><span class="p">[]</span><span class="o">=</span><span class="s">&#34;Hello World!&#34;</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">2</span><span class="p">){</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage : %s &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="c1">//创建服务端socket，通过serv_sock创建与客户端连接的socket
</span><span class="c1"></span>	<span class="n">serv_sock</span><span class="o">=</span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">serv_sock</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;socket() error&#34;</span><span class="p">);</span>
	
	<span class="c1">//设置描述的地址和端口号
</span><span class="c1"></span>	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">));</span>
	<span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
	<span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
	
	<span class="c1">//将socket_fd 和serv_addr进行绑定
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span> <span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;bind() error&#34;</span><span class="p">);</span> 
	
	<span class="c1">//设置排队建立3次握手队列和刚刚建立3次握手队列的连接上限和
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;listen() error&#34;</span><span class="p">);</span>
	
	<span class="c1">//阻塞，与客户端建立连接，三次握手 =》 client_fd
</span><span class="c1"></span>	<span class="n">clnt_addr_size</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clnt_addr</span><span class="p">);</span>  
	<span class="n">clnt_sock</span><span class="o">=</span><span class="n">accept</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clnt_addr</span><span class="p">,</span><span class="o">&amp;</span><span class="n">clnt_addr_size</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">clnt_sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;accept() error&#34;</span><span class="p">);</span>  
	
	<span class="c1">//给clnt_sock客户连接发送数据
</span><span class="c1"></span>	<span class="n">write</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>

	<span class="c1">//关闭连接，close fd
</span><span class="c1"></span>	<span class="n">close</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">);</span>	
	<span class="n">close</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//将错误信息写入到标准错误流
</span><span class="c1"></span>	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id="13-基于linux的文件操作">1.3 基于Linux的文件操作</h3>
<p>在Linux中，socket也被认为是文件的一种，因此在网络传输过程中可以使用文件I/O的相关函数。</p>
<p>文件描述符是系统分配给文件或套接字的一个整数。每当生成文件或套接字，操作系统将返回分配给它们的整数，这个整数将成为程序员与操作系统之间良好沟通的渠道。实际上，文件描述符只不过是未来方便称呼操作系统创建的文件或套接字而赋予的数值而已。</p>
<p>标准输入输入及错误的文件描述符：</p>
<table>
<thead>
<tr>
<th align="left">文件描述符</th>
<th align="center">对象</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">0</td>
<td align="center">标准输入: Standard Input</td>
</tr>
<tr>
<td align="left">1</td>
<td align="center">标准输出: Standard Output</td>
</tr>
<tr>
<td align="left">2</td>
<td align="center">标准错误: Standard Error</td>
</tr>
</tbody>
</table>
<p>文件和套接字一般经过创建过程才会被分配文件描述符。而上述对象即使未经过特殊的创建过程，程序开始运行后也会被自动分配文件描述符。</p>
<h4 id="131-open函数">1.3.1 open函数</h4>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
</code></pre></div><p>调用open函数，成功时返回文件描述符，失败返回-1。</p>
<ul>
<li>path：文件名的字符串地址。</li>
<li>flag：文件打开的模式信息。</li>
</ul>
<p>文件打开模式：</p>
<table>
<thead>
<tr>
<th align="left">打开模式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">O_CREAT</td>
<td align="center">必要时创建文件</td>
</tr>
<tr>
<td align="left">O_TRUNC</td>
<td align="center">删除全部现有数据</td>
</tr>
<tr>
<td align="left">O_APPEND</td>
<td align="center">维持现有数据，保存到其后面</td>
</tr>
<tr>
<td align="left">O_RDONLY</td>
<td align="center">只读打开</td>
</tr>
<tr>
<td align="left">O_WRONLY</td>
<td align="center">只写打开</td>
</tr>
<tr>
<td align="left">ORDWR</td>
<td align="center">读写打开</td>
</tr>
</tbody>
</table>
<h4 id="132-close函数">1.3.2 close函数</h4>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
</code></pre></div><p>调用close函数，成功返回0，失败返回-1。</p>
<ul>
<li>fd：需要关闭的文件或套接字的文件描述符。</li>
</ul>
<h4 id="133-write函数">1.3.3 write函数</h4>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">nbytes</span><span class="p">);</span>
</code></pre></div><p>调用write函数，成功时返回写入的字节数，失败返回-1。</p>
<ul>
<li>fd：数据传输对象的文件描述符</li>
<li>buf：要传输数据的起始地址</li>
<li>nbytes：要传输数据的字节数</li>
</ul>
<h4 id="134-read函数">1.3.4 read函数</h4>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">nbytes</span><span class="p">);</span>
</code></pre></div><p>调用read函数，成功时返回接收的字节数(<strong>但遇到文件结尾则返回0</strong>)，失败时返回-1。</p>
<ul>
<li>fd：数据接收对象的文件描述符</li>
<li>buf：要接收数据的起始地址</li>
<li>nbytes：要接收数据的最大字节数</li>
</ul>
<h2 id="2-地址族与数据序列">2. 地址族与数据序列</h2>
<p>端口号就是在同一操作系统内为区分不同套接字而设置的，因此无法将1个端口号分配给不同的套接字。总之，数据传输目标地址同时包含IP地址和端口号，只有这样，数据才会被传输到最终的目的应用程序(应用程序套接字)。</p>
<h3 id="21-网络地址internet-address">2.1 网络地址(Internet Address)</h3>
<p>为使计算机连接到网络并收发数据，必须向其分配IP地址。IP地址分为两类。</p>
<ul>
<li>IPv4(Internet Protocol version 4)		4字节地址族</li>
<li>IPv6(Internet Protocol version 6)		6字节地址族</li>
</ul>
<p>IPv4地址的结构体</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="p">{</span>
	<span class="n">sa_family_t</span> <span class="n">sin_family</span><span class="p">;</span>	<span class="c1">//地址族(Address Family)
</span><span class="c1"></span>	<span class="n">uint16_t</span> <span class="n">sin_port</span><span class="p">;</span>	<span class="c1">//16位TCP/UDP端口号
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span>	<span class="c1">//32位IP地址
</span><span class="c1"></span>	<span class="kt">char</span> <span class="n">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="c1">//不使用，设置为0
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><code>sockaddr_in</code>结构体中的另一个结构体struct in_addr，它是用来存放32位的IP地址</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">in_addr</span> <span class="p">{</span>
	<span class="n">In_addr_t</span> <span class="n">s_addr</span><span class="p">;</span>	<span class="c1">//32位IPv4的地址
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>结构体sockaddr_in的成员分析：</p>
<ol>
<li>
<p>成员sin_family</p>
<table>
<thead>
<tr>
<th align="left">地址族(Address Family)</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">AF_INET</td>
<td align="center">IPv4网络协议中使用的地址族</td>
</tr>
<tr>
<td align="left">AF_INET6</td>
<td align="center">IPv6网络协议中使用的地址族</td>
</tr>
<tr>
<td align="left">AF_LOCAL</td>
<td align="center">本地通信中采用的UNIX协议的地址族</td>
</tr>
</tbody>
</table>
<blockquote>
<p>AF_LOCAL只是为了说明具有多种地址族而添加的。</p>
</blockquote>
</li>
<li>
<p>成员sin_port</p>
<p>该成员保存16位端口号，<strong>它以网络字节序保存</strong>。</p>
</li>
<li>
<p>成员sin_addr</p>
<p>该成员保存32位IP地址信息，<strong>它以网络字节序保存</strong>。</p>
</li>
<li>
<p>成员sin_zero</p>
<p>无特殊含义。只是为了使用结构体sockaddr_in的大小与sockaddr结构体保持一致而插入的成员。<strong>必须填充为0，否则无法得到想要的结果。</strong></p>
</li>
</ol>
<p>bind函数的第二个参数期望得到sockaddr结构体变量地址值，包括地址族、端口号、IP地址等。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">sockaddr</span> <span class="p">{</span>
	<span class="n">sa_family_t</span> <span class="n">sin_family</span><span class="p">;</span>	<span class="c1">//地址族(Address Family)
</span><span class="c1"></span>	<span class="kt">char</span> <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>	<span class="c1">//地址信息
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>此结构体成员sa_data保存的地址信息中需包含IP地址和端口号，剩余部分应该填充为0，这也是bind函数要求的。而对于包含地址信息来讲非常麻烦，继而就有了新的结构体sockaddr_in。</p>
<h3 id="22-网络字节序与地址转换">2.2 网络字节序与地址转换</h3>
<p>CPU向内存保存数据的方式有两种，这意味着CPU解析数据的方式也分为两种。</p>
<ul>
<li>大端序(Big Endian)：高位字节存放地位地址。<strong>网络字节序(Network Byte Order)，统一为大端序。</strong></li>
<li>小端序(Little Endian)：高位字节存放到高位地址。<strong>主机字节序一般采取的形式。</strong></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">int n = 0x12345678;

小端存储：78 56 34 12
大端存储：12 34 56 78
</code></pre></div><p>转换字节序的函数：</p>
<ul>
<li><code>unsigned short htons(unsigned short);</code> 把short型数据从主机字节序转换为网络字节序。</li>
<li><code>unsigned short ntohs(unsigned short);</code> 把short型数据从网络字节序转换为主机字节序。</li>
<li><code>unsigned long htonl(unsigned short);</code>  把long型数据从主机字节序转换为网络字节序。</li>
<li><code>unsigned long ntohl(unsigned short);</code>  把long型数据从网络字节序转换为主机字节序。</li>
</ul>
<p>通过函数名可以了解其功能：</p>
<ul>
<li>函数名中的h代表主机(host)字节序。</li>
<li>函数名中的n代表网络(network)字节序。</li>
<li>函数名中的s指的是short。</li>
<li>函数名中的l指的是long。(Linux中的long类型占用4个字节)</li>
</ul>
<p>小端运行环境的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">host_port</span><span class="o">=</span><span class="mh">0x1234</span><span class="p">;</span> <span class="c1">//该值按照小端的方式进行存储
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">net_port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">host_addr</span><span class="o">=</span><span class="mh">0x12345678</span><span class="p">;</span> <span class="c1">//该值按照小端的方式进行存储
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">net_addr</span><span class="p">;</span>
	
	<span class="n">net_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">host_port</span><span class="p">);</span>
	<span class="n">net_addr</span><span class="o">=</span><span class="n">htonl</span><span class="p">(</span><span class="n">host_addr</span><span class="p">);</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Host ordered port: %#x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">host_port</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Network ordered port: %#x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">net_port</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Host ordered address: %#lx </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">host_addr</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Network ordered address: %#lx </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">net_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>对于IP地址的表示，我们熟悉的是点分十进制表示法(Dotted Decimal Notation)，而非整数型数据的表示法。</p>
<p>通过inet_addr函数，我们可以将字符串式的IP地址转换为32位整数型数据，而且可以检测无效的IP地址。<strong>此函数在转换类型的同时进行网络字节序的转换。</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">in_add_t</span> <span class="nf">inet_addr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">);</span>
</code></pre></div><p>调用<code>inet_addr</code>函数，成功返回32位<strong>大端序整数型值</strong>，失败时返回INADDR_NONE。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addr1</span><span class="o">=</span><span class="s">&#34;127.212.124.78&#34;</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addr2</span><span class="o">=</span><span class="s">&#34;127.212.124.256&#34;</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">conv_addr</span><span class="o">=</span><span class="n">inet_addr</span><span class="p">(</span><span class="n">addr1</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">conv_addr</span><span class="o">==</span><span class="n">INADDR_NONE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error occured! </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Network ordered integer addr: %#lx </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">conv_addr</span><span class="p">);</span>
	
	<span class="n">conv_addr</span><span class="o">=</span><span class="n">inet_addr</span><span class="p">(</span><span class="n">addr2</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">conv_addr</span><span class="o">==</span><span class="n">INADDR_NONE</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error occureded </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Network ordered integer addr: %#lx </span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">conv_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>inet_aton函数与inet_addr函数功能是一样的，只不过该函数利用了in_addr结构体，且使用频率更高。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">inet_aton</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
</code></pre></div><p>调用inet_aton函数，成功返回1，失败返回0。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="o">=</span><span class="s">&#34;127.232.124.79&#34;</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr_inet</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">inet_aton</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_inet</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">))</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;Conversion error&#34;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Network ordered integer addr: %#x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">addr_inet</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>inet_ntoa函数可以把网络字节序整数型IP地址转换成我们熟悉的字符串形式。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">char</span> <span class="o">*</span> <span class="nf">inet_ntoa</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span> <span class="n">adr</span><span class="p">);</span>
</code></pre></div><p>调用inet_ntoa函数，成功时返回转换的字符串地址值，失败时返回-1。</p>
<blockquote>
<p>该函数的返回类型为char指针，意味着调用该函数会在内部申请了内存并保存了这个字符串。所以调用完该函数，应立即将字符串内容复制保存起来，因为下次调用inet_ntoa函数，则有可能覆盖之前保存的字符串信息。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr1</span><span class="p">,</span> <span class="n">addr2</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str_ptr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">str_arr</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
   
	<span class="n">addr1</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">htonl</span><span class="p">(</span><span class="mh">0x1020304</span><span class="p">);</span>
	<span class="n">addr2</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">htonl</span><span class="p">(</span><span class="mh">0x1010101</span><span class="p">);</span>
	
	<span class="n">str_ptr</span><span class="o">=</span><span class="n">inet_ntoa</span><span class="p">(</span><span class="n">addr1</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">str_arr</span><span class="p">,</span> <span class="n">str_ptr</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Dotted-Decimal notation1: %s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">str_ptr</span><span class="p">);</span>
	
	<span class="n">inet_ntoa</span><span class="p">(</span><span class="n">addr2</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Dotted-Decimal notation2: %s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">str_ptr</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Dotted-Decimal notation3: %s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">str_arr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">root@com:/home/swyoon/tcpip# gcc inet_ntoa.c -o ntoa
</span><span class="cm">root@com:/home/swyoon/tcpip# ./ntoa
</span><span class="cm">Dotted-Decimal notation1: 1.2.3.4 
</span><span class="cm">Dotted-Decimal notation2: 1.1.1.1 
</span><span class="cm">Dotted-Decimal notation3: 1.2.3.4 
</span><span class="cm">
</span><span class="cm">*/</span>
</code></pre></div><p>网络地址初始化</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>

<span class="kt">char</span> <span class="o">*</span><span class="n">serv_ip</span> <span class="o">=</span> <span class="s">&#34;127.0.0.1&#34;</span><span class="p">;</span>	<span class="c1">//声明IP地址字符串
</span><span class="c1"></span><span class="kt">char</span> <span class="o">*</span><span class="n">ser_port</span> <span class="o">=</span> <span class="s">&#34;9190&#34;</span><span class="p">;</span>	<span class="c1">//声明端口号字符串
</span><span class="c1"></span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>	<span class="err">结构体变量</span><span class="n">addr的所有成员初始化为0</span>
<span class="n">addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>	<span class="c1">//指定IPv4协议族
</span><span class="c1"></span><span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="n">serv_ip</span><span class="p">);</span>	<span class="c1">//基于字符串的IP地址初始化
</span><span class="c1"></span><span class="n">addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">serv_port</span><span class="p">));</span>	<span class="c1">//基于字符串的端口号初始化
</span></code></pre></div><p>每次创建服务端套接字都要输入IP地址，可以利用<code>INADDR_ANY</code>分配服务端的IP地址。采用这种方式，则可以自动获取服务端的计算机IP地址。</p>
<p><code>addr.sin_addr.s_addr = htonl(INADDR_ANY);</code></p>
<h2 id="3-基于tcp的服务端客户端">3. 基于TCP的服务端/客户端</h2>
<h3 id="31-缺陷的echo版本">3.1 缺陷的echo版本</h3>
<p>echo_server.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 1024
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">serv_sock</span><span class="p">,</span> <span class="n">clnt_sock</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">str_len</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_adr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">clnt_adr</span><span class="p">;</span>
	<span class="n">socklen_t</span> <span class="n">clnt_adr_sz</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage : %s &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">serv_sock</span><span class="o">=</span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
	<span class="k">if</span><span class="p">(</span><span class="n">serv_sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;socket() error&#34;</span><span class="p">);</span>
	
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

	<span class="k">if</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;bind() error&#34;</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;listen() error&#34;</span><span class="p">);</span>
	
	<span class="n">clnt_adr_sz</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clnt_adr</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">clnt_sock</span><span class="o">=</span><span class="n">accept</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clnt_adr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clnt_adr_sz</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">clnt_sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;accept() error&#34;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Connected client %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	
		<span class="c1">//接收客户端的数据，然后再原封不动的发回给客户端
</span><span class="c1"></span>		<span class="k">while</span><span class="p">((</span><span class="n">str_len</span><span class="o">=</span><span class="n">read</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">))</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">write</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">str_len</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">close</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">close</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>echo_cilent.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 1024
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sock</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">str_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_adr</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage : %s &lt;IP&gt; &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">sock</span><span class="o">=</span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
	<span class="k">if</span><span class="p">(</span><span class="n">sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;socket() error&#34;</span><span class="p">);</span>
	
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">inet_addr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;connect() error!&#34;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">puts</span><span class="p">(</span><span class="s">&#34;Connected...........&#34;</span><span class="p">);</span>
	
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">fputs</span><span class="p">(</span><span class="s">&#34;Input message(Q to quit): &#34;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
		<span class="n">fgets</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
		
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="s">&#34;q</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="s">&#34;Q</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="c1">//发生数据给服务端
</span><span class="c1"></span>		<span class="n">write</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>

		<span class="c1">//阻塞接收服务端的数据
</span><span class="c1"></span>		<span class="n">str_len</span><span class="o">=</span><span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">message</span><span class="p">[</span><span class="n">str_len</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Message from server: %s&#34;</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>上面的程序存在很大的问题，因为TCP是基于流的，但保证数据能够完整的传输。write函数的调用只是把数据放入到发送缓冲区中，至于何时发送，发送大小是多少，这些都是不确定的；read函数从接收缓存区中拿数据，每次能拿多少也是不确定的。</p>
<h3 id="32-简易的echo版本">3.2 简易的echo版本</h3>
<p>在收发数据过程中，我们可以简单规范一下应用层协议：每发送一次数据，都在数据前4字节存放数据的大小，这样接收端就能明确的知道每次的接收数据的大小。</p>
<p>echo_server.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 1024
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">serv_sock</span><span class="p">,</span> <span class="n">clnt_sock</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">str_len</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_adr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">clnt_adr</span><span class="p">;</span>
	<span class="n">socklen_t</span> <span class="n">clnt_adr_sz</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage : %s &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">serv_sock</span><span class="o">=</span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
	<span class="k">if</span><span class="p">(</span><span class="n">serv_sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;socket() error&#34;</span><span class="p">);</span>
	
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

	<span class="k">if</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;bind() error&#34;</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;listen() error&#34;</span><span class="p">);</span>
	
	<span class="n">clnt_adr_sz</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clnt_adr</span><span class="p">);</span>

	<span class="c1">//没开启多线程，只处理一个客户端；可以通过one loop思想处理多个客户
</span><span class="c1"></span>	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">clnt_sock</span><span class="o">=</span><span class="n">accept</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clnt_adr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clnt_adr_sz</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">clnt_sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;accept() error&#34;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Connected client %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">++</span><span class="n">i</span><span class="p">);</span>
	
		<span class="kt">int</span> <span class="n">quit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">quit</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//接收客户端的数据，然后再原封不动的发回给客户端
</span><span class="c1"></span>
			<span class="c1">//先接受数据的长度
</span><span class="c1"></span>			<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">while</span><span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">,</span> <span class="n">message</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">size</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;read() error!&#34;</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">quit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				
				<span class="n">size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="kt">int</span> <span class="n">str_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">message</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">message</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">message</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">message</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="c1">// printf(&#34;%d %d %d %d\n&#34;, message[0],message[1],message[2],message[3]);
</span><span class="c1"></span>			<span class="c1">// printf(&#34;%d\n&#34;, str_size);
</span><span class="c1"></span>			<span class="n">str_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">while</span><span class="p">(</span><span class="n">str_len</span> <span class="o">!=</span> <span class="n">str_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">,</span> <span class="n">message</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span> <span class="n">str_len</span><span class="p">,</span> <span class="n">str_size</span> <span class="o">-</span> <span class="n">str_len</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;read() error!&#34;</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">quit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				
				<span class="n">str_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">quit</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">write</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">str_size</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>

				<span class="n">message</span><span class="p">[</span><span class="n">str_size</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Send Message to client(%d): %s&#34;</span><span class="p">,</span> <span class="n">clnt_sock</span><span class="p">,</span> <span class="n">message</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">close</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">close</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>echo_cilent.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 1024
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sock</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">str_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_adr</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage : %s &lt;IP&gt; &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">sock</span><span class="o">=</span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
	<span class="k">if</span><span class="p">(</span><span class="n">sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;socket() error&#34;</span><span class="p">);</span>
	
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">inet_addr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;connect() error!&#34;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">puts</span><span class="p">(</span><span class="s">&#34;Connected...........&#34;</span><span class="p">);</span>
	
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fputs</span><span class="p">(</span><span class="s">&#34;Input message(Q to quit): &#34;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
		<span class="n">fgets</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">BUF_SIZE</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
		
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span><span class="s">&#34;q</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span><span class="s">&#34;Q</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="c1">// *((int *)message) = strlen(message + 4);
</span><span class="c1"></span>
		<span class="kt">int</span> <span class="n">message_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">message</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">message_len</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
		<span class="n">message</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">message_len</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
		<span class="n">message</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">message_len</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
		<span class="n">message</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">message_len</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
		
		<span class="c1">//发生数据给服务端
</span><span class="c1"></span>		<span class="n">write</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">message_len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>

		<span class="c1">// printf(&#34;%d %d %d %d\n&#34;, message[0],message[1],message[2],message[3]);
</span><span class="c1"></span>		<span class="c1">// printf(&#34;%s\n&#34;, message + 4);
</span><span class="c1"></span>
		<span class="c1">//先接收客户端一次发送的数据长度
</span><span class="c1"></span>		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">message</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">size</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;read() error!&#34;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="kt">int</span> <span class="n">str_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">message</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">message</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">message</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">message</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">str_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">str_len</span> <span class="o">!=</span> <span class="n">str_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">message</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span> <span class="n">str_len</span><span class="p">,</span> <span class="n">str_size</span> <span class="o">-</span> <span class="n">str_len</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;read() error!&#34;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">str_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="n">message</span><span class="p">[</span><span class="n">str_size</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Message from server: %s&#34;</span><span class="p">,</span> <span class="n">message</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>注意：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//当发生异常情况，去读数据过程中str_len超出str_size，此时就无法退出循环
</span><span class="c1"></span><span class="k">while</span><span class="p">(</span><span class="n">str_len</span> <span class="o">!=</span> <span class="n">str_size</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">...</span>
<span class="p">}</span>

<span class="c1">//最好这样
</span><span class="c1"></span><span class="k">while</span><span class="p">(</span><span class="n">str_len</span> <span class="o">&lt;</span> <span class="n">str_size</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div><h3 id="33-简单的操作运算">3.3 简单的操作运算</h3>
<ul>
<li>客户端连接到服务端后以1字节整数形式转递待算数个数。</li>
<li>客户端向服务器端传递的每个整数型数据占用4个字节空间。</li>
<li>传递整数型数据后接着传递运算符。运算符信息占用1字节。</li>
<li>目前支持操作符：+、-、*。</li>
<li>服务端以4个字节整数型向客户端传回运算结果。</li>
<li>客户端得到运算结果后终止与服务端的连接。</li>
</ul>
<blockquote>
<p>调用close函数将向对方传递EOF。</p>
</blockquote>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/socket/3.3.png"
        data-srcset="../../imgs/socket/3.3.png, ../../imgs/socket/3.3.png 1.5x, ../../imgs/socket/3.3.png 2x"
        data-sizes="auto"
        alt="../../imgs/socket/3.3.png"
        title="套接字通信原理图" /></p>
<p>op_client.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 1024
</span><span class="cp">#define RLT_SIZE 4
</span><span class="cp">#define OPSZ 4
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sock</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">opmsg</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">opnd_cnt</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_adr</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage : %s &lt;IP&gt; &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">sock</span><span class="o">=</span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
	<span class="k">if</span><span class="p">(</span><span class="n">sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;socket() error&#34;</span><span class="p">);</span>
	
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">inet_addr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;connect() error!&#34;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">puts</span><span class="p">(</span><span class="s">&#34;Connected...........&#34;</span><span class="p">);</span>

	<span class="n">fputs</span><span class="p">(</span><span class="s">&#34;Operand count: &#34;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opnd_cnt</span><span class="p">);</span>
	<span class="n">opmsg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">opnd_cnt</span><span class="p">;</span><span class="c1">//先获得操作数的个数
</span><span class="c1"></span>	
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">opnd_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Operand %d: &#34;</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">opmsg</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">OPSZ</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span><span class="c1">//保存操作数
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="n">fgetc</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span><span class="c1">//删掉缓冲中的字符 =》 scanf函数产生的
</span><span class="c1"></span>
	<span class="n">fputs</span><span class="p">(</span><span class="s">&#34;Operator: &#34;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opmsg</span><span class="p">[</span><span class="n">opnd_cnt</span><span class="o">*</span><span class="n">OPSZ</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span><span class="c1">//获取操作符
</span><span class="c1"></span>	<span class="n">write</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">opmsg</span><span class="p">,</span> <span class="n">opnd_cnt</span><span class="o">*</span><span class="n">OPSZ</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>

	<span class="c1">//获取服务端计算的结果(4字节)
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">RLT_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">result</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">RLT_SIZE</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Operation result: %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>op_server.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 1024
</span><span class="cp">#define OPSZ 4
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">calculate</span><span class="p">(</span><span class="kt">int</span> <span class="n">opnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opnds</span><span class="p">[],</span> <span class="kt">char</span> <span class="n">oprator</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">serv_sock</span><span class="p">,</span> <span class="n">clnt_sock</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">opinfo</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">opnd_cnt</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">recv_cnt</span><span class="p">,</span> <span class="n">recv_len</span><span class="p">;</span>	
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_adr</span><span class="p">,</span> <span class="n">clnt_adr</span><span class="p">;</span>
	<span class="n">socklen_t</span> <span class="n">clnt_adr_sz</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage : %s &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">serv_sock</span><span class="o">=</span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
	<span class="k">if</span><span class="p">(</span><span class="n">serv_sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;socket() error&#34;</span><span class="p">);</span>
	
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

	<span class="k">if</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;bind() error&#34;</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;listen() error&#34;</span><span class="p">);</span>	
	<span class="n">clnt_adr_sz</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clnt_adr</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">clnt_sock</span><span class="o">=</span><span class="n">accept</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clnt_adr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clnt_adr_sz</span><span class="p">);</span>	
		
		<span class="c1">//先获取操作数的数量
</span><span class="c1"></span>		<span class="n">opnd_cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">opnd_cnt</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">//获取全部数据
</span><span class="c1"></span>		<span class="n">recv_len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">while</span><span class="p">((</span><span class="n">opnd_cnt</span><span class="o">*</span><span class="n">OPSZ</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="n">recv_len</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">//BUF_SIZE - recv_len - 1: 因为操作符已经占用一个字节了
</span><span class="c1"></span>			<span class="n">recv_cnt</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opinfo</span><span class="p">[</span><span class="n">recv_len</span><span class="p">],</span> <span class="n">BUF_SIZE</span> <span class="o">-</span> <span class="n">recv_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">recv_len</span> <span class="o">+=</span> <span class="n">recv_cnt</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">result</span><span class="o">=</span><span class="n">calculate</span><span class="p">(</span><span class="n">opnd_cnt</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">opinfo</span><span class="p">,</span> <span class="n">opinfo</span><span class="p">[</span><span class="n">recv_len</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">write</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
		<span class="n">close</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">close</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">calculate</span><span class="p">(</span><span class="kt">int</span> <span class="n">opnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opnds</span><span class="p">[],</span> <span class="kt">char</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="o">=</span><span class="n">opnds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">;</span>
	
	<span class="k">switch</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">opnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">result</span><span class="o">+=</span><span class="n">opnds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">opnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">result</span><span class="o">-=</span><span class="n">opnds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">opnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">result</span><span class="o">*=</span><span class="n">opnds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id="34-tcp原理">3.4 TCP原理</h3>
<p>TCP套接字的数据收发无边界。实际上，write函数调用后并非立即传输数据，read函数调用后也非马上接收数据。更准确地说，write函数调用瞬间，数据将移至输出缓冲；read函数调用瞬间，从输入缓冲读取数据。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/socket/5.2.png"
        data-srcset="../../imgs/socket/5.2.png, ../../imgs/socket/5.2.png 1.5x, ../../imgs/socket/5.2.png 2x"
        data-sizes="auto"
        alt="../../imgs/socket/5.2.png"
        title="TCP套接字的I/O缓冲" /></p>
<p>调用write函数时，数据将移动到输出缓冲，在适当的时候(不管是分别传送还是一次性传送)传向对方的输入缓冲。这时对方将调用read函数从输入缓冲读取数据。这些I/O缓冲特性可整理如下：</p>
<ul>
<li>I/O缓冲在每个TCP套接字中单独存在。</li>
<li>I/O缓冲在创建套接字时自动生成。</li>
<li>即使关闭套接字也会继续传递输入缓冲中遗留的数据。(调用close时)</li>
<li>关闭套接字将丢失缓冲中的数据。(调用close完成后)</li>
</ul>
<h2 id="4-基于udp的服务器端客户端">4. 基于UDP的服务器端/客户端</h2>
<h2 id="5-优雅地断开套接字连接">5. 优雅地断开套接字连接</h2>
<p>调用Linux的close函数意味着完全断开连接。完全断开不仅指无法传输数据，而且也不能接收数据。为了解决这类问题，“只关闭一部分数据交换中使用的流”(Half-close)的方法应运而生。断开一部分连接是指，可以传输数据但无法接收，或可以接收数据但无法传输。顾名思义就是只关闭流的一半。</p>
<h3 id="51-套接字和流stream">5.1 套接字和流(Stream)</h3>
<p>两台主机通过套接字建立连接后进入可交换数据的状态，又称“流形成的状态”。也就是把建立套接字后可交换数据的状态看作一种流。</p>
<p>此处的流可以比作水流。水朝着一个方向流动，同样，在套接字的流中，数据也只能向一个方向移动。因此，为了进行双向通信，需要2个流。如下图所示：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/socket/7.2.png"
        data-srcset="../../imgs/socket/7.2.png, ../../imgs/socket/7.2.png 1.5x, ../../imgs/socket/7.2.png 2x"
        data-sizes="auto"
        alt="../../imgs/socket/7.2.png"
        title="套接字中生成的两个流" /></p>
<p>一旦两台主机间建立了套接字连接，每个主机就会拥有单独的输入流和输出流。当然，其中一个主机的输入流与另一主机的输出流相连，而输出流则与另一主机的输入流相连。</p>
<h3 id="52-shutdown函数">5.2 shutdown函数</h3>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">shutdown</span><span class="p">(</span><span class="kt">int</span> <span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">howto</span><span class="p">);</span>
</code></pre></div><p>调用shutdown函数，成功时返回0，失败时返回-1。</p>
<ul>
<li>sock：需要断开的套接字文件描述符。</li>
<li>howto：传递断开方式信息。</li>
</ul>
<p>第二个参数(howto)参数决定断开连接的方式：</p>
<ul>
<li>SHUT_RD：断开输入流</li>
<li>SHUT_WR：断开输出流</li>
<li>SHUT_RDWR：同时断开I/O流。</li>
</ul>
<ol>
<li>若向shutdown的第二个参数传递SHUT_RD，则断开输入流，套接字无法接收数据。即使输入缓冲收到数据也会抹去，而且无法调用输入相关函数(read等)。</li>
<li>如果shutdown函数的第二个参数传递SHUT_WR，则中断输出流，也就无法传输数据(write等)。<strong>但如果输出缓冲还留有未传输的数据，则将传递至目标主机。</strong></li>
<li>最后，若传入SHUT)RDWR，则同时中断I/O流(相当于调用close函数)。这相当于分2次调用shutdown，其中一次以SHUT_RD为参数，另一次以SHUT_WR为参数。</li>
</ol>
<blockquote>
<p>断开输出流时，会向对方主机传输EOF。</p>
</blockquote>
<h3 id="53-基于半关闭的文件传输程序">5.3 基于半关闭的文件传输程序</h3>
<p>file_server.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 30
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">serv_sd</span><span class="p">,</span> <span class="n">clnt_sd</span><span class="p">;</span>
	<span class="n">FILE</span> <span class="o">*</span> <span class="n">fp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">read_cnt</span><span class="p">;</span>
	
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_adr</span><span class="p">,</span> <span class="n">clnt_adr</span><span class="p">;</span>
	<span class="n">socklen_t</span> <span class="n">clnt_adr_sz</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage: %s &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="c1">//rb：以二进制方式读入
</span><span class="c1"></span>	<span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&#34;file_server.c&#34;</span><span class="p">,</span> <span class="s">&#34;rb&#34;</span><span class="p">);</span> 
	<span class="n">serv_sd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
	
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
	
	<span class="n">bind</span><span class="p">(</span><span class="n">serv_sd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">listen</span><span class="p">(</span><span class="n">serv_sd</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	
	<span class="n">clnt_adr_sz</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clnt_adr</span><span class="p">);</span>    
	<span class="n">clnt_sd</span><span class="o">=</span><span class="n">accept</span><span class="p">(</span><span class="n">serv_sd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clnt_adr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clnt_adr_sz</span><span class="p">);</span>
	
	<span class="c1">// while(1)
</span><span class="c1"></span>	<span class="c1">// {
</span><span class="c1"></span>	<span class="c1">// 	read_cnt=fread((void*)buf, 1, BUF_SIZE, fp);
</span><span class="c1"></span>	<span class="c1">// 	if(read_cnt&lt;BUF_SIZE)
</span><span class="c1"></span>	<span class="c1">// 	{
</span><span class="c1"></span>	<span class="c1">// 		write(clnt_sd, buf, read_cnt);
</span><span class="c1"></span>	<span class="c1">// 		break;
</span><span class="c1"></span>	<span class="c1">// 	}
</span><span class="c1"></span>	<span class="c1">// 	write(clnt_sd, buf, BUF_SIZE);
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">//将fp文件描述符指向的文件数据发送给客户端(clnt_sd描述符)
</span><span class="c1"></span>	<span class="k">while</span><span class="p">(</span><span class="n">read_cnt</span> <span class="o">=</span> <span class="n">fread</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">write</span><span class="p">(</span><span class="n">clnt_sd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">read_cnt</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="c1">//关闭输出流，及发送EOF。
</span><span class="c1"></span>	<span class="n">shutdown</span><span class="p">(</span><span class="n">clnt_sd</span><span class="p">,</span> <span class="n">SHUT_WR</span><span class="p">);</span>

	<span class="c1">//输入流仍然可以使用
</span><span class="c1"></span>	<span class="n">read</span><span class="p">(</span><span class="n">clnt_sd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Message from client: %s </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	
	<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">close</span><span class="p">(</span><span class="n">clnt_sd</span><span class="p">);</span>
	<span class="n">close</span><span class="p">(</span><span class="n">serv_sd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div><p>file_cilent.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 30
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sd</span><span class="p">;</span>
	<span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">read_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_adr</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage: %s &lt;IP&gt; &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="c1">//wb：是二进制方式写入
</span><span class="c1"></span>	<span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&#34;./file/receive.dat&#34;</span><span class="p">,</span> <span class="s">&#34;wb&#34;</span><span class="p">);</span>
	<span class="n">sd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">inet_addr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>

	<span class="n">connect</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	
	<span class="c1">//通过sd接收服务端发送的数据，并存放到buf中
</span><span class="c1"></span>	<span class="k">while</span><span class="p">((</span><span class="n">read_cnt</span><span class="o">=</span><span class="n">read</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUF_SIZE</span> <span class="p">))</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">//把服务端接收的数据(buf)，流向fp文件描述符指定的文件receive.dat
</span><span class="c1"></span>		<span class="n">fwrite</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">read_cnt</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">puts</span><span class="p">(</span><span class="s">&#34;Received file data&#34;</span><span class="p">);</span>
	<span class="n">write</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="s">&#34;Thank you&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="n">close</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="6-域名及网络地址">6. 域名及网络地址</h2>
<h2 id="7-套接字的多种可选项">7. 套接字的多种可选项</h2>
<h2 id="8-多进程服务器端">8. 多进程服务器端</h2>
<h2 id="9-进程间通信">9. 进程间通信</h2>
<h2 id="10-io复用">10. I/O复用</h2>
<p>复用：</p>
<ul>
<li>在1个通信频道中传递多个数据(信号)的技术。</li>
<li>为了提高物理设备的效率，用最少的物理要素传递最多数据时使用的技术。</li>
</ul>
<h3 id="101-select函数">10.1 select函数</h3>
<p>select函数的调用过程：</p>
<p>  <img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/socket/12.5.png"
        data-srcset="../../imgs/socket/12.5.png, ../../imgs/socket/12.5.png 1.5x, ../../imgs/socket/12.5.png 2x"
        data-sizes="auto"
        alt="../../imgs/socket/12.5.png"
        title="select函数的调用过程" /></p>
<p><strong>设置文件描述符</strong></p>
<p>  利用select函数可以同时监视多个文件描述符。当然，监视文件描述符可以视为监视套接字。首先需要将要监视的文件描述符集中到一起，按照监视项(接收、传输、异常)进行区分，将上述3种监视项分成3类。</p>
<p>  使用fd_set数组变量执行此项操作，数组是存有0和1的位数组。</p>
<p>    <img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/socket/12.6.png"
        data-srcset="../../imgs/socket/12.6.png, ../../imgs/socket/12.6.png 1.5x, ../../imgs/socket/12.6.png 2x"
        data-sizes="auto"
        alt="../../imgs/socket/12.6.png"
        title="fd_set结构体" /></p>
<p>最左端的位表示文件描述符0(所在位置)。如果该位设置为1，则表示该文件描述符是监视对象。上图中，文件描述符1和3就是要监控的对象。</p>
<p>在fd_set变量中注册或更改值的操作都是由下列宏完成的：</p>
<ul>
<li>FD_ZERO(fd_set *fdest)：将fd_set变量的所有位初始化为0。</li>
<li>FD_SET(int fd, fd_set *fdset)：在参数fdset指向的变量中注册文件描述符fd的信息。</li>
<li>FD_CLR(int fd, fd_set *fdset)：从参数fdset指向的变量中清除文件描述符fd的信息。</li>
<li>FD_ISSET(int fd, fd_set *fdset)若参数fdset指向的变量中包含文件描述符fd的信息，则返回&quot;真&rdquo;。</li>
</ul>
<p>  <img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/socket/12.7.png"
        data-srcset="../../imgs/socket/12.7.png, ../../imgs/socket/12.7.png 1.5x, ../../imgs/socket/12.7.png 2x"
        data-sizes="auto"
        alt="../../imgs/socket/12.7.png"
        title="fd_set相关函数的功能" /></p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/select.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/time.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">maxfd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">readset</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">writeset</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptset</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</code></pre></div><p>调用select函数，成功时返回大于0的值，失败时返回-1。</p>
<ul>
<li>maxfd：监视对象文件描述符数量。</li>
<li>readset：将所有关注 &ldquo;是否存在待读取数据&rdquo; 的文件描述符注册到fd_set型变量，并传递其地址值。</li>
<li>writeset：将所有关注 &ldquo;是否可传输无阻塞数据&rdquo; 的文件描述符注册到fd_set型变量，并传递其地址值。</li>
<li>exceptset：将所有关注 &ldquo;是否发生异常&rdquo; 的文件描述符注册到fd_set型变量，并传递其地址值。
timeout：调用select函数后，为防止陷入无限阻塞的状态，传递超时(time-out)信息。</li>
<li>返回值：发生错误时返回-1，超时返回时返回0。因发生关注的事件返回时，返回大于0的值，该值是发生事件的文件描述符数。</li>
</ul>
<p>timeval结构体定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">timeval</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">tv_sec</span><span class="p">;</span>	<span class="c1">//seconds
</span><span class="c1"></span>	<span class="kt">long</span> <span class="n">tv_usec</span><span class="p">;</span>	<span class="c1">//microseconds
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>本例select函数只有在监视的文件描述符发生变化时才返回。如果未发生变化，就会进入阻塞状态。指定超时时间就是为了防止这种情况的发生。通过声明上述结构体变量，将秒数填入tv_sec成员，将毫秒数填入tv_usec成员，然后将结构体的地址值传递到select函数的最后一个参数。此时，即使文件秒师傅中未发生变化，只要过了指定时间，也可以从函数中返回。不过这种情况下，select函数返回0。因此，可以通过返回值了解返回原因。如果不想设置超时，则传递NULL作为参数。</p>
<p> </p>
<p><strong>select函数示例：</strong></p>
<p>select.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/time.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/select.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 30
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">fd_set</span> <span class="n">reads</span><span class="p">,</span> <span class="n">temps</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">str_len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reads</span><span class="p">);</span>
	<span class="n">FD_SET</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reads</span><span class="p">);</span> <span class="c1">// 0 is standard input(console)
</span><span class="c1"></span>
	<span class="cm">/*
</span><span class="cm">	timeout.tv_sec=5;
</span><span class="cm">	timeout.tv_usec=5000;
</span><span class="cm">	*/</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">temps</span> <span class="o">=</span> <span class="n">reads</span><span class="p">;</span>
		<span class="n">timeout</span><span class="p">.</span><span class="n">tv_sec</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">timeout</span><span class="p">.</span><span class="n">tv_usec</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

		<span class="c1">//设置监听文件描述符0(标准输入)的可读事件，并设置超时时间
</span><span class="c1"></span>		<span class="n">result</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temps</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">puts</span><span class="p">(</span><span class="s">&#34;select() error!&#34;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">puts</span><span class="p">(</span><span class="s">&#34;Time-out!&#34;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> 
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temps</span><span class="p">))</span> 
			<span class="p">{</span>
				<span class="c1">//从标准输入流中去读数据，并打印
</span><span class="c1"></span>				<span class="n">str_len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
				<span class="n">buf</span><span class="p">[</span><span class="n">str_len</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">&#34;message from console: %s&#34;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="102-基于select的io复用实例">10.2 基于select的I/O复用实例</h3>
<p>echo_selectserv.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/time.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/select.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 100
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">serv_sock</span><span class="p">,</span> <span class="n">clnt_sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_adr</span><span class="p">,</span> <span class="n">clnt_adr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">fd_set</span> <span class="n">reads</span><span class="p">,</span> <span class="n">cpy_reads</span><span class="p">;</span>

	<span class="n">socklen_t</span> <span class="n">adr_sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd_max</span><span class="p">,</span> <span class="n">str_len</span><span class="p">,</span> <span class="n">fd_num</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage : %s &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">serv_sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;bind() error&#34;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;listen() error&#34;</span><span class="p">);</span>

	<span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reads</span><span class="p">);</span>
	<span class="n">FD_SET</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reads</span><span class="p">);</span>
	<span class="n">fd_max</span> <span class="o">=</span> <span class="n">serv_sock</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cpy_reads</span> <span class="o">=</span> <span class="n">reads</span><span class="p">;</span>
		<span class="n">timeout</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="n">timeout</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>

		<span class="c1">//只监听了可读事件
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">((</span><span class="n">fd_num</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">fd_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpy_reads</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="c1">//超时未得到可读事件
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">fd_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="c1">//需要进一步优化
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fd_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpy_reads</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="c1">//发生建立连接的事件
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">serv_sock</span><span class="p">)</span> <span class="c1">// connection request!
</span><span class="c1"></span>				<span class="p">{</span>
					<span class="n">adr_sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clnt_adr</span><span class="p">);</span>
					<span class="n">clnt_sock</span> <span class="o">=</span>
						<span class="n">accept</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clnt_adr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adr_sz</span><span class="p">);</span>
					<span class="n">FD_SET</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reads</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">fd_max</span> <span class="o">&lt;</span> <span class="n">clnt_sock</span><span class="p">)</span>
						<span class="n">fd_max</span> <span class="o">=</span> <span class="n">clnt_sock</span><span class="p">;</span>
					<span class="n">printf</span><span class="p">(</span><span class="s">&#34;connected client: %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">clnt_sock</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="c1">//可读事件
</span><span class="c1"></span>				<span class="k">else</span> <span class="c1">// read message!
</span><span class="c1"></span>				<span class="p">{</span>
					<span class="n">str_len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">str_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// close request!
</span><span class="c1"></span>					<span class="p">{</span>
						<span class="n">FD_CLR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reads</span><span class="p">);</span>
						<span class="n">close</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
						<span class="n">printf</span><span class="p">(</span><span class="s">&#34;closed client: %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">else</span>
					<span class="p">{</span>
						<span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">str_len</span><span class="p">);</span> <span class="c1">// echo!
</span><span class="c1"></span>					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">close</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>echo.server.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 1024
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sock</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">str_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_adr</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage : %s &lt;IP&gt; &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">sock</span><span class="o">=</span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
	<span class="k">if</span><span class="p">(</span><span class="n">sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;socket() error&#34;</span><span class="p">);</span>
	
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">inet_addr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;connect() error!&#34;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">puts</span><span class="p">(</span><span class="s">&#34;Connected...........&#34;</span><span class="p">);</span>
	
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">fputs</span><span class="p">(</span><span class="s">&#34;Input message(Q to quit): &#34;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
		<span class="n">fgets</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
		
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="s">&#34;q</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="s">&#34;Q</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">write</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>
		<span class="n">str_len</span><span class="o">=</span><span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">message</span><span class="p">[</span><span class="n">str_len</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Message from server: %s&#34;</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="11-多种io函数">11. 多种I/O函数</h2>
<h2 id="12-多播与广播">12. 多播与广播</h2>
<h2 id="13-套接字和标准io">13. 套接字和标准I/O</h2>
<p>使用标准I/O函数时会得到额外的缓冲支持。创建套接字时，操作系统将生成用于I/O的缓冲。此缓冲在执行TCP协议时发挥着非常重要的作用。若此时使用标准I/O函数，将得到额外的另一缓冲的支持。</p>
<p>  <img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/socket/15.1.png"
        data-srcset="../../imgs/socket/15.1.png, ../../imgs/socket/15.1.png 1.5x, ../../imgs/socket/15.1.png 2x"
        data-sizes="auto"
        alt="../../imgs/socket/15.1.png"
        title="缓冲的关系" /></p>
<p>如上图，使用标准I/O函数传输数据时，经过2个缓冲。设置缓冲的主要目的是为了提高性能，但套接字中的缓冲主要是为了实现TCP协议而设立的。例如，TCP传输中丢失数据时将再次传递，而再次发生数据则保存在套接字的输出缓冲中。与之相反，使用标准I/O函数缓冲的主要目的是为了提高性能。</p>
<h3 id="131-标准io函数">13.1 标准I/O函数</h3>
<p>创建套接字时返回文件描述符，而为了使用标准I/O函数，只能将其转换为FILE结构体指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">FILE</span> <span class="o">*</span><span class="nf">fdopen</span><span class="p">(</span><span class="kt">int</span> <span class="n">fildes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
</code></pre></div><p>调用fdopen函数，成功时返回转换的FILE结构体指针，失败时返回NULL。</p>
<ul>
<li>fildes：需要转换的文件描述符。</li>
<li>mode：将要创建的FILE结构体指针的模式(mode)信息。</li>
</ul>
<p>desto.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;	//open函数的头文件</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&#34;./file/file.txt&#34;</span><span class="p">,</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">fputs</span><span class="p">(</span><span class="s">&#34;file open error&#34;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="c1">//将fd文件描述符转换为写模式的FILE指针
</span><span class="c1"></span>   <span class="n">fp</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">&#34;w&#34;</span><span class="p">);</span>
   <span class="n">fputs</span><span class="p">(</span><span class="s">&#34;Network C programming </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
   <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>也可以利用fileno函数将FILE指针转换为文件描述符</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">fileno</span><span class="p">(</span><span class="n">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</code></pre></div><p>调用fileno函数，成功时返回转换后的文件描述符，失败时返回-1。</p>
<p>todes.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&#34;data.dat&#34;</span><span class="p">,</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">fputs</span><span class="p">(</span><span class="s">&#34;file open error&#34;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="n">printf</span><span class="p">(</span><span class="s">&#34;First file descriptor: %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
   <span class="n">fp</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">&#34;w&#34;</span><span class="p">);</span>
   <span class="n">fputs</span><span class="p">(</span><span class="s">&#34;TCP/IP SOCKET PROGRAMMING </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Second file descriptor: %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">fileno</span><span class="p">(</span><span class="n">fp</span><span class="p">));</span>
   <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
   
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="132-基于套接字的标准io函数使用">13.2 基于套接字的标准I/O函数使用</h3>
<p>标准I/O函数为了提高性能，内部提供额外的缓冲。因此，若不调用fflush函数则无法保证立即将数据传输到客户端。</p>
<p>echo_stdserv.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 1024
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">serv_sock</span><span class="p">,</span> <span class="n">clnt_sock</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">str_len</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_adr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">clnt_adr</span><span class="p">;</span>
	<span class="n">socklen_t</span> <span class="n">clnt_adr_sz</span><span class="p">;</span>
	<span class="n">FILE</span> <span class="o">*</span> <span class="n">readfp</span><span class="p">;</span>
	<span class="n">FILE</span> <span class="o">*</span> <span class="n">writefp</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage : %s &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">serv_sock</span><span class="o">=</span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
	<span class="k">if</span><span class="p">(</span><span class="n">serv_sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;socket() error&#34;</span><span class="p">);</span>
	
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

	<span class="k">if</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;bind() error&#34;</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;listen() error&#34;</span><span class="p">);</span>
	
	<span class="n">clnt_adr_sz</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">clnt_adr</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">clnt_sock</span><span class="o">=</span><span class="n">accept</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clnt_adr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clnt_adr_sz</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">clnt_sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;accept() error&#34;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Connected client %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	
		<span class="n">readfp</span><span class="o">=</span><span class="n">fdopen</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">,</span> <span class="s">&#34;r&#34;</span><span class="p">);</span>
		<span class="n">writefp</span><span class="o">=</span><span class="n">fdopen</span><span class="p">(</span><span class="n">clnt_sock</span><span class="p">,</span> <span class="s">&#34;w&#34;</span><span class="p">);</span>
	
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">readfp</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">fgets</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">,</span> <span class="n">readfp</span><span class="p">);</span>
			<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">writefp</span><span class="p">);</span>
			<span class="n">fflush</span><span class="p">(</span><span class="n">writefp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">fclose</span><span class="p">(</span><span class="n">readfp</span><span class="p">);</span>
		<span class="n">fclose</span><span class="p">(</span><span class="n">writefp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">close</span><span class="p">(</span><span class="n">serv_sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>echo_stdclnt.c</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BUF_SIZE 1024
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sock</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">str_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_adr</span><span class="p">;</span>
	<span class="n">FILE</span> <span class="o">*</span> <span class="n">readfp</span><span class="p">;</span>
	<span class="n">FILE</span> <span class="o">*</span> <span class="n">writefp</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">!=</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Usage : %s &lt;IP&gt; &lt;port&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">sock</span><span class="o">=</span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
	<span class="k">if</span><span class="p">(</span><span class="n">sock</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;socket() error&#34;</span><span class="p">);</span>
	
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">));</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">inet_addr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">serv_adr</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_adr</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">error_handling</span><span class="p">(</span><span class="s">&#34;connect() error!&#34;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">puts</span><span class="p">(</span><span class="s">&#34;Connected...........&#34;</span><span class="p">);</span>

	<span class="n">readfp</span><span class="o">=</span><span class="n">fdopen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">&#34;r&#34;</span><span class="p">);</span>
	<span class="n">writefp</span><span class="o">=</span><span class="n">fdopen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">&#34;w&#34;</span><span class="p">);</span>	

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">fputs</span><span class="p">(</span><span class="s">&#34;Input message(Q to quit): &#34;</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
		<span class="n">fgets</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="s">&#34;q</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="s">&#34;Q</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">writefp</span><span class="p">);</span>
		<span class="n">fflush</span><span class="p">(</span><span class="n">writefp</span><span class="p">);</span>
 		<span class="n">fgets</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">,</span> <span class="n">readfp</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Message from server: %s&#34;</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
	<span class="p">}</span>	
	<span class="n">fclose</span><span class="p">(</span><span class="n">writefp</span><span class="p">);</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">readfp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">error_handling</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fputs</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">fputc</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="14-分离io流">14. 分离I/O流</h2>
<p>前面已经介绍的基于文件描述符的分离流(shutdown函数)的目的：</p>
<ul>
<li>通过分开输入过程(代码)和输出过程降低实现难度。</li>
<li>与输入无关的输出操作可以提高速度。</li>
</ul>
<p>  </p>
<p>基于FILE指针的分离流的目的：</p>
<ul>
<li>为了将FILE指针按读模式和写模式加以区分。</li>
<li>可以通过区分读写模式降低实现难度。</li>
<li>通过区分I/O缓冲提高缓冲性能。</li>
</ul>
<h3 id="141-文件描述符的复制和半关闭">14.1 文件描述符的复制和半关闭</h3>
<h2 id="15-优于select的epoll">15. 优于select的epoll</h2>
<h2 id="16-多线程服务器端的实现">16. 多线程服务器端的实现</h2>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2022-10-09</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://cui-jiang-tao.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-title="TCP/IP网络编程" data-hashtags="c/c&#43;&#43;"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://cui-jiang-tao.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-hashtag="c/c&#43;&#43;"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://cui-jiang-tao.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-title="TCP/IP网络编程"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://cui-jiang-tao.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-title="TCP/IP网络编程"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://cui-jiang-tao.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-title="TCP/IP网络编程"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/c/c&#43;&#43;/">c/c&#43;&#43;</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/git/" class="prev" rel="prev" title="Git"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>Git</a>
            <a href="/posts/c%E6%A0%87%E5%87%86%E5%BA%93/" class="next" rel="next" title="C标准库">C标准库<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022</span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"data":{"id-1":"Home","id-2":"Home"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
