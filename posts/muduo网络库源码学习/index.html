<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>muduo网络库源码学习 - vstk的网站</title><meta name="Description" content="This is my cool site"><meta property="og:title" content="muduo网络库源码学习" />
<meta property="og:description" content="第二部分：Muduo网络库 初探EventLoop 1、什么都不做的EventLoop 一个EventLoop就是一个事件循环，下面将通过一个“什" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" />
<meta property="article:published_time" content="2022-12-06T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-12-07T00:00:00+00:00" /><meta property="og:site_name" content="My cool site" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="muduo网络库源码学习"/>
<meta name="twitter:description" content="第二部分：Muduo网络库 初探EventLoop 1、什么都不做的EventLoop 一个EventLoop就是一个事件循环，下面将通过一个“什"/>
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" /><link rel="prev" href="https://cui-jiang-tao.github.io/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "muduo网络库源码学习",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/cui-jiang-tao.github.io\/posts\/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0\/"
        },"genre": "posts","keywords": "muduo","wordcount":  13889 ,
        "url": "https:\/\/cui-jiang-tao.github.io\/posts\/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0\/","datePublished": "2022-12-06T00:00:00+00:00","dateModified": "2022-12-07T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "cjt"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="vstk的网站"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="vstk的网站"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">muduo网络库源码学习</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>cjt</a></span>&nbsp;<span class="post-category">included in <a href="/categories/c/c++/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>c/c++</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-12-06">2022-12-06</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;13889 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;28 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#初探eventloop">初探EventLoop</a>
      <ul>
        <li><a href="#1什么都不做的eventloop">1、什么都不做的EventLoop</a></li>
        <li><a href="#2one-loop-per-thread">2、one loop per thread</a></li>
        <li><a href="#3事件循环">3、事件循环</a></li>
      </ul>
    </li>
    <li><a href="#channel分析">Channel分析</a>
      <ul>
        <li><a href="#1channel与文件描述符">1、Channel与文件描述符</a></li>
        <li><a href="#2设置监听回调函数">2、设置监听回调函数</a></li>
        <li><a href="#3channel与eventloop关系">3、Channel与EventLoop关系</a></li>
        <li><a href="#4响应事件">4、响应事件</a></li>
      </ul>
    </li>
    <li><a href="#poller">Poller</a>
      <ul>
        <li><a href="#1poller">1、Poller</a></li>
        <li><a href="#2poller分析">2、Poller分析</a></li>
        <li><a href="#3epollpoller-分析">3、EPollPoller 分析</a></li>
      </ul>
    </li>
    <li><a href="#定时器">定时器</a>
      <ul>
        <li><a href="#1timerfd_系列定时器">1、timerfd_*系列定时器</a></li>
        <li><a href="#2timer-分析">2、Timer 分析</a></li>
        <li><a href="#3timerid-分析">3、TimerId 分析</a></li>
        <li><a href="#4timerqueue">4、TimerQueue</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="第二部分muduo网络库">第二部分：Muduo网络库</h1>
<h2 id="初探eventloop">初探EventLoop</h2>
<h3 id="1什么都不做的eventloop">1、什么都不做的EventLoop</h3>
<p>一个EventLoop就是一个事件循环，下面将通过一个“什么都不做的EventLoop”来大致描述下muduo中EventLoop的功能。</p>
<p>“什么都不做的EventLoop”有如下几个特点：</p>
<ul>
<li>one loop per thread意思是说每个线程最多只能有一个EventLoop对象。</li>
<li>EventLoop对象构造的时候，会检查当前线程是否已经创建了其他EventLoop对象，如果已创建，终止程序(LOG_FATAL)</li>
<li>EventLoop构造函数会记住本对象所属线程(threadId_)。</li>
<li>创建了EventLoop对象的线程称为IO线程，其功能是运行事件循环(EventLoop::loop)</li>
</ul>
<h3 id="2one-loop-per-thread">2、one loop per thread</h3>
<p>这里指的是一个EventLoop只属于一个线程(但一个线程可以拥有多个EventLoop)，在muduo中，如果EventLoop一旦被创建，EventLoop会保持所属线程的一份tid拷贝，作为标识。如果该EventLoop被其他线程调用则会报错，muduo中使用assertInLoopThread函数来判断该EventLoop对象是否是在所属线程中执行。</p>
<h3 id="3事件循环">3、事件循环</h3>
<p>一个EventLoop里其实是调用了poll/epoll来跟踪所关注的文件描述符的，当有文件描述符上有事件发生时，EventLoop会得到那些发生事件的文件描述符信息。</p>
<h2 id="channel分析">Channel分析</h2>
<p>Channel，可以理解为是一个“通道”，该“通道”中绑定了一个文件描述符及其所关注事件、注册的读写事件等信息。</p>
<h3 id="1channel与文件描述符">1、Channel与文件描述符</h3>
<p>一个Channel管理一个文件描述符，在创建Channel时需要指定：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">Channel</span><span class="o">::</span><span class="n">Channel</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd__</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span>
    <span class="n">fd_</span><span class="p">(</span><span class="n">fd__</span><span class="p">),</span>
    <span class="p">...</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div><p>该文件描述符的关注事件可以用如下代码表示：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="kt">int</span> <span class="n">Channel</span><span class="o">::</span><span class="n">kNoneEvent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                <span class="c1">//没有事件：0
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">Channel</span><span class="o">::</span><span class="n">kReadEvent</span> <span class="o">=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLPRI</span><span class="p">;</span> <span class="c1">//可读事件：3
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">Channel</span><span class="o">::</span><span class="n">kWriteEvent</span> <span class="o">=</span> <span class="n">POLLOUT</span><span class="p">;</span>         <span class="c1">//可写事件：4
</span></code></pre></div><p>在Channel内部也定义了events_和revents_来标记文件描述符所关注的事件以及实际发生的事件，该方法和struct pollfd 结构体类似：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">events_</span><span class="p">;</span> <span class="c1">// 关注的事件
</span><span class="c1"></span><span class="kt">int</span> <span class="n">revents_</span><span class="p">;</span> <span class="c1">// poll/epoll返回的事件，即实际监听到发生的事件类型
</span></code></pre></div><p>muduo提供了下面这些函数来设置文件描述符关注事件：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">enableReading</span><span class="p">()</span> <span class="p">{</span> <span class="n">events_</span> <span class="o">|=</span> <span class="n">kReadEvent</span><span class="p">;</span> <span class="n">update</span><span class="p">();</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">enableWriting</span><span class="p">()</span> <span class="p">{</span> <span class="n">events_</span> <span class="o">|=</span> <span class="n">kWriteEvent</span><span class="p">;</span> <span class="n">update</span><span class="p">();</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">disableWriting</span><span class="p">()</span> <span class="p">{</span> <span class="n">events_</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">kWriteEvent</span><span class="p">;</span> <span class="n">update</span><span class="p">();</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">disableAll</span><span class="p">()</span> <span class="p">{</span> <span class="n">events_</span> <span class="o">=</span> <span class="n">kNoneEvent</span><span class="p">;</span> <span class="n">update</span><span class="p">();</span> <span class="p">}</span>
</code></pre></div><p>其中update函数的作用就是将该Channel及其绑定的文件描述符和EventLoop中的poll/epoll关联起来。</p>
<p>muduo也提供了下面函数来获取和设置文件描述符及其事件的状态，其中需要注意的是set_revents函数，该函数是被poll/epoll类中调用的：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">fd</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fd_</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">events</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">events_</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">set_revents</span><span class="p">(</span><span class="kt">int</span> <span class="n">revt</span><span class="p">)</span> <span class="p">{</span> <span class="n">revents_</span> <span class="o">=</span> <span class="n">revt</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// used by pollers
</span><span class="c1">// int revents() const { return revents_; }
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">isNoneEvent</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">events_</span> <span class="o">==</span> <span class="n">kNoneEvent</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><h3 id="2设置监听回调函数">2、设置监听回调函数</h3>
<p>Channel中可以设置读、写、错误和关闭事件的回调函数，通过函数模板的方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">ReadEventCallback</span> <span class="n">readCallback_</span><span class="p">;</span>
<span class="n">EventCallback</span> <span class="n">writeCallback_</span><span class="p">;</span>
<span class="n">EventCallback</span> <span class="n">closeCallback_</span><span class="p">;</span>
<span class="n">EventCallback</span> <span class="n">errorCallback_</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">EventCallback</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Timestamp</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ReadEventCallback</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">setReadCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadEventCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">readCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">setWriteCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">EventCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">writeCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">setCloseCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">EventCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">closeCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">setErrorCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">EventCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">errorCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><h3 id="3channel与eventloop关系">3、Channel与EventLoop关系</h3>
<p>一个Channel一定会关联一个EventLoop，和文件描述符一样，在构造函数中需要传入。一旦关联该EventLoop，EventLoop就可对该Channel操作。</p>
<h3 id="4响应事件">4、响应事件</h3>
<p>muduo中定义了该函数来响应Channel所绑定的文件描述符发生事件及其回调函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//处理绑定的事件
</span><span class="c1"></span><span class="kt">void</span> <span class="n">Channel</span><span class="o">::</span><span class="n">handleEvent</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">tied_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">guard</span> <span class="o">=</span> <span class="n">tie_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">//确定shared_ptr指针还存在
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">guard</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">handleEventWithGuard</span><span class="p">(</span><span class="n">receiveTime</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">handleEventWithGuard</span><span class="p">(</span><span class="n">receiveTime</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm"> * poll函数的事件标志符值：
</span><span class="cm">*    常量	                 说明
</span><span class="cm">    POLLIN	        普通或优先级带数据可读
</span><span class="cm">    POLLRDNORM    	普通数据可读
</span><span class="cm">    POLLRDBAND    	优先级带数据可读
</span><span class="cm">    POLLPRI	        高优先级数据可读
</span><span class="cm">    POLLOUT	        普通数据可写
</span><span class="cm">    POLLWRNORM	    普通数据可写
</span><span class="cm">    POLLWRBAND	    优先级带数据可写
</span><span class="cm">    POLLERR	        发生错误
</span><span class="cm">    POLLHUP	        对方描述符挂起
</span><span class="cm">    POLLNVAL	    描述字不是一个打开的文件
</span><span class="cm"> *
</span><span class="cm"> */</span>
<span class="c1">//开始选择性处理Channel对象绑定的事件
</span><span class="c1"></span><span class="kt">void</span> <span class="n">Channel</span><span class="o">::</span><span class="n">handleEventWithGuard</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">eventHandling_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">//处于处理事件中
</span><span class="c1"></span>
  <span class="c1">// close
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">((</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="n">POLLHUP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">logHup_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">LOG_WARN</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Channel::handle_event() POLLHUP&#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//符合关闭套接字的事件，回调close函数
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">closeCallback_</span><span class="p">)</span>
      <span class="n">closeCallback_</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">//Invalid polling request.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="n">POLLNVAL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOG_WARN</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Channel::handle_event() POLLNVAL&#34;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// error
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLNVAL</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errorCallback_</span><span class="p">)</span>
      <span class="n">errorCallback_</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// read
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLPRI</span> <span class="o">|</span> <span class="n">POLLRDHUP</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">readCallback_</span><span class="p">)</span>
      <span class="n">readCallback_</span><span class="p">(</span><span class="n">receiveTime</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// write
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="n">POLLOUT</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">writeCallback_</span><span class="p">)</span>
      <span class="n">writeCallback_</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">eventHandling_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//事件已处理完成
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>该函数会根据revents_判断该文件描述符上实际发生的事件类型，然后调用相关的注册的回调函数。例如如果是有POLLIN(读事件)产生，那么将调用readCallback_回调函数。</p>
<p>那么什么时候handleEvent函数会执行呢，在poll/epoll返回时，EventLoop对象在loop循环中会拿到有事件发生的Channel集合，并逐一执行它们的handleEvent函数。</p>
<h2 id="poller">Poller</h2>
<h3 id="1poller">1、Poller</h3>
<p>Poller是一个接口，指的是muduo封装的PollPoller、EPollPoller及其父类Poller的总称。在muduo中定义了一个Poller类，该类中定义了一些PollPoller和EPollPoller必须要实现的函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">virtual</span> <span class="n">Timestamp</span> <span class="nf">poll</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMs</span><span class="p">,</span> <span class="n">ChannelList</span><span class="o">*</span> <span class="n">activeChannels</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">updateChannel</span><span class="p">(</span><span class="n">Channel</span><span class="o">*</span> <span class="n">channel</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">removeChannel</span><span class="p">(</span><span class="n">Channel</span><span class="o">*</span> <span class="n">channel</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div><p>一个Channel管理一个文件描述符fd的所有信息与操作，但如果要将文件描述符和poll/epoll关联和注册事件监听，Poller也需要关联Channel并提供相关操作的函数。但是由于poll/epoll的poll函数和操作的方法及其数据结构不同，所以这些具体的实现还是要放在PollPoller和EPollPoller中。</p>
<p>muduo提供了两种事件循环的类PollPoller和EPollPoller，同时也提供了该函数来选择使用哪一个：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">Poller</span> <span class="o">*</span><span class="n">Poller</span><span class="o">::</span><span class="n">newDefaultPoller</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">getenv</span><span class="p">(</span><span class="s">&#34;MUDUO_USE_POLL&#34;</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">PollPoller</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">EPollPoller</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="2poller分析">2、Poller分析</h3>
<p><strong>1、PollPoller和EventLoop关系</strong></p>
<p>一个EventLoop关联一个PollPoller，Channel的update会调用EventLoop的update函数，而EventLoop又调用Poller相关的函数。EventLoop之所以能够“事件循环”也是其内部调用Poller的poll函数。</p>
<p><strong>2、PollPoller和Channel的关系</strong></p>
<p>Channel管理了一个文件描述符，在muduo中，一个Channel可以看作是一个文件描述符的“代表”，如果要操作一个文件描述符，则必须是通过该文件描述符对应的Channel。PollPoller需要监听和返回这些文件描述符上注册和实际发生的事件，所以必须提供操作Channel的函数和数据结构。下面这两个数据结构用于保存文件描述符及其Channel：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">struct</span> <span class="nc">pollfd</span><span class="o">&gt;</span> <span class="n">PollFdList</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Channel</span><span class="o">*&gt;</span> <span class="n">ChannelMap</span><span class="p">;</span>

<span class="n">PollFdList</span> <span class="n">pollfds_</span><span class="p">;</span>
<span class="n">ChannelMap</span> <span class="n">channels_</span><span class="p">;</span>
</code></pre></div><ul>
<li>pollfds_的作用非常明显，因为poll函数需要一个struct pollfd的数组地址，所以该结构是用于poll函数参数。</li>
<li>channels_则是用于管理注册的Channel的，key是Channel对应的文件描述符fd，value就是该Channel的地址，使用map数据结构可以很方便地对Channel进行查找和删除。</li>
</ul>
<p><strong>3、update 和 remove Channel</strong></p>
<p>(1) updateChannel 函数</p>
<p>由于需要更新一个Channel，所以该函数的参数只有Channel的一份指针：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * 主要时将Channel负责的文件描述符(fd)注册到Poller对象中, 或更新Poller对象 old
</span><span class="cm"> * fd_channels
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="n">PollPoller</span><span class="o">::</span><span class="n">updateChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Poller</span><span class="o">::</span><span class="n">assertInLoopThread</span><span class="p">();</span>
  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; events = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// index &lt; 0说明是一个新的通道
</span><span class="c1"></span>    <span class="c1">// a new one, add to pollfds_
</span><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">())</span> <span class="o">==</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="k">struct</span> <span class="nc">pollfd</span> <span class="n">pfd</span><span class="p">;</span>
    <span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
    <span class="n">pfd</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">());</span>
    <span class="n">pfd</span><span class="p">.</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// channel-&gt;revents()
</span><span class="c1"></span>    <span class="n">pollfds_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pfd</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
    <span class="n">channels_</span><span class="p">[</span><span class="n">pfd</span><span class="p">.</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span> <span class="c1">//通过文件描述符(fd) 映射 Channel
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// update existing one
</span><span class="c1"></span>    <span class="c1">//已存在的Channel
</span><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">())</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>

    <span class="c1">// index的取值必定在channels_.size()内
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>
    <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>

    <span class="cm">/**
</span><span class="cm">     * 更新pollfds_容器的信息(struct pollfd)
</span><span class="cm">     */</span>
    <span class="k">struct</span> <span class="nc">pollfd</span> <span class="o">&amp;</span><span class="n">pfd</span> <span class="o">=</span> <span class="n">pollfds_</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

    <span class="c1">// pfd.fd == -1 代表此Chanel不需被Poller::poll检测
</span><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">||</span> <span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">pfd</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">());</span>
    <span class="n">pfd</span><span class="p">.</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">//如果不再关注该Channel中文件描述符事件，则直接将该文件描述符赋值为其相反数减一。
</span><span class="c1"></span>    <span class="c1">// 将一个通道暂时更改为不关注事件，但不从Poller中移除该通道
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">isNoneEvent</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// ignore this pollfd
</span><span class="c1"></span>      <span class="c1">// 暂时忽略该文件描述符的事件
</span><span class="c1"></span>      <span class="c1">// 这里pfd.fd 可以直接设置为-1
</span><span class="c1"></span>      <span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 这样子设置是为了removeChannel优化
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>channel-&gt;index() &lt; 0</code>分支：</p>
<ul>
<li>当一个Channel创建后默认设置自身的index_为-1，所以对于新创建的Channel如果被更新，那么一定是走<code>channel-&gt;index() &lt; 0</code>分支的。既然该Channel是刚创建并且是第一次和PollPoller关联，那么PollPoller中一定不会存在该Channel的信息，所以使用了该断言。</li>
<li>再接下来就是构造一个pollfd结构体并将该结构体的文件信息通过Channel保存起来，供下次poll函数调用。</li>
<li>需要注意的是，上面Channel的index_被设置为当前pollfds_的实际长度减一，这也是为了方便快速获取到pollfds_向量中的对应的文件描述符，有了该文件描述又可以很快从channels_中获取到该Channel，这个过程的代价很小，几乎不需要遍历。</li>
</ul>
<p>接下来分析<code>channel-&gt;index() &gt; 0</code> 的情况：</p>
<ul>
<li>发生这种情况也意味着该Channel之前已经注册到该PollPoller中了，但是由于一些原因需要修改该文件描述符的关注事件，对于这种情况的Channel将调用else分支代码。</li>
<li>代码中两个assert断言该Channel是否已经和PollPoller关联，如果关联则取出该pollfd数组中的该Channel对应的文件描述符及其结构体，更新该结构体中文件描述符监听事件。如果不再关注该Channel中文件描述符事件，则直接将该文件描述符赋值为其相反数减一。</li>
</ul>
<p>(2) removeChannel 函数</p>
<p>使用该函数之前一般需要调用 updateChannel 函数设置不再关注该Channel对应的文件描述符上的事件。</p>
<p>该函数定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">PollPoller</span><span class="o">::</span><span class="n">removeChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Poller</span><span class="o">::</span><span class="n">assertInLoopThread</span><span class="p">();</span>
  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">())</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">isNoneEvent</span><span class="p">());</span>

  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>

  <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>

  <span class="k">const</span> <span class="k">struct</span> <span class="nc">pollfd</span> <span class="o">&amp;</span><span class="n">pfd</span> <span class="o">=</span> <span class="n">pollfds_</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">pfd</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pfd</span><span class="p">.</span><span class="n">events</span> <span class="o">==</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">());</span>

  <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">());</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pollfds_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 这里移除的算法复杂度是O(1)，将待删除元素与最后一个元素交换再pop_back
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">channelAtEnd</span> <span class="o">=</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">fd</span><span class="p">;</span>
    <span class="n">iter_swap</span><span class="p">(</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">//不再关注该Channel中文件描述符事件，通过这种方式获取原有的下标(key)位置
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">channelAtEnd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">channelAtEnd</span> <span class="o">=</span> <span class="o">-</span><span class="n">channelAtEnd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">channels_</span><span class="p">[</span><span class="n">channelAtEnd</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
    <span class="n">pollfds_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>首先三个断言确认该Channel已经和PollPoller关联而且确认该Channel上的文件描述符事件不再关注，然后找到该Channel文件描述符在pollfds_数组中的位置，将该Channel从Channels_中去除，将该文件描述符对应的pollfd从pollfds_数组中去除。</li>
<li>从pollfs_数组中去除一个pollfd，Muduo使用了一个技巧，如果要去除的pollfd结构是数组中的最后一个元素，则调用pop_back函数直接弹出，否则将该元素和数组中最后一个元素交换位置，然后弹出最后一个元素，这样保证了pollfds_数组元素是连续的，不存在中间缺失的情况。</li>
</ul>
<p><strong>3、poll</strong></p>
<p>poll函数是在EventLoop中调用的，EventLoop希望通过该函数获取到当前的活动Channel(文件描述符上有事件发生)集合，所以会传入一个ChannelList* activeChannels作为poll的参数，该结构是一个vector集合，保存Channel的地址，定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">*&gt;</span> <span class="n">ChannelList</span><span class="p">;</span>
</code></pre></div><p>poll函数定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * poll机制与select机制类似，通过管理文件描述符来进行轮询，效率更高，并且处理的连接个数不受内核的限制。
</span><span class="cm"> * 通过poll的方式进行轮询，通过Poller::fillActiveChannels得到活跃事件
</span><span class="cm"> */</span>
<span class="n">Timestamp</span> <span class="n">PollPoller</span><span class="o">::</span><span class="n">poll</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMs</span><span class="p">,</span> <span class="n">ChannelList</span> <span class="o">*</span><span class="n">activeChannels</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// XXX pollfds_ shouldn&#39;t change
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">numEvents</span> <span class="o">=</span> <span class="o">::</span><span class="n">poll</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">timeoutMs</span><span class="p">);</span>

  <span class="n">Timestamp</span> <span class="nf">now</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">numEvents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="n">numEvents</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; events happended&#34;</span><span class="p">;</span>
    <span class="n">fillActiveChannels</span><span class="p">(</span><span class="n">numEvents</span><span class="p">,</span> <span class="n">activeChannels</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">numEvents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; nothing happended&#34;</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;PollPoller::poll()&#34;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>该函数的第一个参数是超时时间，第二个参数是EventLoop中需要的活动通道集合。该函数的内部也是调用了poll函数，当poll返回时，该函数会获取当前时间戳，作为函数返回值使用。</li>
</ul>
<p>poll的返回值：</p>
<ul>
<li>如果poll返回为0，则说明poll超时但没有发生任何事件；</li>
<li>如果poll为负值，则说明poll系统调用失败；</li>
<li>如果poll正常返回一个整数，则说明当前有文件描述符活动，需要获取这些文件描述符对应的Channel，并返回给EventLoop，这里使用了fillActiveChannels来获取这些活跃的通道；</li>
</ul>
<p>fillActiveChannels函数定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * struct pollfd {
</span><span class="cm">    int fd;         	  // 用于检测的文件描述符
</span><span class="cm">    short events;         // 等待的事件类型
</span><span class="cm">    short revents;        // 实际发生的事件类型
</span><span class="cm">  } ;
</span><span class="cm">
</span><span class="cm">  通过fd 获得发生事件的Chanel集合
</span><span class="cm">**/</span>
<span class="kt">void</span> <span class="n">PollPoller</span><span class="o">::</span><span class="n">fillActiveChannels</span><span class="p">(</span><span class="kt">int</span> <span class="n">numEvents</span><span class="p">,</span>
                                    <span class="n">ChannelList</span> <span class="o">*</span><span class="n">activeChannels</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">PollFdList</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">pfd</span> <span class="o">=</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
       <span class="n">pfd</span> <span class="o">!=</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">numEvents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">pfd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pfd</span><span class="o">-&gt;</span><span class="n">revents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">--</span><span class="n">numEvents</span><span class="p">;</span>
      <span class="n">ChannelMap</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">pfd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">ch</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

      <span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">==</span> <span class="n">pfd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>

      <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_revents</span><span class="p">(</span><span class="n">pfd</span><span class="o">-&gt;</span><span class="n">revents</span><span class="p">);</span>
      <span class="c1">// pfd-&gt;revents = 0;  //??? 暂不清楚意图
</span><span class="c1"></span>      <span class="n">activeChannels</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>需要注意的是Channel的index_，在PollPoller中，如果index_为-1，则说明该Channel是新的需要加入的通道；如果index_&gt;0，则说明该Channel已经和PollPoller关联了，index_的值用于在pollfds_数组中查找文件描述符对应的pollfd如果index_为其他负值，则说明该文件描述符将不被关注，该Channel也将被移除。</p>
<h3 id="3epollpoller-分析">3、EPollPoller 分析</h3>
<p><strong>1、EPollPoller和EventLoop关系</strong></p>
<p>一个EventLoop关联一个EPollPoller，Channel的update会调用EventLoop的update函数，而EventLoop又调用Poller相关的函数。EventLoop之所以能够“事件循环”也是其内部调用Poller的poll函数。</p>
<p><strong>2、EPollPoller和Channel的关系</strong></p>
<p>Channel管理了一个文件描述符，在muduo中，一个Channel可以看作是一个文件描述符的“代表”，如果要操作一个文件描述符，则必须是通过该文件描述符对应的Channel。EPollPoller需要监听和返回这些文件描述符上注册和实际发生的事件，所以必须提供操作Channel的函数和数据结构。下面这两个数据结构用于保存文件描述符及其Channel：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">struct</span> <span class="nc">epoll_event</span><span class="o">&gt;</span> <span class="n">EventList</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Channel</span><span class="o">*&gt;</span> <span class="n">ChannelMap</span><span class="p">;</span>

<span class="n">EventList</span> <span class="n">events_</span><span class="p">;</span>
<span class="n">ChannelMap</span> <span class="n">channels_</span><span class="p">;</span>
</code></pre></div><p>EventList events_的作用非常明显，因为epoll函数需要一个struct epoll_event的数组地址，所以该结构是用于epoll_wait函数参数。ChannelMap channels_则是用于管理注册的Channel的，key是Channel对应的文件描述符fd，value就是该Channel的地址，使用map数据结构可以很方便的对Channel进行查找和操作。</p>
<p><strong>3、update 和 remove Channel</strong></p>
<p>(1) updateChannel 函数</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//将Channel加入epoll中管理，updateChannel方法一定是I/O线程调用的
</span><span class="c1"></span><span class="kt">void</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">updateChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Poller</span><span class="o">::</span><span class="n">assertInLoopThread</span><span class="p">();</span>
  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; events = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">();</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kNew</span> <span class="o">||</span> <span class="n">index</span> <span class="o">==</span> <span class="n">kDeleted</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// a new one, add with EPOLL_CTL_ADD
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kNew</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">==</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
      <span class="n">channels_</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="c1">// index == kDeleted
</span><span class="c1"></span>    <span class="p">{</span>
      <span class="c1">//也就是说，当Channel对象的无事件，可以通过index_来标识为删除状态，并不会从channels_容器中移除
</span><span class="c1"></span>      <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">kAdded</span><span class="p">);</span>     <span class="c1">//设置Channel对象为添加状态
</span><span class="c1"></span>    <span class="n">update</span><span class="p">(</span><span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span> <span class="c1">//添加到epoll中监视
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// update existing one with EPOLL_CTL_MOD/DEL
</span><span class="c1"></span>    <span class="c1">//更新已存在的Channel描述符，修改或删除
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">fd</span><span class="p">;</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kAdded</span><span class="p">);</span>

    <span class="c1">//当Channel对象不绑定事件，那么就从epoll的监视中移除，并设置Channel对象为删除状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">isNoneEvent</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">update</span><span class="p">(</span><span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
      <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">kDeleted</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">//更新epoll中监视的Channel对象的信息
</span><span class="c1"></span>      <span class="n">update</span><span class="p">(</span><span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这个函数的作用和PollPoller函数作用是一样的。当一个Channel的index_为-1时则说明这个Channel并没有和EPollPoller关联，如果index_为2，则说明该通道被取消过关注，如果为1则说明该Channel已经和EPollPoller关联，需要更新相关文件描述符的一些监听事件：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">namespace</span> <span class="p">{</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">kNew</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>        <span class="c1">//还没有和EPollPoller关联
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">kAdded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1">//该Channel已经和EPollPoller关联
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">kDeleted</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>     <span class="c1">//该通道被取消关注
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>如果index_是kNew或者kDeleted，则说明需要将该通道和该EPollPoller关联，设置index_为kAdded，然后调用update函数将该通道和EPollPoller关联：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//更新Channel对象绑定的事件
</span><span class="c1"></span><span class="kt">void</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">operation</span><span class="p">,</span> <span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">epoll_event</span> <span class="n">event</span><span class="p">;</span>
  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">event</span><span class="p">);</span>
  <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">();</span>
  <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd_</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operation</span> <span class="o">==</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;epoll_ctl op=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">operation</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; fd=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">fd</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">LOG_SYSFATAL</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;epoll_ctl op=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">operation</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; fd=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">fd</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>update函数内部也是调用了epoll_ctl函数。需要注意的是，epoll_event里并没有设置文件描述符，而是用了event.data.ptr指针保存了Channel，毕竟Channel中包含的文件描述符信息更加丰富。</p>
<p>如果index_已经是added状态，那么判断该Channel中文件描述符是否被设置为“不关注”，如果是的话，直接调用updata函数将该文件描述符移除epoll事件监听，否则更新该文件描述符结构的events监听事件。</p>
<p>(2) removeChannel 函数</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//将Channel对象从channels_容器和epoll监控中移除，此操作必须是I/O线程调用的
</span><span class="c1"></span><span class="kt">void</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">removeChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Poller</span><span class="o">::</span><span class="n">assertInLoopThread</span><span class="p">();</span>

  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">fd</span><span class="p">;</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">isNoneEvent</span><span class="p">());</span> <span class="c1">//要移除的Channel对象本身一定是无事件的
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>

  <span class="c1">//很奇怪，要移除的Channel对象应该就只能是kDeleted的啊？？？
</span><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kAdded</span> <span class="o">||</span> <span class="n">index</span> <span class="o">==</span> <span class="n">kDeleted</span><span class="p">);</span>

  <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kAdded</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">update</span><span class="p">(</span><span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//重新设置Channel为未被管理的初始状态
</span><span class="c1"></span>  <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">kNew</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>该函数将取消对Channel对应的文件描述的事件监听，然后将该Channel从channels_中删除。</p>
<p><strong>4、poll</strong></p>
<p>poll函数是在EventLoop中调用的，EventLoop希望通过该函数获取到当前的活动Channel(文件描述符上有事件发生)集合，所以会传入一个ChannelList* activeChannels作为poll的参数，该结构是一个vector集合，保存Channel的地址，定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">*&gt;</span> <span class="n">ChannelList</span><span class="p">;</span>
</code></pre></div><p>poll函数定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">Timestamp</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">poll</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMs</span><span class="p">,</span> <span class="n">ChannelList</span> <span class="o">*</span><span class="n">activeChannels</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//活跃的事件数量
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">numEvents</span> <span class="o">=</span> <span class="o">::</span><span class="n">epoll_wait</span><span class="p">(</span><span class="n">epollfd_</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">events_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
                               <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">events_</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">timeoutMs</span><span class="p">);</span>

  <span class="n">Timestamp</span> <span class="nf">now</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">numEvents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="n">numEvents</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; events happended&#34;</span><span class="p">;</span>
    <span class="n">fillActiveChannels</span><span class="p">(</span><span class="n">numEvents</span><span class="p">,</span> <span class="n">activeChannels</span><span class="p">);</span>

    <span class="c1">//活跃的事件数量太多了，扩容，动态调整
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numEvents</span><span class="p">)</span> <span class="o">==</span> <span class="n">events_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">events_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">events_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">numEvents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; nothing happended&#34;</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// numEvents &lt; 0 的情况
</span><span class="c1"></span>    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;EPollPoller::poll()&#34;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>该函数的第一个参数是超时时间，第二个参数是EventLoop中需要的活动通道集合。该函数的内部也是调用了epoll_wait函数，该函数需要一个额外的文件描述符作为epollfd_，该文件描述符在构造函数初始化参数中中已经初始化了。</p>
<p>当epoll_wait返回时，获取当前时间戳，作为EPollPoller::poll函数返回值使用。</p>
<ul>
<li>如果epoll_wait返回为0，则说明epoll_wait超时且没有发生任何事件；</li>
<li>如果poll为负值，则说明poll系统调用失败；</li>
<li>如果poll正常返回一个整数，则说明当前有文件描述符活动，需要获取这些文件描述符对应的Channel，并返回给EventLoop，这里使用了fillActiveChannels来获取这些活跃的通道，当活跃的文件描述达到events_数组大小时，该数组将会扩容一倍，以满足更多需求，也减少了vector动态扩张的次数。</li>
</ul>
<p>fillActiveChannels函数定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">fillActiveChannels</span><span class="p">(</span><span class="kt">int</span> <span class="n">numEvents</span><span class="p">,</span>
                                     <span class="n">ChannelList</span> <span class="o">*</span><span class="n">activeChannels</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">//活跃的事件数量不可能比装所有事件的容器的元素数量多
</span><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numEvents</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">events_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEvents</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Channel</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">events_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>

<span class="c1">// NDEBUG模式
</span><span class="c1"></span><span class="cp">#ifndef NDEBUG
</span><span class="cp"></span>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
    <span class="n">ChannelMap</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span>
    <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_revents</span><span class="p">(</span><span class="n">events_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="p">);</span>
    <span class="n">activeChannels</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>需要注意的是EPollPoller的文件描述符epollfd_，由于EPollPoller是采用RAII技法编写的，在构造函数中创建了文件描述符epollfd_，那么在析构函数中也应该关闭epollfd_并释放资源：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">EPollPoller</span><span class="o">::~</span><span class="n">EPollPoller</span><span class="p">()</span> <span class="p">{</span> <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">epollfd_</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><h2 id="定时器">定时器</h2>
<p>muduo的定时器由三个类实现，TimerId、Timer、TimerQueue，用户只能看到第一个类，其它两个都是内部实现细节。</p>
<h3 id="1timerfd_系列定时器">1、timerfd_*系列定时器</h3>
<p>muduo选择了timerfd_*系列作为定时器。</p>
<p>下面这组函数便是操作timerfd的系统调用：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;sys/timerfd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">timerfd_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">clockid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">timerfd_settime</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="o">*</span><span class="n">new_value</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="o">*</span><span class="n">old_value</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">timerfd_gettime</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="o">*</span><span class="n">curr_value</span><span class="p">)</span>
</code></pre></div><p><strong>timerfd_create</strong>，它是用来创建一个定时器描述符timerfd</p>
<ul>
<li>第一个参数：clockid指定时间类型，有两个值：
<ul>
<li>CLOCK_REALTIME :Systemwide realtime clock. 系统范围内的实时时钟</li>
<li>CLOCK_MONOTONIC:以固定的速率运行，从不进行调整和复位 ,它不受任何系统time-of-day时钟修改的影响</li>
</ul>
</li>
<li>第二个参数：flags可以是0或者O_CLOEXEC/O_NONBLOCK。</li>
<li>返回值：timerfd(文件描述符)</li>
</ul>
<p><strong>timerfd_settime</strong>，该函数作用是用来启动或关闭有fd指定的定时器。在讲解该函数前，先理解两个相关结构体：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">timespec</span> <span class="p">{</span>
    <span class="n">time_t</span> <span class="n">tv_sec</span><span class="p">;</span>      <span class="cm">/* Seconds */</span>
    <span class="kt">long</span>   <span class="n">tv_nsec</span><span class="p">;</span>     <span class="cm">/* Nanoseconds */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">itimerspec</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">it_interval</span><span class="p">;</span>  <span class="cm">/* Interval for periodic timer */</span>
    <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">it_value</span><span class="p">;</span>     <span class="cm">/* Initial expiration */</span>
<span class="p">};</span>
</code></pre></div><p>第二个结构体itimerspec就是timerfd要设置的超时结构体，它的成员it_value表示定时器第一次超时时间，it_interval表示之后的超时时间即每隔多长时间超时</p>
<p>下面正式分析该函数的参数和返回值：</p>
<p>参数：</p>
<ul>
<li>fd：timerfd，有timerfd_create函数返回</li>
<li>flags：1代表设置的是绝对时间；为0代表相对时间</li>
<li>fnew_value：指定新的超时时间，设定new_value.it_value非零则启动定时器，否则关闭定时器，如果new_value.it_interval为0，则定时器只定时一次，即初始那次，否则之后每隔设定时间超时一次</li>
<li>old_value：不为null，则返回定时器这次设置之前的超时时间</li>
</ul>
<p><strong>timerfd_gettime</strong>，此函数用于获得定时器距离下次超时还剩下的时间。如果调用时定时器已经到期，并且该定时器处于循环模式(设置超时时间时struct itimerspec::it_interval不为0)，那么调用此函数之后定时器重新开始计时。</p>
<h3 id="2timer-分析">2、Timer 分析</h3>
<p>一个定时器会在某一个时刻执行某个任务，而且有可能是“定时执行”，所以，一个Timer里封装了该Timer的超时时间(定时时间)、任务的执行周期等信息：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="n">TimerCallback</span> <span class="n">callback_</span><span class="p">;</span> <span class="c1">//定时执行函数
</span><span class="c1"></span><span class="n">Timestamp</span> <span class="n">expiration_</span><span class="p">;</span>  <span class="c1">// 超时时间
</span><span class="c1"></span><span class="k">const</span> <span class="kt">double</span> <span class="n">interval_</span><span class="p">;</span> <span class="c1">// 执行间隔
</span><span class="c1"></span><span class="k">const</span> <span class="kt">bool</span> <span class="n">repeat_</span><span class="p">;</span>  <span class="c1">// 是否重复定时执行任务
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int64_t</span> <span class="n">sequence_</span><span class="p">;</span> <span class="c1">// 序列号，每个Tmier的序列号都不一样
</span></code></pre></div><p>其中sequence_是通过对一个静态变量的原子增加来保证独一无二的：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">static</span> <span class="n">AtomicInt64</span> <span class="n">s_numCreated_</span><span class="p">;</span>
</code></pre></div><p>该原子操作会在Timer构造函数初始化列表中完成初始化：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">Timer</span><span class="p">(</span><span class="k">const</span> <span class="n">TimerCallback</span><span class="o">&amp;</span> <span class="n">cb</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">when</span><span class="p">,</span> <span class="kt">double</span> <span class="n">interval</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">callback_</span><span class="p">(</span><span class="n">cb</span><span class="p">),</span>
    <span class="n">expiration_</span><span class="p">(</span><span class="n">when</span><span class="p">),</span>
    <span class="n">interval_</span><span class="p">(</span><span class="n">interval</span><span class="p">),</span>
    <span class="n">repeat_</span><span class="p">(</span><span class="n">interval</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="n">sequence_</span><span class="p">(</span><span class="n">s_numCreated_</span><span class="p">.</span><span class="n">incrementAndGet</span><span class="p">())</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div><p>Timer也提供了一些列函数来操作和获取这些变量值：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="nf">run</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">callback_</span><span class="p">();</span> <span class="p">}</span>

  <span class="c1">//触发事件的时间戳
</span><span class="c1"></span>  <span class="n">Timestamp</span> <span class="nf">expiration</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">expiration_</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">repeat</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">repeat_</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">int64_t</span> <span class="nf">sequence</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sequence_</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">restart</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">now</span><span class="p">);</span>

  <span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">numCreated</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s_numCreated_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
</code></pre></div><p>如果要重新设置该Timer的超时时间，可以通过下面这个函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * 如果是重复的累加的，加入累加的时间重新设置到期时间，否则设置为失效时间
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="n">Timer</span><span class="o">::</span><span class="n">restart</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">repeat_</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 重新计算下一个超时时刻
</span><span class="c1"></span>    <span class="n">expiration_</span> <span class="o">=</span> <span class="n">addTime</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">interval_</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">//设置无效的时间
</span><span class="c1"></span>    <span class="n">expiration_</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="o">::</span><span class="n">invalid</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="3timerid-分析">3、TimerId 分析</h3>
<p>TimerId 中保存了一个Timer，以及该TimerId的序列号，同时将TimerQueue 设置为友元类：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Timer</span><span class="p">;</span>

<span class="c1">///
</span><span class="c1">/// An opaque identifier, for canceling Timer.
</span><span class="c1">///
</span><span class="c1"></span><span class="k">class</span> <span class="nc">TimerId</span> <span class="o">:</span> <span class="k">public</span> <span class="n">muduo</span><span class="o">::</span><span class="n">copyable</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">TimerId</span><span class="p">()</span> <span class="o">:</span> <span class="n">timer_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">sequence_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">TimerId</span><span class="p">(</span><span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">seq</span><span class="p">)</span> <span class="o">:</span> <span class="n">timer_</span><span class="p">(</span><span class="n">timer</span><span class="p">),</span> <span class="n">sequence_</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// default copy-ctor, dtor and assignment are okay
</span><span class="c1"></span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">TimerQueue</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Timer</span> <span class="o">*</span><span class="n">timer_</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">sequence_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><h3 id="4timerqueue">4、TimerQueue</h3>
<p><strong>1、TimerQueue 设计原理</strong></p>
<p>一个TimerQueue 会关联一个EventLoop，一个TimerQueue中会绑定一个文件描述符timerfd以及Channel。该TimerQueue中保存众多的Timer，并且将这些Timer根据其超时时间从小到大放入一个集合中，其中最近超时时间将设置为timerfd的超时时间(也就是说将最近超时时间关联到timerfd上)，到了该时间，timerfd上会有读事件发生，然后定时器会将定时在该超时时间到真正处理该读事件之间的Timer获取到，执行这些Timer的定时函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// FIXME: use unique_ptr&lt;Timer&gt; instead of raw pointers.
</span><span class="c1">// unique_ptr是C++ 11标准的一个独享所有权的智能指针
</span><span class="c1">// 无法得到指向同一对象的两个unique_ptr指针
</span><span class="c1">// 但可以进行移动构造与移动赋值操作，即所有权可以移动到另一个对象(而非拷贝构造)
</span><span class="c1"></span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">Timer</span> <span class="o">*&gt;</span> <span class="n">Entry</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">TimerList</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Timer</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">ActiveTimer</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">ActiveTimer</span><span class="o">&gt;</span> <span class="n">ActiveTimerSet</span><span class="p">;</span>

<span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span> <span class="c1">// 所属EventLoop
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">timerfd_</span><span class="p">;</span>
<span class="n">Channel</span> <span class="n">timerfdChannel_</span><span class="p">;</span>
<span class="c1">// Timer list sorted by expiration
</span><span class="c1">// set中的元素都是排好序的, 用于存储Timer，同时将Timer的到期时间戳作为key
</span><span class="c1"></span><span class="n">TimerList</span> <span class="n">timers_</span><span class="p">;</span> <span class="c1">// timers_是按到期时间排序
</span><span class="c1"></span>
<span class="c1">// for cancel()
</span><span class="c1">// timers_与activeTimers_保存的是相同的数据 =》 利于操作，空间换效率吧？？？
</span><span class="c1">// timers_是按到期时间排序，activeTimers_是按对象地址排序
</span><span class="c1"></span><span class="n">ActiveTimerSet</span> <span class="n">activeTimers_</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">callingExpiredTimers_</span><span class="p">;</span>      <span class="c1">//用来确定是否正在调用回调函数的定时器/* atomic */
</span><span class="c1"></span><span class="n">ActiveTimerSet</span> <span class="n">cancelingTimers_</span><span class="p">;</span> <span class="c1">// 保存的是被取消的定时器
</span></code></pre></div><p>TimerQueue 的构造函数如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * 一个TimerQueue只对应一个Eventloop和一个内部构造的Channel(构造对象时，默认绑定一个定时器对象timerfd_)
</span><span class="cm"> * 同时设置Channel的回调函数TimerQueue::handleRead
</span><span class="cm"> */</span>
<span class="n">TimerQueue</span><span class="o">::</span><span class="n">TimerQueue</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span> <span class="n">timerfd_</span><span class="p">(</span><span class="n">createTimerfd</span><span class="p">()),</span> <span class="n">timerfdChannel_</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">timerfd_</span><span class="p">),</span>
      <span class="n">timers_</span><span class="p">(),</span> <span class="n">callingExpiredTimers_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">timerfdChannel_</span><span class="p">.</span><span class="n">setReadCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
  <span class="c1">// we are always reading the timerfd, we disarm it with timerfd_settime.
</span><span class="c1"></span>  <span class="n">timerfdChannel_</span><span class="p">.</span><span class="n">enableReading</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>构造函数中使用了createTimerfd来创建一个定时器文件描述符，该函数定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * 创建定时器，生成一个定时器对象，返回与之关联的文件描述符timerfd。
</span><span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">createTimerfd</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">timerfd</span> <span class="o">=</span> <span class="o">::</span><span class="n">timerfd_create</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">TFD_NONBLOCK</span> <span class="o">|</span> <span class="n">TFD_CLOEXEC</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">timerfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOG_SYSFATAL</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed in timerfd_create&#34;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">timerfd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>构造函数中Channel绑定的“读事件”回调函数是TimerQueue::handleRead，该函数定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * I/O线程才可调用
</span><span class="cm"> * 用来设置关联的Channel的回调函数
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">handleRead</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>

  <span class="n">Timestamp</span> <span class="nf">now</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>
  <span class="c1">// 清除该事件，避免一直触发，并记录触发TimerQueue::handleRead回调函数的时间
</span><span class="c1"></span>  <span class="n">readTimerfd</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>

  <span class="c1">// 获取该时刻之前所有的定时器列表(即超时定时器列表)
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">expired</span> <span class="o">=</span> <span class="n">getExpired</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>

  <span class="n">callingExpiredTimers_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="c1">// safe to callback outside critical section
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expired</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">expired</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
       <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 这里回调定时器处理函数
</span><span class="c1"></span>    <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">callingExpiredTimers_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// 不是一次性定时器，需要重启
</span><span class="c1"></span>  <span class="n">reset</span><span class="p">(</span><span class="n">expired</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>如果定时器超时，那么将执行该回调函数，该回调函数会调用readTimerfd函数先处理文件描述符事件，readTimerfd 函数定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// 清除定时器，避免一直触发，并记录传入的时间戳
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">readTimerfd</span><span class="p">(</span><span class="kt">int</span> <span class="n">timerfd</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">howmany</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">timerfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">howmany</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">howmany</span><span class="p">);</span>
  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TimerQueue::handleRead() &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">howmany</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; at &#34;</span>
            <span class="o">&lt;&lt;</span> <span class="n">now</span><span class="p">.</span><span class="n">toString</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">howmany</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOG_ERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TimerQueue::handleRead() reads &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span>
              <span class="o">&lt;&lt;</span> <span class="s">&#34; bytes instead of 8&#34;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在处理完文件描述符读事件后调用getExpired函数获取从文件描述符事件发生到当前时间内超时的Timer，然后遍历该集合，获取到Timer并执行其run函数(run函数中执行的是Timer真正的定时函数)。处理完这些超时的Timer后调用reset函数来重置这些Timer的定时任务，因为有些Timer是设置为循环执行的，所以还要重新设置它们的下一次执行时间。</p>
<p><strong>2、向TimerQueue 中添加一个Timer</strong></p>
<p>TimerQueue使用addTimer函数来向队列中添加一个Timer：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * 添加一个新Timer，并及时更新；
</span><span class="cm"> * 如果TimerList中元素只有一个或插入的Timer最快到期，马上重新设置TimerQueue对象绑定的timerfd的超时时间
</span><span class="cm"> */</span>
<span class="n">TimerId</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimer</span><span class="p">(</span><span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">when</span><span class="p">,</span>
                             <span class="kt">double</span> <span class="n">interval</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/**
</span><span class="cm">   * 该对象将存储到TimerList中
</span><span class="cm">   * =&gt; std::set&lt;std::pair&lt;Timestamp, Timer*&gt;&gt; TimerList;
</span><span class="cm">   */</span>
  <span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Timer</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">when</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>

  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimerInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timer</span><span class="p">));</span>

  <span class="c1">// addTimerInLoop(timer);
</span><span class="c1"></span>  <span class="k">return</span> <span class="nf">TimerId</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div><p>该函数需要传入一个定时回调函数，一个超时时间戳和定时周期，TimerCallback的原型如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">TimerCallback</span><span class="p">;</span>
</code></pre></div><p>创建一个Timer，然后通过EventLoop调用TimerQueue::addTimerInLoop函数，最后TimerQueue::addTimer返回一个TimerId。runInLoop的实现细节在后面章节会解释，addTimerInLoop函数的定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * I/O线程才可调用
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimerInLoop</span><span class="p">(</span><span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
  <span class="c1">// 插入一个定时器，有可能会使得最早到期的定时器发生改变
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="n">earliestChanged</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">earliestChanged</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 重置定时器的超时时刻(timerfd_settime)
</span><span class="c1"></span>    <span class="n">resetTimerfd</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>该函数又调用了insert函数，insert定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * 返回值，插入的Timer是否是最早到期的时间;说明：插入的Timer元素是有序timers_(set集合)的第一个元素或唯一的元素为true
</span><span class="cm"> * 功能：插入一个std::pair&lt;Timestamp，Timer*&gt;对象，将参数timer的到期时间戳作为std::pair的first，Timner对象作为sencond
</span><span class="cm"> * activeTimers_ 和 timers_两个容器保存的Timer对象是一样的，仅仅内存分布不同而已
</span><span class="cm"> */</span>
<span class="kt">bool</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// 最早到期时间是否改变
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="n">earliestChanged</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">Timestamp</span> <span class="n">when</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">();</span>
  <span class="n">TimerList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

  <span class="c1">// 如果timers_为空或者when小于timers_中的最早到期时间(这个插入的Timer是集合第一个到期的时间戳)
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">timers_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">||</span> <span class="n">when</span> <span class="o">&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">earliestChanged</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="p">{</span>
    <span class="c1">// 插入到timers_中
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TimerList</span><span class="o">::</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">timers_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Entry</span><span class="p">(</span><span class="n">when</span><span class="p">,</span> <span class="n">timer</span><span class="p">));</span>

    <span class="c1">// result.first代表插入的元素的iterator，result.second代表元素是否插入成功
</span><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="p">{</span>
    <span class="c1">// 插入到activeTimers_中
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">ActiveTimerSet</span><span class="o">::</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">activeTimers_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ActiveTimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">()));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">earliestChanged</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>insert函数会获取到该Timer的超时时间，如果该Timer的超时时间是最近的(比之前从小到大排列的超时集合最小的还小)，说明该Timer的定时函数是最早执行的，所以设置标志earliestChanged = true，然后将该Timer加入到timers_和activeTimers_中，然后返回earliestChanged。</p>
<p>回到TimerQueue::addTimerInLoop函数，该函数在插入一个Timer后，判断earliestChanged，如果该项为true，那么也需要重新设置TimerQueue的timerfd_的定时时间，则调用resetTimerfd函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * 重置定时器的超时时间，重新设置Timer文件描述符(Timerfd)的超时时间，启动或停止定时器
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">resetTimerfd</span><span class="p">(</span><span class="kt">int</span> <span class="n">timerfd</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">expiration</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// wake up loop by timerfd_settime()
</span><span class="c1"></span>  <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="n">newValue</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="n">oldValue</span><span class="p">;</span>
  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newValue</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">newValue</span><span class="p">);</span>
  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldValue</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">oldValue</span><span class="p">);</span>
  <span class="n">newValue</span><span class="p">.</span><span class="n">it_value</span> <span class="o">=</span> <span class="n">howMuchTimeFromNow</span><span class="p">(</span><span class="n">expiration</span><span class="p">);</span>

  <span class="c1">//启动或停止定时器，依据newValue
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">::</span><span class="n">timerfd_settime</span><span class="p">(</span><span class="n">timerfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newValue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldValue</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;timerfd_settime()&#34;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><strong>3、获取超时Timer</strong></p>
<p>getExpired函数会获取到将小于传入时间戳now的Timer，将这些Timer的Entry保存到一个vector中并返回，同时删除timers_和activeTimers_中的这些和Timer相关的部分。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * rvo优化
</span><span class="cm"> * 返回一个到期时间std::vector&lt;Entry&gt;的容器
</span><span class="cm"> * =》typedef std::pair&lt;Timestamp,Timer*&gt; Entry;
</span><span class="cm"> */</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">getExpired</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">expired</span><span class="p">;</span>
  <span class="c1">// std::pair作为set的key时，比较pair 是先比较first, first相同再比较second
</span><span class="c1"></span>  <span class="n">Entry</span> <span class="nf">sentry</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Timer</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">UINTPTR_MAX</span><span class="p">));</span>

  <span class="c1">// 返回第一个未到期的Timer的迭代器
</span><span class="c1"></span>  <span class="c1">// lower_bound的含义是返回第一个值&gt;=sentry的元素的iterator
</span><span class="c1"></span>  <span class="c1">// 即*end &gt;= sentry，从而end-&gt;first &gt; now
</span><span class="c1"></span>  <span class="n">TimerList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">sentry</span><span class="p">);</span>

  <span class="c1">// timers_的集合全是过期的时间戳，或者？？？
</span><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">timers_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">||</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>

  <span class="c1">// 将到期的定时器插入到expired中
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">,</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">expired</span><span class="p">));</span>
  <span class="c1">// 从timers_中移除到期的定时器
</span><span class="c1"></span>  <span class="n">timers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">);</span>

  <span class="c1">// 从activeTimers_中移除到期的定时器
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expired</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">expired</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
       <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ActiveTimer</span> <span class="nf">timer</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">());</span>
    <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">expired</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><strong>4、向TimerQueue 中取消一个Timer</strong></p>
<p>muduo使用cancle来取消一个Timer：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancel</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timerId</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancelInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timerId</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div><p>该函数又调用了TimerQueue::cancelInLoop：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * I/O线程才可调用
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancelInLoop</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timerId</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="n">ActiveTimer</span> <span class="nf">timer</span><span class="p">(</span><span class="n">timerId</span><span class="p">.</span><span class="n">timer_</span><span class="p">,</span> <span class="n">timerId</span><span class="p">.</span><span class="n">sequence_</span><span class="p">);</span>
  <span class="c1">// 查找该定时器
</span><span class="c1"></span>  <span class="n">ActiveTimerSet</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">Entry</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">(),</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span> <span class="c1">// FIXME: no delete
</span><span class="c1"></span>                      <span class="c1">// please,如果用了unique_ptr,这里就不需要手动删除了
</span><span class="c1"></span>    <span class="n">activeTimers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">callingExpiredTimers_</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 已经到期，并且正在调用回调函数的定时器
</span><span class="c1"></span>    <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div><p>该函数以TimerId的方式从TimerQueue中删除相关Timer内容，如果该当前TimerQueue已经有超时事件产生(handleRead中callingExpiredTimers_设置为true)，TimerQueue::getExpired会删除超时的Timer，那么还需要将该Timer保存到“待取消定时器队列”中：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">ActiveTimerSet</span> <span class="n">cancelingTimers_</span><span class="p">;</span>
</code></pre></div><p><strong>5、重置超时Timer</strong></p>
<p>handleRead函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * I/O线程才可调用
</span><span class="cm"> * 用来设置关联的Channel的回调函数
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">handleRead</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>

  <span class="n">Timestamp</span> <span class="nf">now</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>
  <span class="c1">// 清除该事件，避免一直触发，并记录触发TimerQueue::handleRead回调函数的时间
</span><span class="c1"></span>  <span class="n">readTimerfd</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>

  <span class="c1">// 获取该时刻之前所有的定时器列表(即超时定时器列表)
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">expired</span> <span class="o">=</span> <span class="n">getExpired</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>

  <span class="n">callingExpiredTimers_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="c1">// safe to callback outside critical section
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expired</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">expired</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
       <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 这里回调定时器处理函数
</span><span class="c1"></span>    <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">callingExpiredTimers_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// 不是一次性定时器，需要重启
</span><span class="c1"></span>  <span class="n">reset</span><span class="p">(</span><span class="n">expired</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>如果已经去除队列中的超时定时器集合，这些集合的定时任务也处理完了之后还需要reset这些集合，因为一个定时器Timer可能设置了repeat_和interval_，需要重新设置下一次Timer的执行时间。reset函数定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * 对已经过期的队列进行处理，如果是重复调用的，重新设置新的到期时间并加入Timer队列中继续监控；重新设置TimerQueue对象绑定的fd到期时间
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">reset</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">expired</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Timestamp</span> <span class="n">nextExpire</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expired</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">expired</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ActiveTimer</span> <span class="nf">timer</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">());</span>
    <span class="c1">// 如果是重复的定时器并且是未取消定时器，则重启该定时器
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">repeat</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
        <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="o">==</span> <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">//如果是重复的累加的，加入累加的时间重新设置到期时间，否则设置为失效时间
</span><span class="c1"></span>      <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">restart</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
      <span class="c1">//将累加后新的Timer插入到Timer队列中，继续监控
</span><span class="c1"></span>      <span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 一次性定时器或者已被取消的定时器是不能重置的，因此删除该定时器
</span><span class="c1"></span>      <span class="c1">// FIXME move to a free list
</span><span class="c1"></span>      <span class="k">delete</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span> <span class="c1">// FIXME: no delete please
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timers_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// //得到队列中第一个要到期的时间，获取最早到期的定时器超时时间
</span><span class="c1"></span>    <span class="n">nextExpire</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">//队列中还未到期的时间是有效的
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">nextExpire</span><span class="p">.</span><span class="n">valid</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 重置定时器的超时时刻(timerfd_settime)，重新设置TimerQueue对象绑定的fd到期时间
</span><span class="c1"></span>    <span class="n">resetTimerfd</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">,</span> <span class="n">nextExpire</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这个函数会检查这些超时的定时器Timer，如果是设置了repeat_为true并且不在“取消定时器队列”中则重置下一次定时器执行时间，否则(如一次性定时任务，或者取消了但未能避免执行)则直接删除。在执行handleRead时也会将cancelingTimers_清空。最后设置TimerQueue的timerfd_最近定时时间，准备下一次执行定时事件的到来。</p>
<p><strong>6、析构函数与资源销毁</strong></p>
<p>关闭timerfd_文件描述符，释放管理的所有Timer资源。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">TimerQueue</span><span class="o">::~</span><span class="n">TimerQueue</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">);</span> <span class="c1">//关闭关联的描述符
</span><span class="c1"></span>  <span class="c1">// do not remove channel, since we&#39;re in EventLoop::dtor();
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">TimerList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2022-12-07</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" data-title="muduo网络库源码学习" data-hashtags="muduo"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" data-hashtag="muduo"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" data-title="muduo网络库源码学习"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" data-title="muduo网络库源码学习"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" data-title="muduo网络库源码学习"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/muduo/">muduo</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/" class="prev" rel="prev" title="大并发服务器开发"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>大并发服务器开发</a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022</span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"data":{"id-1":"Home","id-2":"Home"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
