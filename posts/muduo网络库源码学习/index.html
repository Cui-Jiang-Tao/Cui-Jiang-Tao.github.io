<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>muduo网络库源码学习 - vstk的网站</title><meta name="author" content="cjt">
<meta name="author-link" content="">
<meta name="description" content="第二部分：Muduo网络库 10. 初探EventLoop 10.1 什么都不做的EventLoop 一个EventLoop就是一个事件循环，下面将通过一个&q" /><meta name="keywords" content='muduo' /><meta itemprop="name" content="muduo网络库源码学习">
<meta itemprop="description" content="第二部分：Muduo网络库 10. 初探EventLoop 10.1 什么都不做的EventLoop 一个EventLoop就是一个事件循环，下面将通过一个&q"><meta itemprop="datePublished" content="2022-12-06T00:00:00+00:00" />
<meta itemprop="dateModified" content="2022-12-12T00:00:00+00:00" />
<meta itemprop="wordCount" content="35643">
<meta itemprop="keywords" content="muduo," /><meta property="og:title" content="muduo网络库源码学习" />
<meta property="og:description" content="第二部分：Muduo网络库 10. 初探EventLoop 10.1 什么都不做的EventLoop 一个EventLoop就是一个事件循环，下面将通过一个&q" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-06T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-12-12T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="muduo网络库源码学习"/>
<meta name="twitter:description" content="第二部分：Muduo网络库 10. 初探EventLoop 10.1 什么都不做的EventLoop 一个EventLoop就是一个事件循环，下面将通过一个&q"/>
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" /><link rel="prev" href="https://cui-jiang-tao.github.io/posts/c&#43;&#43;_primer_5th/" /><link rel="next" href="https://cui-jiang-tao.github.io/posts/hugo%E6%90%AD%E5%BB%BA/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "muduo网络库源码学习",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/cui-jiang-tao.github.io\/posts\/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0\/"
    },"genre": "posts","keywords": "muduo","wordcount":  35643 ,
    "url": "https:\/\/cui-jiang-tao.github.io\/posts\/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0\/","datePublished": "2022-12-06T00:00:00+00:00","dateModified": "2022-12-12T00:00:00+00:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "cjt"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="fixed" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="vstk的网站"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span><span id="typeit-header-desktop" class="typeit"></span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              >文章</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              >标签</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              >分类</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="Search titles or contents ..." id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
              <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
              <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
            </span>
          </li><li class="menu-item theme-switch" title="Switch Theme">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li>
      </ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="vstk的网站"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span><span id="typeit-header-title-mobile" class="typeit"></span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="Search titles or contents ..." id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              Cancel
            </a>
          </li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                >文章</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                >标签</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                >分类</a></li><li class="menu-item theme-switch" title="Switch Theme">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
  </div>
  <div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
  </div><main class="container" data-page-style="wide"><aside class="toc" id="toc-auto"><h2 class="toc-title">Contents&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside>

  <aside class="aside-custom">
    </aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX">
        <span>muduo网络库源码学习</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><img
    class="lazyload avatar"
    src="/svg/loading.min.svg"
    data-src="https://www.gravatar.com/avatar/736cc0685dbd22dd674add9c481fc755?s=32&amp;d="
    data-srcset="https://www.gravatar.com/avatar/736cc0685dbd22dd674add9c481fc755?s=32&amp;d=, https://www.gravatar.com/avatar/736cc0685dbd22dd674add9c481fc755?s=32&amp;d= 1.5x, https://www.gravatar.com/avatar/736cc0685dbd22dd674add9c481fc755?s=32&amp;d= 2x"
    data-sizes="auto"
    alt="cjt"
    title="cjt"/>&nbsp;cjt</span></span>
          <span class="post-category">included in <a href="/categories/c/c++/"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> c/c++</a></span></div>
      <div class="post-meta-line"><span title=2022-12-06&#32;00:00:00><i class="fa-regular fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-12-06">2022-12-06</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw" aria-hidden="true"></i> 35643 words</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw" aria-hidden="true"></i> 72 minutes</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>Contents</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#10-初探eventloop">10. 初探EventLoop</a>
      <ul>
        <li><a href="#101-什么都不做的eventloop">10.1 什么都不做的EventLoop</a></li>
        <li><a href="#102-one-loop-per-thread">10.2 one loop per thread</a></li>
        <li><a href="#103-事件循环">10.3 事件循环</a></li>
      </ul>
    </li>
    <li><a href="#11-channel分析">11. Channel分析</a>
      <ul>
        <li><a href="#111-channel与文件描述符">11.1 Channel与文件描述符</a></li>
        <li><a href="#112-设置监听回调函数">11.2 设置监听回调函数</a></li>
        <li><a href="#113-channel与eventloop关系">11.3 Channel与EventLoop关系</a></li>
        <li><a href="#114-响应事件">11.4 响应事件</a></li>
      </ul>
    </li>
    <li><a href="#12-poller">12. Poller</a>
      <ul>
        <li><a href="#121-poller">12.1 Poller</a></li>
        <li><a href="#122-poller分析">12.2 Poller分析</a>
          <ul>
            <li><a href="#1221-pollpoller和eventloop关系">12.2.1 PollPoller和EventLoop关系</a></li>
            <li><a href="#1222-pollpoller和channel的关系">12.2.2 PollPoller和Channel的关系</a></li>
            <li><a href="#1223-update-和-remove-channel">12.2.3 update 和 remove Channel</a></li>
            <li><a href="#1224-poll">12.2.4 poll</a></li>
          </ul>
        </li>
        <li><a href="#123-epollpoller-分析">12.3 EPollPoller 分析</a>
          <ul>
            <li><a href="#1231-epollpoller和eventloop关系">12.3.1 EPollPoller和EventLoop关系</a></li>
            <li><a href="#1232-epollpoller和channel的关系">12.3.2 EPollPoller和Channel的关系</a></li>
            <li><a href="#1233-update-和-remove-channel">12.3.3 update 和 remove Channel</a></li>
            <li><a href="#1234-poll">12.3.4 poll</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#13-定时器">13. 定时器</a>
      <ul>
        <li><a href="#131-timerfd_系列定时器">13.1 timerfd_*系列定时器</a></li>
        <li><a href="#132-timer-分析">13.2 Timer 分析</a></li>
        <li><a href="#133-timerid-分析">13.3 TimerId 分析</a></li>
        <li><a href="#134-timerqueue">13.4 TimerQueue</a>
          <ul>
            <li><a href="#1341-timerqueue-设计原理">13.4.1 TimerQueue 设计原理</a></li>
            <li><a href="#1342-向timerqueue-中添加一个timer">13.4.2 向TimerQueue 中添加一个Timer</a></li>
            <li><a href="#1343-获取超时timer">13.4.3 获取超时Timer</a></li>
            <li><a href="#1344-向timerqueue-中取消一个timer">13.4.4 向TimerQueue 中取消一个Timer</a></li>
            <li><a href="#1345-重置超时timer">13.4.5 重置超时Timer</a></li>
            <li><a href="#1346-析构函数与资源销毁">13.4.6 析构函数与资源销毁</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#14-深入-eventloop">14. 深入 EventLoop</a>
      <ul>
        <li><a href="#141-eventloop-与-channel">14.1 EventLoop 与 Channel</a></li>
        <li><a href="#142-eventloop-与-timerqueue">14.2 EventLoop 与 TimerQueue</a></li>
        <li><a href="#143-eventloop-与-poller">14.3 EventLoop 与 Poller</a></li>
        <li><a href="#144-跨线程执行函数">14.4 跨线程执行函数</a></li>
        <li><a href="#145-析构函数与资源销毁">14.5 析构函数与资源销毁</a></li>
      </ul>
    </li>
    <li><a href="#15-muduo-事件监听总结">15. muduo 事件监听总结</a>
      <ul>
        <li><a href="#151-channel及其文件描述符如何加入到poller中">15.1 Channel及其文件描述符如何加入到Poller中</a></li>
        <li><a href="#152-eventloop如何获取活跃的channel并处理相关事件">15.2 EventLoop如何获取活跃的Channel并处理相关事件</a></li>
        <li><a href="#153-eventloop如何处理定时器">15.3 EventLoop如何处理定时器</a></li>
        <li><a href="#154-eventloop与跨线程调用函数">15.4 EventLoop与跨线程调用函数</a></li>
      </ul>
    </li>
    <li><a href="#16-eventloopthread">16. EventLoopThread</a></li>
    <li><a href="#17-eventloopthreadpool">17. EventLoopThreadPool</a></li>
    <li><a href="#18-网络套接字相关">18. 网络套接字相关</a>
      <ul>
        <li><a href="#181-sockets">18.1 sockets</a></li>
        <li><a href="#182-inetaddress">18.2 InetAddress</a></li>
        <li><a href="#183-socket">18.3 Socket</a></li>
      </ul>
    </li>
    <li><a href="#19-buffer的设计">19. Buffer的设计</a></li>
    <li><a href="#20-acceptor-分析">20. Acceptor 分析</a></li>
    <li><a href="#21-tcpconnection">21. TcpConnection</a>
      <ul>
        <li><a href="#211-设计思想">21.1 设计思想</a></li>
        <li><a href="#212-tcp-网络编程的本质">21.2 TCP 网络编程的本质</a></li>
        <li><a href="#213-发送和接收缓冲区">21.3 发送和接收缓冲区</a></li>
        <li><a href="#214-连接事件处理">21.4 连接事件处理</a></li>
        <li><a href="#215-读事件处理">21.5 &ldquo;读&quot;事件处理</a></li>
        <li><a href="#216-发送数据">21.6 发送数据</a></li>
        <li><a href="#217-写事件处理">21.7 &ldquo;写&quot;事件处理</a></li>
      </ul>
    </li>
    <li><a href="#22-tcpserver">22. TcpServer</a>
      <ul>
        <li><a href="#221-io-线程">22.1 I/O 线程</a></li>
        <li><a href="#222-acceptor">22.2 Acceptor</a></li>
        <li><a href="#223-启动服务器">22.3 启动服务器</a></li>
        <li><a href="#224-处理客户端连接">22.4 处理客户端连接</a></li>
        <li><a href="#225-释放资源">22.5 释放资源</a></li>
      </ul>
    </li>
    <li><a href="#23-connector">23. Connector</a>
      <ul>
        <li><a href="#231-设计思想">23.1 设计思想</a></li>
        <li><a href="#232-连接服务端">23.2 连接服务端</a></li>
        <li><a href="#233-错误处理与重连">23.3 错误处理与重连</a></li>
        <li><a href="#234-处理写事件">23.4 处理&quot;写&quot;事件</a></li>
        <li><a href="#235-重置连接">23.5 重置连接</a></li>
      </ul>
    </li>
    <li><a href="#24-tcpclient">24. TcpClient</a></li>
    <li><a href="#25-阶段性总结">25. 阶段性总结</a></li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><h1 id="第二部分muduo网络库">第二部分：Muduo网络库</h1>
<h2 id="10-初探eventloop">10. 初探EventLoop</h2>
<h3 id="101-什么都不做的eventloop">10.1 什么都不做的EventLoop</h3>
<p>一个EventLoop就是一个事件循环，下面将通过一个&quot;什么都不做的EventLoop&quot;来大致描述下muduo中EventLoop的功能。</p>
<p>&ldquo;什么都不做的EventLoop&quot;有如下几个特点：</p>
<ul>
<li>one loop per thread意思是说每个线程最多只能有一个EventLoop对象。</li>
<li>EventLoop对象构造的时候，会检查当前线程是否已经创建了其他EventLoop对象，如果已创建，终止程序(LOG_FATAL)</li>
<li>EventLoop构造函数会记住本对象所属线程(threadId_)。</li>
<li>创建了EventLoop对象的线程称为IO线程，其功能是运行事件循环(EventLoop::loop)</li>
</ul>
<h3 id="102-one-loop-per-thread">10.2 one loop per thread</h3>
<p>这里指的是一个EventLoop只属于一个线程(但一个线程可以拥有多个EventLoop)，在muduo中，如果EventLoop一旦被创建，EventLoop会保持所属线程的一份tid拷贝，作为标识。如果该EventLoop被其他线程调用则会报错，muduo中使用EventLoop::assertInLoopThread()函数来判断该EventLoop对象是否是在所属线程中执行。</p>
<h3 id="103-事件循环">10.3 事件循环</h3>
<p>一个EventLoop里其实是调用了poll/epoll来跟踪所关注的文件描述符的，当有文件描述符上有事件发生时，EventLoop会得到那些发生事件的文件描述符信息。</p>
<h2 id="11-channel分析">11. Channel分析</h2>
<p>Channel，可以理解为是一个&quot;通道&rdquo;，该&quot;通道&quot;中绑定了一个文件描述符及其所关注事件、注册的读写事件等信息。</p>
<h3 id="111-channel与文件描述符">11.1 Channel与文件描述符</h3>
<p>一个Channel管理一个文件描述符，在创建Channel时需要指定：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Channel</span><span class="o">::</span><span class="n">Channel</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd__</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">fd_</span><span class="p">(</span><span class="n">fd__</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该文件描述符的关注事件可以用如下代码表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">Channel</span><span class="o">::</span><span class="n">kNoneEvent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                <span class="c1">//没有事件：0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">Channel</span><span class="o">::</span><span class="n">kReadEvent</span> <span class="o">=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLPRI</span><span class="p">;</span> <span class="c1">//可读事件：3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">Channel</span><span class="o">::</span><span class="n">kWriteEvent</span> <span class="o">=</span> <span class="n">POLLOUT</span><span class="p">;</span>         <span class="c1">//可写事件：4
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在Channel内部也定义了events_和revents_来标记文件描述符所关注的事件以及实际发生的事件，该方法和struct pollfd 结构体类似：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">events_</span><span class="p">;</span>  <span class="c1">// 关注的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">revents_</span><span class="p">;</span> <span class="c1">// poll/epoll返回的事件，即实际监听到发生的事件类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>muduo提供了下面这些函数来设置文件描述符关注事件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">enableReading</span><span class="p">()</span> <span class="p">{</span> <span class="n">events_</span> <span class="o">|=</span> <span class="n">kReadEvent</span><span class="p">;</span> <span class="n">update</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">enableWriting</span><span class="p">()</span> <span class="p">{</span> <span class="n">events_</span> <span class="o">|=</span> <span class="n">kWriteEvent</span><span class="p">;</span> <span class="n">update</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">disableWriting</span><span class="p">()</span> <span class="p">{</span> <span class="n">events_</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">kWriteEvent</span><span class="p">;</span> <span class="n">update</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">disableAll</span><span class="p">()</span> <span class="p">{</span> <span class="n">events_</span> <span class="o">=</span> <span class="n">kNoneEvent</span><span class="p">;</span> <span class="n">update</span><span class="p">();</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中update函数的作用就是将该Channel及其绑定的文件描述符和EventLoop中的poll/epoll关联起来。</p>
<p>muduo也提供了下面函数来获取和设置文件描述符及其事件的状态，其中需要注意的是set_revents函数，该函数是被poll/epoll类中调用的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">fd</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fd_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">events</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">events_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">set_revents</span><span class="p">(</span><span class="kt">int</span> <span class="n">revt</span><span class="p">)</span> <span class="p">{</span> <span class="n">revents_</span> <span class="o">=</span> <span class="n">revt</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// used by pollers
</span></span></span><span class="line"><span class="cl"><span class="c1">// int revents() const { return revents_; }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">isNoneEvent</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">events_</span> <span class="o">==</span> <span class="n">kNoneEvent</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="112-设置监听回调函数">11.2 设置监听回调函数</h3>
<p>Channel中可以设置读、写、错误和关闭事件的回调函数，通过函数模板的方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">EventCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Timestamp</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ReadEventCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ReadEventCallback</span> <span class="n">readCallback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">EventCallback</span> <span class="n">writeCallback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">EventCallback</span> <span class="n">closeCallback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">EventCallback</span> <span class="n">errorCallback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setReadCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadEventCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">readCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setWriteCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">EventCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">writeCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setCloseCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">EventCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">closeCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setErrorCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">EventCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">errorCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="113-channel与eventloop关系">11.3 Channel与EventLoop关系</h3>
<p>一个Channel一定会关联一个EventLoop，和文件描述符一样，在构造函数中需要传入。一旦关联该EventLoop，EventLoop就可对该Channel操作。</p>
<h3 id="114-响应事件">11.4 响应事件</h3>
<p>muduo中定义了该函数来响应Channel所绑定的文件描述符发生事件及其回调函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//处理绑定的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Channel</span><span class="o">::</span><span class="n">handleEvent</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">tied_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">guard</span> <span class="o">=</span> <span class="n">tie_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">//确定shared_ptr指针还存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">guard</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">handleEventWithGuard</span><span class="p">(</span><span class="n">receiveTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">handleEventWithGuard</span><span class="p">(</span><span class="n">receiveTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * poll函数的事件标志符值：
</span></span></span><span class="line"><span class="cl"><span class="cm">*    常量	                 说明
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLIN	        普通或优先级带数据可读
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLRDNORM    	普通数据可读
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLRDBAND    	优先级带数据可读
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLPRI	        高优先级数据可读
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLOUT	        普通数据可写
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLWRNORM	    普通数据可写
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLWRBAND	    优先级带数据可写
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLERR	        发生错误
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLHUP	        对方描述符挂起
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLNVAL	    描述字不是一个打开的文件
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="c1">//开始选择性处理Channel对象绑定的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Channel</span><span class="o">::</span><span class="n">handleEventWithGuard</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">eventHandling_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">//处于处理事件中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// close
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">((</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="n">POLLHUP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">logHup_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_WARN</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Channel::handle_event() POLLHUP&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//符合关闭套接字的事件，回调close函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">closeCallback_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">closeCallback_</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//Invalid polling request.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="n">POLLNVAL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_WARN</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Channel::handle_event() POLLNVAL&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLNVAL</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">errorCallback_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">errorCallback_</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// read
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLPRI</span> <span class="o">|</span> <span class="n">POLLRDHUP</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">readCallback_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">readCallback_</span><span class="p">(</span><span class="n">receiveTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="n">POLLOUT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">writeCallback_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">writeCallback_</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">eventHandling_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//事件已处理完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数会根据revents_判断该文件描述符上实际发生的事件类型，然后调用相关的注册的回调函数。例如如果是有POLLIN(读事件)产生，那么将调用readCallback_回调函数。</p>
<p>那么什么时候handleEvent函数会执行呢，在poll/epoll返回时，EventLoop对象在loop循环中会拿到有事件发生的Channel集合，并逐一执行它们的handleEvent函数。</p>
<h2 id="12-poller">12. Poller</h2>
<h3 id="121-poller">12.1 Poller</h3>
<p>Poller是一个抽象类，指的是muduo封装的PollPoller、EPollPoller及其父类Poller的总称。在muduo中定义了一个Poller类，该类中定义了一些PollPoller和EPollPoller必须要实现的函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">virtual</span> <span class="n">Timestamp</span> <span class="nf">poll</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMs</span><span class="p">,</span> <span class="n">ChannelList</span><span class="o">*</span> <span class="n">activeChannels</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">updateChannel</span><span class="p">(</span><span class="n">Channel</span><span class="o">*</span> <span class="n">channel</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">removeChannel</span><span class="p">(</span><span class="n">Channel</span><span class="o">*</span> <span class="n">channel</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个Channel管理一个文件描述符fd的所有信息与操作，但如果要将文件描述符和poll/epoll关联和注册事件监听，Poller也需要关联Channel并提供相关操作的函数。但是由于poll/epoll的poll函数和操作的方法及其数据结构不同，所以这些具体的实现还是要放在PollPoller和EPollPoller中。</p>
<p>muduo提供了两种事件循环的类PollPoller和EPollPoller，同时也提供了该函数来选择使用哪一个：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Poller</span> <span class="o">*</span><span class="n">Poller</span><span class="o">::</span><span class="n">newDefaultPoller</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">getenv</span><span class="p">(</span><span class="s">&#34;MUDUO_USE_POLL&#34;</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nf">PollPoller</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nf">EPollPoller</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="122-poller分析">12.2 Poller分析</h3>
<h4 id="1221-pollpoller和eventloop关系">12.2.1 PollPoller和EventLoop关系</h4>
<p>一个EventLoop关联一个PollPoller，Channel的update会调用EventLoop的update函数，而EventLoop又调用Poller相关的函数。EventLoop之所以能够&quot;事件循环&quot;也是其内部调用Poller的poll函数。</p>
<h4 id="1222-pollpoller和channel的关系">12.2.2 PollPoller和Channel的关系</h4>
<p>Channel管理了一个文件描述符，在muduo中，一个Channel可以看作是一个文件描述符的&quot;代表&quot;，如果要操作一个文件描述符，则必须是通过该文件描述符对应的Channel。PollPoller需要监听和返回这些文件描述符上注册和实际发生的事件，所以必须提供操作Channel的函数和数据结构。下面这两个数据结构用于保存文件描述符及其Channel：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">struct</span> <span class="nc">pollfd</span><span class="o">&gt;</span> <span class="n">PollFdList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Channel</span><span class="o">*&gt;</span> <span class="n">ChannelMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PollFdList</span> <span class="n">pollfds_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ChannelMap</span> <span class="n">channels_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>pollfds_的作用非常明显，因为poll函数需要一个struct pollfd的数组地址，所以该结构是用于poll函数参数。</li>
<li>channels_则是用于管理注册的Channel的，key是Channel对应的文件描述符fd，value就是该Channel的地址，使用map数据结构可以很方便地对Channel进行查找和删除。</li>
</ul>
<h4 id="1223-update-和-remove-channel">12.2.3 update 和 remove Channel</h4>
<p><strong>1. updateChannel 函数</strong></p>
<p>由于需要更新一个Channel，所以该函数的参数只有Channel的一份指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 主要时将Channel负责的文件描述符(fd)注册到Poller对象中, 或更新Poller对象
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">PollPoller</span><span class="o">::</span><span class="n">updateChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Poller</span><span class="o">::</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; events = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// index &lt; 0说明是一个新的通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// a new one, add to pollfds_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">())</span> <span class="o">==</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">pollfd</span> <span class="n">pfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">pfd</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">pfd</span><span class="p">.</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// channel-&gt;revents()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pollfds_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">channels_</span><span class="p">[</span><span class="n">pfd</span><span class="p">.</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span> <span class="c1">//通过文件描述符(fd) 映射 Channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// update existing one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//已存在的Channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">())</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// index的取值必定在channels_.size()内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 更新pollfds_容器的信息(struct pollfd)
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">pollfd</span> <span class="o">&amp;</span><span class="n">pfd</span> <span class="o">=</span> <span class="n">pollfds_</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// pfd.fd == -1 代表此Chanel不需被Poller::poll检测
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">||</span> <span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">pfd</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">pfd</span><span class="p">.</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//如果不再关注该Channel中文件描述符事件，则直接将该文件描述符赋值为其相反数减一。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将一个通道暂时更改为不关注事件，但不从Poller中移除该通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">isNoneEvent</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// ignore this pollfd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 暂时忽略该文件描述符的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 这里pfd.fd 可以直接设置为-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 这样子设置是为了removeChannel优化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>channel-&gt;index() &lt; 0</code>分支：</p>
<ul>
<li>当一个Channel创建后默认设置自身的index_为-1，所以对于新创建的Channel如果被更新，那么一定是走<code>channel-&gt;index() &lt; 0</code>分支的。既然该Channel是刚创建并且是第一次和PollPoller关联，那么PollPoller中一定不会存在该Channel的信息，所以使用了该断言。</li>
<li>再接下来就是构造一个pollfd结构体并将该结构体的文件信息通过Channel保存起来，供下次poll函数调用。</li>
<li>需要注意的是，上面Channel的index_被设置为当前pollfds_的实际长度减一，这也是为了方便快速获取到pollfds_向量中的对应的文件描述符，有了该文件描述又可以很快从channels_中获取到该Channel，这个过程的代价很小，几乎不需要遍历。</li>
</ul>
<p>接下来分析<code>channel-&gt;index() &gt; 0</code> 的情况：</p>
<ul>
<li>发生这种情况也意味着该Channel之前已经注册到该PollPoller中了，但是由于一些原因需要修改该文件描述符的关注事件，对于这种情况的Channel将调用else分支代码。</li>
<li>代码中两个assert断言该Channel是否已经和PollPoller关联，如果关联则取出该pollfd数组中的该Channel对应的文件描述符及其结构体，更新该结构体中文件描述符监听事件。如果不再关注该Channel中文件描述符事件，则直接将该文件描述符赋值为其相反数减一。</li>
</ul>
<p><strong>2. removeChannel 函数</strong></p>
<p>使用该函数之前一般需要调用 updateChannel 函数设置不再关注该Channel对应的文件描述符上的事件。</p>
<p>该函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">PollPoller</span><span class="o">::</span><span class="n">removeChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Poller</span><span class="o">::</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">())</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">isNoneEvent</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="k">struct</span> <span class="nc">pollfd</span> <span class="o">&amp;</span><span class="n">pfd</span> <span class="o">=</span> <span class="n">pollfds_</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">pfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pfd</span><span class="p">.</span><span class="n">events</span> <span class="o">==</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">pollfds_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里移除的算法复杂度是O(1)，将待删除元素与最后一个元素交换再pop_back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">channelAtEnd</span> <span class="o">=</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">iter_swap</span><span class="p">(</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//不再关注该Channel中文件描述符事件，通过这种方式获取原有的下标(key)位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">channelAtEnd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">channelAtEnd</span> <span class="o">=</span> <span class="o">-</span><span class="n">channelAtEnd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">channels_</span><span class="p">[</span><span class="n">channelAtEnd</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pollfds_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>首先三个断言确认该Channel已经和PollPoller关联而且确认该Channel上的文件描述符事件不再关注，然后找到该Channel文件描述符在pollfds_数组中的位置，将该Channel从Channels_中去除，将该文件描述符对应的pollfd从pollfds_数组中去除。</li>
<li>从pollfs_数组中去除一个pollfd，Muduo使用了一个技巧，如果要去除的pollfd结构是数组中的最后一个元素，则调用pop_back函数直接弹出，否则将该元素和数组中最后一个元素交换位置，然后弹出最后一个元素，这样保证了pollfds_数组元素是连续的，不存在中间缺失的情况。</li>
</ul>
<h4 id="1224-poll">12.2.4 poll</h4>
<p>poll函数是在EventLoop中调用的，EventLoop希望通过该函数获取到当前的活动Channel(文件描述符上有事件发生)集合，所以会传入一个ChannelList* activeChannels作为poll的参数，该结构是一个vector集合，保存Channel的地址，定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">*&gt;</span> <span class="n">ChannelList</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>poll函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * poll机制与select机制类似，通过管理文件描述符来进行轮询，效率更高，并且处理的连接个数不受内核的限制。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 通过poll的方式进行轮询，通过Poller::fillActiveChannels得到活跃事件
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">Timestamp</span> <span class="n">PollPoller</span><span class="o">::</span><span class="n">poll</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMs</span><span class="p">,</span> <span class="n">ChannelList</span> <span class="o">*</span><span class="n">activeChannels</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// XXX pollfds_ shouldn&#39;t change
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">numEvents</span> <span class="o">=</span> <span class="o">::</span><span class="n">poll</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">timeoutMs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="nf">now</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">numEvents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="n">numEvents</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; events happended&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fillActiveChannels</span><span class="p">(</span><span class="n">numEvents</span><span class="p">,</span> <span class="n">activeChannels</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">numEvents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; nothing happended&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;PollPoller::poll()&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>该函数的第一个参数是超时时间，第二个参数是EventLoop中需要的活动通道集合。该函数的内部也是调用了poll函数，当poll返回时，该函数会获取当前时间戳，作为函数返回值使用。</li>
</ul>
<p>poll的返回值：</p>
<ul>
<li>如果poll返回为0，则说明poll超时但没有发生任何事件；</li>
<li>如果poll为负值，则说明poll系统调用失败；</li>
<li>如果poll正常返回一个整数，则说明当前有文件描述符活动，需要获取这些文件描述符对应的Channel，并返回给EventLoop，这里使用了fillActiveChannels来获取这些活跃的通道；</li>
</ul>
<p>fillActiveChannels函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * struct pollfd {
</span></span></span><span class="line"><span class="cl"><span class="cm">    int fd;         	  // 用于检测的文件描述符
</span></span></span><span class="line"><span class="cl"><span class="cm">    short events;         // 等待的事件类型
</span></span></span><span class="line"><span class="cl"><span class="cm">    short revents;        // 实际发生的事件类型
</span></span></span><span class="line"><span class="cl"><span class="cm">  } ;
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">  通过fd 获得发生事件的Chanel集合
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">PollPoller</span><span class="o">::</span><span class="n">fillActiveChannels</span><span class="p">(</span><span class="kt">int</span> <span class="n">numEvents</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">ChannelList</span> <span class="o">*</span><span class="n">activeChannels</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">PollFdList</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">pfd</span> <span class="o">=</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="n">pfd</span> <span class="o">!=</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">numEvents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">pfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pfd</span><span class="o">-&gt;</span><span class="n">revents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">--</span><span class="n">numEvents</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">ChannelMap</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">pfd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">ch</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">==</span> <span class="n">pfd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_revents</span><span class="p">(</span><span class="n">pfd</span><span class="o">-&gt;</span><span class="n">revents</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// pfd-&gt;revents = 0;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">activeChannels</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是Channel的index_，在PollPoller中，如果index_为-1，则说明该Channel是新的需要加入的通道；如果index_&gt;0，则说明该Channel已经和PollPoller关联了，index_的值用于在pollfds_数组中查找文件描述符对应的pollfd如果index_为其他负值，则说明该文件描述符将不被关注，该Channel也将被移除。</p>
<h3 id="123-epollpoller-分析">12.3 EPollPoller 分析</h3>
<h4 id="1231-epollpoller和eventloop关系">12.3.1 EPollPoller和EventLoop关系</h4>
<p>一个EventLoop关联一个EPollPoller，Channel的update会调用EventLoop的update函数，而EventLoop又调用Poller相关的函数。EventLoop之所以能够&quot;事件循环&quot;也是其内部调用Poller的poll函数。</p>
<h4 id="1232-epollpoller和channel的关系">12.3.2 EPollPoller和Channel的关系</h4>
<p>Channel管理了一个文件描述符，在muduo中，一个Channel可以看作是一个文件描述符的&quot;代表&quot;，如果要操作一个文件描述符，则必须是通过该文件描述符对应的Channel。EPollPoller需要监听和返回这些文件描述符上注册和实际发生的事件，所以必须提供操作Channel的函数和数据结构。下面这两个数据结构用于保存文件描述符及其Channel：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">struct</span> <span class="nc">epoll_event</span><span class="o">&gt;</span> <span class="n">EventList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Channel</span><span class="o">*&gt;</span> <span class="n">ChannelMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventList</span> <span class="n">events_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ChannelMap</span> <span class="n">channels_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>EventList events_的作用非常明显，因为epoll函数需要一个struct epoll_event的数组地址，所以该结构是用于epoll_wait函数参数。ChannelMap channels_则是用于管理注册的Channel的，key是Channel对应的文件描述符fd，value就是该Channel的地址，使用map数据结构可以很方便的对Channel进行查找和操作。</p>
<h4 id="1233-update-和-remove-channel">12.3.3 update 和 remove Channel</h4>
<p><strong>1. updateChannel 函数</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//将Channel加入epoll中管理，updateChannel方法一定是I/O线程调用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">updateChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Poller</span><span class="o">::</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; events = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kNew</span> <span class="o">||</span> <span class="n">index</span> <span class="o">==</span> <span class="n">kDeleted</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// a new one, add with EPOLL_CTL_ADD
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kNew</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">==</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">channels_</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="c1">// index == kDeleted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//也就是说，当Channel对象的无事件，可以通过index_来标识为删除状态，并不会从channels_容器中移除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">kAdded</span><span class="p">);</span>     <span class="c1">//设置Channel对象为添加状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">update</span><span class="p">(</span><span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span> <span class="c1">//添加到epoll中监视
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// update existing one with EPOLL_CTL_MOD/DEL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//更新已存在的Channel描述符，修改或删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kAdded</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//当Channel对象不绑定事件，那么就从epoll的监视中移除，并设置Channel对象为删除状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">isNoneEvent</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">update</span><span class="p">(</span><span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">kDeleted</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">//更新epoll中监视的Channel对象的信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">update</span><span class="p">(</span><span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数的作用和PollPoller函数作用是一样的。当一个Channel的index_为-1时则说明这个Channel并没有和EPollPoller关联，如果index_为2，则说明该通道被取消过关注，如果为1则说明该Channel已经和EPollPoller关联，需要更新相关文件描述符的一些监听事件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">kNew</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>        <span class="c1">//还没有和EPollPoller关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">kAdded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1">//该Channel已经和EPollPoller关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">kDeleted</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>     <span class="c1">//该通道被取消关注
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果index_是kNew或者kDeleted，则说明需要将该通道和该EPollPoller关联，设置index_为kAdded，然后调用update函数将该通道和EPollPoller关联：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//更新Channel对象绑定的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">operation</span><span class="p">,</span> <span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">epoll_event</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd_</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">operation</span> <span class="o">==</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;epoll_ctl op=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">operation</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; fd=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_SYSFATAL</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;epoll_ctl op=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">operation</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; fd=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>update函数内部也是调用了epoll_ctl函数。需要注意的是，epoll_event里并没有设置文件描述符，而是用了event.data.ptr指针保存了Channel，毕竟Channel中包含的文件描述符信息更加丰富。</p>
<p>如果index_已经是added状态，那么判断该Channel中文件描述符是否被设置为&quot;不关注&quot;，如果是的话，直接调用updata函数将该文件描述符移除epoll事件监听，否则更新该文件描述符结构的events监听事件。</p>
<p><strong>2. removeChannel 函数</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 将Channel对象从channels_容器和epoll监控中移除，此操作必须是I/O线程调用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">removeChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Poller</span><span class="o">::</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">isNoneEvent</span><span class="p">());</span> <span class="c1">//要移除的Channel对象本身一定是无事件的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 要移除的Channel对象应该就可能处于关联状态、也可能处于被取消关注状态(kDeleted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kAdded</span> <span class="o">||</span> <span class="n">index</span> <span class="o">==</span> <span class="n">kDeleted</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 处于关联状态，说明epoll还在监视它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kAdded</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">update</span><span class="p">(</span><span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 重新设置Channel为未被管理的初始状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">kNew</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数将取消对Channel对应的文件描述的事件监听，然后将该Channel从channels_中删除。</p>
<h4 id="1234-poll">12.3.4 poll</h4>
<p>poll函数是在EventLoop中调用的，EventLoop希望通过该函数获取到当前的活动Channel(文件描述符上有事件发生)集合，所以会传入一个ChannelList* activeChannels作为poll的参数，该结构是一个vector集合，保存Channel的地址，定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">*&gt;</span> <span class="n">ChannelList</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>poll函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Timestamp</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">poll</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMs</span><span class="p">,</span> <span class="n">ChannelList</span> <span class="o">*</span><span class="n">activeChannels</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//活跃的事件数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">numEvents</span> <span class="o">=</span> <span class="o">::</span><span class="n">epoll_wait</span><span class="p">(</span><span class="n">epollfd_</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">events_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                               <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">events_</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">timeoutMs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="nf">now</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">numEvents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="n">numEvents</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; events happended&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fillActiveChannels</span><span class="p">(</span><span class="n">numEvents</span><span class="p">,</span> <span class="n">activeChannels</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//活跃的事件数量太多了，扩容，动态调整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numEvents</span><span class="p">)</span> <span class="o">==</span> <span class="n">events_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">events_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">events_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">numEvents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; nothing happended&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// numEvents &lt; 0 的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;EPollPoller::poll()&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数的第一个参数是超时时间，第二个参数是EventLoop中需要的活动通道集合。该函数的内部也是调用了epoll_wait函数，该函数需要一个额外的文件描述符作为epollfd_，该文件描述符在构造函数初始化参数中中已经初始化了。</p>
<p>当epoll_wait返回时，获取当前时间戳，作为EPollPoller::poll函数返回值使用。</p>
<ul>
<li>如果epoll_wait返回为0，则说明epoll_wait超时且没有发生任何事件；</li>
<li>如果poll为负值，则说明poll系统调用失败；</li>
<li>如果poll正常返回一个整数，则说明当前有文件描述符活动，需要获取这些文件描述符对应的Channel，并返回给EventLoop，这里使用了fillActiveChannels来获取这些活跃的通道，当活跃的文件描述达到events_数组大小时，该数组将会扩容一倍，以满足更多需求，也减少了vector动态扩张的次数。</li>
</ul>
<p>fillActiveChannels函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">fillActiveChannels</span><span class="p">(</span><span class="kt">int</span> <span class="n">numEvents</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">ChannelList</span> <span class="o">*</span><span class="n">activeChannels</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//活跃的事件数量不可能比装所有事件的容器的元素数量多
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numEvents</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">events_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEvents</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Channel</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">events_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// NDEBUG模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#ifndef NDEBUG
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">ChannelMap</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_revents</span><span class="p">(</span><span class="n">events_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">activeChannels</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是EPollPoller的文件描述符epollfd_，由于EPollPoller是采用RAII技法编写的，在构造函数中创建了文件描述符epollfd_，那么在析构函数中也应该关闭epollfd_并释放资源：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EPollPoller</span><span class="o">::~</span><span class="n">EPollPoller</span><span class="p">()</span> <span class="p">{</span> <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">epollfd_</span><span class="p">);</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="13-定时器">13. 定时器</h2>
<p>muduo的定时器由三个类实现，TimerId、Timer、TimerQueue，用户只能看到第一个类，其它两个都是内部实现细节。</p>
<h3 id="131-timerfd_系列定时器">13.1 timerfd_*系列定时器</h3>
<p>muduo选择了timerfd_*系列作为定时器。</p>
<p>下面这组函数便是操作timerfd的系统调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/timerfd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">timerfd_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">clockid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">timerfd_settime</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="o">*</span><span class="n">new_value</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="o">*</span><span class="n">old_value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">timerfd_gettime</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="o">*</span><span class="n">curr_value</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>timerfd_create</strong>，它是用来创建一个定时器描述符timerfd</p>
<ul>
<li>第一个参数：clockid指定时间类型，有两个值：
<ul>
<li>CLOCK_REALTIME :Systemwide realtime clock. 系统范围内的实时时钟</li>
<li>CLOCK_MONOTONIC:以固定的速率运行，从不进行调整和复位 ,它不受任何系统time-of-day时钟修改的影响</li>
</ul>
</li>
<li>第二个参数：flags可以是0或者O_CLOEXEC/O_NONBLOCK。</li>
<li>返回值：timerfd(文件描述符)</li>
</ul>
<p><strong>timerfd_settime</strong>，该函数作用是用来启动或关闭有fd指定的定时器。在讲解该函数前，先理解两个相关结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">timespec</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">time_t</span> <span class="n">tv_sec</span><span class="p">;</span>      <span class="cm">/* Seconds */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span>   <span class="n">tv_nsec</span><span class="p">;</span>     <span class="cm">/* Nanoseconds */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">itimerspec</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">it_interval</span><span class="p">;</span>  <span class="cm">/* Interval for periodic timer */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">it_value</span><span class="p">;</span>     <span class="cm">/* Initial expiration */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二个结构体itimerspec就是timerfd要设置的超时结构体，它的成员it_value表示定时器第一次超时时间，it_interval表示之后的超时时间即每隔多长时间超时</p>
<p>下面正式分析该函数的参数和返回值：</p>
<p>参数：</p>
<ul>
<li>fd：timerfd，有timerfd_create函数返回</li>
<li>flags：1代表设置的是绝对时间；为0代表相对时间</li>
<li>fnew_value：指定新的超时时间，设定new_value.it_value非零则启动定时器，否则关闭定时器，如果new_value.it_interval为0，则定时器只定时一次，即初始那次，否则之后每隔设定时间超时一次</li>
<li>old_value：不为null，则返回定时器这次设置之前的超时时间</li>
</ul>
<p><strong>timerfd_gettime</strong>，此函数用于获得定时器距离下次超时还剩下的时间。如果调用时定时器已经到期，并且该定时器处于循环模式(设置超时时间时struct itimerspec::it_interval不为0)，那么调用此函数之后定时器重新开始计时。</p>
<h3 id="132-timer-分析">13.2 Timer 分析</h3>
<p>一个定时器会在某一个时刻执行某个任务，而且有可能是&quot;定时执行&quot;，所以，一个Timer里封装了该Timer的超时时间(定时时间)、任务的执行周期等信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">TimerCallback</span> <span class="n">callback_</span><span class="p">;</span>  <span class="c1">//定时执行函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Timestamp</span> <span class="n">expiration_</span><span class="p">;</span>          <span class="c1">// 超时时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">double</span> <span class="n">interval_</span><span class="p">;</span>         <span class="c1">// 执行间隔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">bool</span> <span class="n">repeat_</span><span class="p">;</span>             <span class="c1">// 是否重复定时执行任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int64_t</span> <span class="n">sequence_</span><span class="p">;</span>        <span class="c1">// 序列号，每个Tmier的序列号都不一样
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其中sequence_是通过对一个静态变量的原子增加来保证独一无二的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">AtomicInt64</span> <span class="n">s_numCreated_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该原子操作会在Timer构造函数初始化列表中完成初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Timer</span><span class="p">(</span><span class="k">const</span> <span class="n">TimerCallback</span><span class="o">&amp;</span> <span class="n">cb</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">when</span><span class="p">,</span> <span class="kt">double</span> <span class="n">interval</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">callback_</span><span class="p">(</span><span class="n">cb</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">expiration_</span><span class="p">(</span><span class="n">when</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">interval_</span><span class="p">(</span><span class="n">interval</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">repeat_</span><span class="p">(</span><span class="n">interval</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">sequence_</span><span class="p">(</span><span class="n">s_numCreated_</span><span class="p">.</span><span class="n">incrementAndGet</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Timer也提供了一些列函数来操作和获取这些变量值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">run</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">callback_</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//触发事件的时间戳
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Timestamp</span> <span class="nf">expiration</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">expiration_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">repeat</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">repeat_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="nf">sequence</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sequence_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">restart</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">numCreated</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s_numCreated_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果要重新设置该Timer的超时时间，可以通过下面这个函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果是重复的累加的，加入累加的时间重新设置到期时间，否则设置为失效时间
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Timer</span><span class="o">::</span><span class="n">restart</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">repeat_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 重新计算下一个超时时刻
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">expiration_</span> <span class="o">=</span> <span class="n">addTime</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">interval_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置无效的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">expiration_</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="o">::</span><span class="n">invalid</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="133-timerid-分析">13.3 TimerId 分析</h3>
<p>TimerId 中保存了一个Timer，以及该TimerId的序列号，同时将TimerQueue 设置为友元类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Timer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// An opaque identifier, for canceling Timer.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">TimerId</span> <span class="o">:</span> <span class="k">public</span> <span class="n">muduo</span><span class="o">::</span><span class="n">copyable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">TimerId</span><span class="p">()</span> <span class="o">:</span> <span class="n">timer_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">sequence_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">TimerId</span><span class="p">(</span><span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">seq</span><span class="p">)</span> <span class="o">:</span> <span class="n">timer_</span><span class="p">(</span><span class="n">timer</span><span class="p">),</span> <span class="n">sequence_</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// default copy-ctor, dtor and assignment are okay
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">class</span> <span class="nc">TimerQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timer</span> <span class="o">*</span><span class="n">timer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">sequence_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="134-timerqueue">13.4 TimerQueue</h3>
<h4 id="1341-timerqueue-设计原理">13.4.1 TimerQueue 设计原理</h4>
<p>一个TimerQueue 会关联一个EventLoop，一个TimerQueue中会绑定一个文件描述符timerfd以及Channel。该TimerQueue中保存众多的Timer，并且将这些Timer根据其超时时间从小到大放入一个集合中，其中最近超时时间将设置为timerfd的超时时间(也就是说将最近超时时间关联到timerfd上)，到了该时间，timerfd上会有读事件发生，然后定时器会将定时在该超时时间到真正处理该读事件之间的Timer获取到，执行这些Timer的定时函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// FIXME: use unique_ptr&lt;Timer&gt; instead of raw pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1">// unique_ptr是C++ 11标准的一个独享所有权的智能指针
</span></span></span><span class="line"><span class="cl"><span class="c1">// 无法得到指向同一对象的两个unique_ptr指针
</span></span></span><span class="line"><span class="cl"><span class="c1">// 但可以进行移动构造与移动赋值操作，即所有权可以移动到另一个对象(而非拷贝构造)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">Timer</span> <span class="o">*&gt;</span> <span class="n">Entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">TimerList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Timer</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">ActiveTimer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">ActiveTimer</span><span class="o">&gt;</span> <span class="n">ActiveTimerSet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span> <span class="c1">// 所属EventLoop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">timerfd_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Channel</span> <span class="n">timerfdChannel_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Timer list sorted by expiration
</span></span></span><span class="line"><span class="cl"><span class="c1">// set中的元素都是排好序的, 用于存储Timer，同时将Timer的到期时间戳作为key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TimerList</span> <span class="n">timers_</span><span class="p">;</span> <span class="c1">// timers_是按到期时间排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// for cancel()
</span></span></span><span class="line"><span class="cl"><span class="c1">// timers_与activeTimers_保存的是相同的数据 =》 利于操作，空间换效率吧？？？
</span></span></span><span class="line"><span class="cl"><span class="c1">// timers_是按到期时间排序，activeTimers_是按对象地址排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ActiveTimerSet</span> <span class="n">activeTimers_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">callingExpiredTimers_</span><span class="p">;</span>      <span class="c1">//用来确定是否正在调用回调函数的定时器/* atomic */
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ActiveTimerSet</span> <span class="n">cancelingTimers_</span><span class="p">;</span> <span class="c1">// 保存的是被取消的定时器
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>TimerQueue 的构造函数如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 一个TimerQueue只对应一个Eventloop和一个内部构造的Channel(构造对象时，默认绑定一个定时器对象timerfd_)
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 同时设置Channel的回调函数TimerQueue::handleRead
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">TimerQueue</span><span class="o">::</span><span class="n">TimerQueue</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span> <span class="n">timerfd_</span><span class="p">(</span><span class="n">createTimerfd</span><span class="p">()),</span> <span class="n">timerfdChannel_</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">timerfd_</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">timers_</span><span class="p">(),</span> <span class="n">callingExpiredTimers_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">timerfdChannel_</span><span class="p">.</span><span class="n">setReadCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// we are always reading the timerfd, we disarm it with timerfd_settime.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">timerfdChannel_</span><span class="p">.</span><span class="n">enableReading</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>构造函数中使用了createTimerfd来创建一个定时器文件描述符，该函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 创建定时器，生成一个定时器对象，返回与之关联的文件描述符timerfd。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">createTimerfd</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">timerfd</span> <span class="o">=</span> <span class="o">::</span><span class="n">timerfd_create</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">TFD_NONBLOCK</span> <span class="o">|</span> <span class="n">TFD_CLOEXEC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">timerfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSFATAL</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed in timerfd_create&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">timerfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>构造函数中Channel绑定的&quot;读事件&quot;回调函数是TimerQueue::handleRead，该函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * I/O线程才可调用
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 用来设置关联的Channel的回调函数
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">handleRead</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="nf">now</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 清除该事件，避免一直触发，并记录触发TimerQueue::handleRead回调函数的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">readTimerfd</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 获取该时刻之前所有的定时器列表(即超时定时器列表)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">expired</span> <span class="o">=</span> <span class="n">getExpired</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">callingExpiredTimers_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// safe to callback outside critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expired</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">expired</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里回调定时器处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">callingExpiredTimers_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 不是一次性定时器，需要重启
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">reset</span><span class="p">(</span><span class="n">expired</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果定时器超时，那么将执行该回调函数，该回调函数会调用readTimerfd函数先处理文件描述符事件，readTimerfd 函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 清除定时器，避免一直触发，并记录传入的时间戳
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">readTimerfd</span><span class="p">(</span><span class="kt">int</span> <span class="n">timerfd</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint64_t</span> <span class="n">howmany</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">timerfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">howmany</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">howmany</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TimerQueue::handleRead() &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">howmany</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; at &#34;</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="n">now</span><span class="p">.</span><span class="n">toString</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">howmany</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_ERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TimerQueue::handleRead() reads &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="s">&#34; bytes instead of 8&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在处理完文件描述符读事件后调用getExpired函数获取从文件描述符事件发生到当前时间内超时的Timer，然后遍历该集合，获取到Timer并执行其run函数(run函数中执行的是Timer真正的定时函数)。处理完这些超时的Timer后调用reset函数来重置这些Timer的定时任务，因为有些Timer是设置为循环执行的，所以还要重新设置它们的下一次执行时间。</p>
<h4 id="1342-向timerqueue-中添加一个timer">13.4.2 向TimerQueue 中添加一个Timer</h4>
<p>TimerQueue使用addTimer函数来向队列中添加一个Timer：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 添加一个新Timer，并及时更新；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果TimerList中元素只有一个或插入的Timer最快到期，马上重新设置TimerQueue对象绑定的timerfd的超时时间
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">TimerId</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimer</span><span class="p">(</span><span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">when</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="kt">double</span> <span class="n">interval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 该对象将存储到TimerList中
</span></span></span><span class="line"><span class="cl"><span class="cm">   * =&gt; std::set&lt;std::pair&lt;Timestamp, Timer*&gt;&gt; TimerList;
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Timer</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">when</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimerInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timer</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// addTimerInLoop(timer);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nf">TimerId</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数需要传入一个定时回调函数，一个超时时间戳和定时周期，TimerCallback的原型如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">TimerCallback</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建一个Timer，然后通过EventLoop调用TimerQueue::addTimerInLoop函数，最后TimerQueue::addTimer返回一个TimerId。runInLoop的实现细节在后面章节会解释，addTimerInLoop函数的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * I/O线程才可调用
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimerInLoop</span><span class="p">(</span><span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 插入一个定时器，有可能会使得最早到期的定时器发生改变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">earliestChanged</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">earliestChanged</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 重置定时器的超时时刻(timerfd_settime)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">resetTimerfd</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数又调用了insert函数，insert定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 返回值，插入的Timer是否是最早到期的时间;说明：插入的Timer元素是有序timers_(set集合)的第一个元素或唯一的元素为true
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 功能：插入一个std::pair&lt;Timestamp，Timer*&gt;对象，将参数timer的到期时间戳作为std::pair的first，Timner对象作为sencond
</span></span></span><span class="line"><span class="cl"><span class="cm"> * activeTimers_ 和 timers_两个容器保存的Timer对象是一样的，仅仅内存分布不同而已
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 最早到期时间是否改变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">earliestChanged</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="n">when</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">TimerList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果timers_为空或者when小于timers_中的最早到期时间(这个插入的Timer是集合第一个到期的时间戳)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">timers_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">||</span> <span class="n">when</span> <span class="o">&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">earliestChanged</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 插入到timers_中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TimerList</span><span class="o">::</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">timers_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Entry</span><span class="p">(</span><span class="n">when</span><span class="p">,</span> <span class="n">timer</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// result.first代表插入的元素的iterator，result.second代表元素是否插入成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 插入到activeTimers_中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">ActiveTimerSet</span><span class="o">::</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">activeTimers_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ActiveTimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">earliestChanged</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>insert函数会获取到该Timer的超时时间，如果该Timer的超时时间是最近的(比之前从小到大排列的超时集合最小的还小)，说明该Timer的定时函数是最早执行的，所以设置标志earliestChanged = true，然后将该Timer加入到timers_和activeTimers_中，然后返回earliestChanged。</p>
<p>回到TimerQueue::addTimerInLoop函数，该函数在插入一个Timer后，判断earliestChanged，如果该项为true，那么也需要重新设置TimerQueue的timerfd_的定时时间，则调用resetTimerfd函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 重置定时器的超时时间，重新设置Timer文件描述符(Timerfd)的超时时间，启动或停止定时器
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">resetTimerfd</span><span class="p">(</span><span class="kt">int</span> <span class="n">timerfd</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">expiration</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// wake up loop by timerfd_settime()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="n">newValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="n">oldValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newValue</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">newValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldValue</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">oldValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">newValue</span><span class="p">.</span><span class="n">it_value</span> <span class="o">=</span> <span class="n">howMuchTimeFromNow</span><span class="p">(</span><span class="n">expiration</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//启动或停止定时器，依据newValue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">::</span><span class="n">timerfd_settime</span><span class="p">(</span><span class="n">timerfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newValue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;timerfd_settime()&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1343-获取超时timer">13.4.3 获取超时Timer</h4>
<p>getExpired函数会获取到将小于传入时间戳now的Timer，将这些Timer的Entry保存到一个vector中并返回，同时删除timers_和activeTimers_中的这些和Timer相关的部分。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * rvo优化
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 返回一个到期时间std::vector&lt;Entry&gt;的容器
</span></span></span><span class="line"><span class="cl"><span class="cm"> * =》typedef std::pair&lt;Timestamp,Timer*&gt; Entry;
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">getExpired</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">expired</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// std::pair作为set的key时，比较pair 是先比较first, first相同再比较second
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Entry</span> <span class="nf">sentry</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Timer</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">UINTPTR_MAX</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 返回第一个未到期的Timer的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// lower_bound的含义是返回第一个值&gt;=sentry的元素的iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 即*end &gt;= sentry，从而end-&gt;first &gt; now
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">TimerList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">sentry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// timers_的集合全是过期的时间戳，或者？？？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">timers_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">||</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 将到期的定时器插入到expired中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">,</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">expired</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 从timers_中移除到期的定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">timers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 从activeTimers_中移除到期的定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expired</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">expired</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ActiveTimer</span> <span class="nf">timer</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">expired</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1344-向timerqueue-中取消一个timer">13.4.4 向TimerQueue 中取消一个Timer</h4>
<p>muduo使用cancle来取消一个Timer：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancel</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timerId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancelInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timerId</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数又调用了TimerQueue::cancelInLoop：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * I/O线程才可调用
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancelInLoop</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timerId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ActiveTimer</span> <span class="nf">timer</span><span class="p">(</span><span class="n">timerId</span><span class="p">.</span><span class="n">timer_</span><span class="p">,</span> <span class="n">timerId</span><span class="p">.</span><span class="n">sequence_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 查找该定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ActiveTimerSet</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">Entry</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">(),</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span> <span class="c1">// FIXME: no delete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                      <span class="c1">// please,如果用了unique_ptr,这里就不需要手动删除了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">activeTimers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">callingExpiredTimers_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 已经到期，并且正在调用回调函数的定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数以TimerId的方式从TimerQueue中删除相关Timer内容，如果该当前TimerQueue已经有超时事件产生(handleRead中callingExpiredTimers_设置为true)，TimerQueue::getExpired会删除超时的Timer，那么还需要将该Timer保存到&quot;待取消定时器队列&quot;中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ActiveTimerSet</span> <span class="n">cancelingTimers_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1345-重置超时timer">13.4.5 重置超时Timer</h4>
<p>handleRead函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * I/O线程才可调用
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 用来设置关联的Channel的回调函数
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">handleRead</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="nf">now</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 清除该事件，避免一直触发，并记录触发TimerQueue::handleRead回调函数的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">readTimerfd</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 获取该时刻之前所有的定时器列表(即超时定时器列表)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">expired</span> <span class="o">=</span> <span class="n">getExpired</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">callingExpiredTimers_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// safe to callback outside critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expired</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">expired</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里回调定时器处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">callingExpiredTimers_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 不是一次性定时器，需要重启
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">reset</span><span class="p">(</span><span class="n">expired</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果已经去除队列中的超时定时器集合，这些集合的定时任务也处理完了之后还需要reset这些集合，因为一个定时器Timer可能设置了repeat_和interval_，需要重新设置下一次Timer的执行时间。reset函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 对已经过期的队列进行处理，如果是重复调用的，重新设置新的到期时间并加入Timer队列中继续监控；重新设置TimerQueue对象绑定的fd到期时间
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">reset</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">expired</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="n">nextExpire</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expired</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="n">it</span> <span class="o">!=</span> <span class="n">expired</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ActiveTimer</span> <span class="nf">timer</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果是重复的定时器并且是未取消定时器，则重启该定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">repeat</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="o">==</span> <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//如果是重复的累加的，加入累加的时间重新设置到期时间，否则设置为失效时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">restart</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//将累加后新的Timer插入到Timer队列中，继续监控
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 一次性定时器或者已被取消的定时器是不能重置的，因此删除该定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// FIXME move to a free list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">delete</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span> <span class="c1">// FIXME: no delete please
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timers_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// //得到队列中第一个要到期的时间，获取最早到期的定时器超时时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">nextExpire</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//队列中还未到期的时间是有效的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">nextExpire</span><span class="p">.</span><span class="n">valid</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 重置定时器的超时时刻(timerfd_settime)，重新设置TimerQueue对象绑定的fd到期时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">resetTimerfd</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">,</span> <span class="n">nextExpire</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数会检查这些超时的定时器Timer，如果是设置了repeat_为true并且不在&quot;取消定时器队列&quot;中则重置下一次定时器执行时间，否则(如一次性定时任务，或者取消了但未能避免执行)则直接删除。在执行handleRead时也会将cancelingTimers_清空。最后设置TimerQueue的timerfd_最近定时时间，准备下一次执行定时事件的到来。</p>
<h4 id="1346-析构函数与资源销毁">13.4.6 析构函数与资源销毁</h4>
<p>关闭timerfd_文件描述符，释放管理的所有Timer资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">TimerQueue</span><span class="o">::~</span><span class="n">TimerQueue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">);</span> <span class="c1">//关闭关联的描述符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// do not remove channel, since we&#39;re in EventLoop::dtor();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">TimerList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="14-深入-eventloop">14. 深入 EventLoop</h2>
<p>已经分析过一个&quot;什么都不做的EventLoop&quot;，muduo中的EventLoop有如下几个特点：</p>
<ul>
<li>one loop per thread意思是说每个线程最多只能有一个EventLoop对象。</li>
<li>EventLoop对象构造的时候，会检查当前线程是否已经创建了其他EventLoop对象，如果已创建，终止程序(LOG_FATAL)</li>
<li>EventLoop构造函数会记住本对象所属线程(threadId_)。</li>
<li>创建了EventLoop对象的线程称为IO线程，其功能是运行事件循环(EventLoop::loop)</li>
</ul>
<p>下面将深入具体分析muduo中的EventLoop的实现。</p>
<h3 id="141-eventloop-与-channel">14.1 EventLoop 与 Channel</h3>
<p>&ldquo;一个Channel会关联一个EventLoop&rdquo;，当Channel设置了监听文件描述符关注事件类型后会调用update函数，Channel中的update函数也是间接调用EventLoop的updateChannel函数，然后又间接调用Poller的updateChannel函数，该函数将会将该Channel及其相关文件描述符和Poller的事件监听联系。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//将Chanel注册到Poller对象的polldfs数组中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Channel</span><span class="o">::</span><span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">updateChannel</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">updateChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">ownerLoop</span><span class="p">()</span> <span class="o">==</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">poller_</span><span class="o">-&gt;</span><span class="n">updateChannel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样地，Channel的remove函数也是间接调用EventLoop的removeChannel函数来删除自身，Poller的removeChannel函数会取消该Channel及其文件描述符的事件监听，并不再保存该Channel及其文件描述符任何信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 调用这个函数之前确保调用disableAll
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Channel</span><span class="o">::</span><span class="n">remove</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">isNoneEvent</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">removeChannel</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">removeChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">ownerLoop</span><span class="p">()</span> <span class="o">==</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">eventHandling_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">currentActiveChannel_</span> <span class="o">==</span> <span class="n">channel</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">           <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">activeChannels_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">activeChannels_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">channel</span><span class="p">)</span> <span class="o">==</span>
</span></span><span class="line"><span class="cl">               <span class="n">activeChannels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">poller_</span><span class="o">-&gt;</span><span class="n">removeChannel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="142-eventloop-与-timerqueue">14.2 EventLoop 与 TimerQueue</h3>
<p>EventLoop中持有一个TimerQueue，并在构造函数中完成了该TimerQueue的初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">TimerQueue</span><span class="o">&gt;</span> <span class="n">timerQueue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">::</span><span class="n">EventLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">looping_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">timerQueue_</span><span class="p">(</span><span class="k">new</span> <span class="n">TimerQueue</span><span class="p">(</span><span class="k">this</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来是一组定时器操作函数，用于添加定时器任务：</p>
<p>EventLoop.h</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Runs callback at &#39;time&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Safe to call from other threads.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">//直接回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TimerId</span> <span class="nf">runAt</span><span class="p">(</span><span class="k">const</span> <span class="n">Timestamp</span> <span class="o">&amp;</span><span class="n">time</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Runs callback after @c delay seconds.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Safe to call from other threads.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">//延期回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TimerId</span> <span class="nf">runAfter</span><span class="p">(</span><span class="kt">double</span> <span class="n">delay</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Runs callback every @c interval seconds.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Safe to call from other threads.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">//以interval的频率回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TimerId</span> <span class="nf">runEvery</span><span class="p">(</span><span class="kt">double</span> <span class="n">interval</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Cancels the timer.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Safe to call from other threads.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">cancel</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timerId</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>EventLoop.cpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">TimerId</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">runAt</span><span class="p">(</span><span class="k">const</span> <span class="n">Timestamp</span> <span class="o">&amp;</span><span class="n">time</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">timerQueue_</span><span class="o">-&gt;</span><span class="n">addTimer</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">TimerId</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">runAfter</span><span class="p">(</span><span class="kt">double</span> <span class="n">delay</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="nf">time</span><span class="p">(</span><span class="n">addTime</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span> <span class="n">delay</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">runAt</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">TimerId</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">runEvery</span><span class="p">(</span><span class="kt">double</span> <span class="n">interval</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="nf">time</span><span class="p">(</span><span class="n">addTime</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span> <span class="n">interval</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">timerQueue_</span><span class="o">-&gt;</span><span class="n">addTimer</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">cancel</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timerId</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">timerQueue_</span><span class="o">-&gt;</span><span class="n">cancel</span><span class="p">(</span><span class="n">timerId</span><span class="p">);</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>本质上这些函数也是调用了TimerQueue的addTimer和cancel函数，需要关注的是addTimer和cancel函数内部都是通过EventLoop::runInLoop函数调用的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 添加一个新Timer，并及时更新；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果TimerList中元素只有一个或插入的Timer最快到期，马上重新设置TimerQueue对象绑定的timerfd的超时时间
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">TimerId</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimer</span><span class="p">(</span><span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">when</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="kt">double</span> <span class="n">interval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 该对象将存储到TimerList中
</span></span></span><span class="line"><span class="cl"><span class="cm">   * std::set&lt;std::pair&lt;Timestamp, std::unique_ptr&lt;Timer&gt;&gt;&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Timer</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">when</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimerInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timer</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// addTimerInLoop(timer);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nf">TimerId</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancel</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timerId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancelInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timerId</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// cancelInLoop(timerId);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用EventLoop::runInLoop能够保证该bind函数是在EventLoop所在线程内执行的，哪怕这个函数是在别的线程里被调用，关于EventLoop::runInLoop函数，后面的章节再分析它是如何实现跨线程安全调用的。</p>
<h3 id="143-eventloop-与-poller">14.3 EventLoop 与 Poller</h3>
<p>一个EventLoop持有一个poller：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Poller</span><span class="o">&gt;</span> <span class="n">poller_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">::</span><span class="n">EventLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">looping_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">poller_</span><span class="p">(</span><span class="n">Poller</span><span class="o">::</span><span class="n">newDefaultPoller</span><span class="p">(</span><span class="k">this</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Poller::newDefaultPoller会根据系统环境来选择是使用PollPoller还是EPollPoller：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Poller</span> <span class="o">*</span><span class="n">Poller</span><span class="o">::</span><span class="n">newDefaultPoller</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">getenv</span><span class="p">(</span><span class="s">&#34;MUDUO_USE_POLL&#34;</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nf">PollPoller</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nf">EPollPoller</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>EventLoop的核心函数loop便是调用了Poller的loop函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 事件循环，该函数不能跨线程调用
</span></span></span><span class="line"><span class="cl"><span class="c1">// 只能在创建该对象的线程中调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">looping_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 断言当前处于创建该对象的线程中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">looping_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">quit_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;EventLoop &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">this</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; start looping&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//::poll(NULL, 0, 5*1000);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">quit_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">activeChannels_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//执行完Poller::poll()的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pollReturnTime_</span> <span class="o">=</span> <span class="n">poller_</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">kPollTimeMs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">activeChannels_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//++iteration_;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">Logger</span><span class="o">::</span><span class="n">logLevel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">Logger</span><span class="o">::</span><span class="n">TRACE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">printActiveChannels</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO sort channel by priority
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">eventHandling_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">//标识事件正在处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">ChannelList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">activeChannels_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">         <span class="n">it</span> <span class="o">!=</span> <span class="n">activeChannels_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">currentActiveChannel_</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">currentActiveChannel_</span><span class="o">-&gt;</span><span class="n">handleEvent</span><span class="p">(</span><span class="n">pollReturnTime_</span><span class="p">);</span> <span class="c1">//事件处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">currentActiveChannel_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventHandling_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//标识事件已处理完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 让IO线程也能执行一些计算任务，IO不忙的时候，处于阻塞状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">doPendingFunctors</span><span class="p">();</span> <span class="c1">// 执行其他线程或者本线程添加的一些回调任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;EventLoop &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">this</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; stop looping&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">looping_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数通过调用Poller的poll函数，将活跃Channel保存到activeChannels_中，然后遍历这些Channel，执行它们的handleEvent函数，最后执行doPendingFunctors函数，该函数将在下一节介绍。</p>
<h3 id="144-跨线程执行函数">14.4 跨线程执行函数</h3>
<p>为了实现跨线程调用函数，muduo使用了如下数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">callingPendingFunctors_</span><span class="p">;</span> <span class="c1">//判断是否IO线程处理一些回调任务中=&gt;pendingFunctors_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">wakeupFd_</span><span class="p">;</span> <span class="c1">// 用于eventfd
</span></span></span><span class="line"><span class="cl"><span class="c1">// unlike in TimerQueue, which is an internal class,
</span></span></span><span class="line"><span class="cl"><span class="c1">// we don&#39;t expose Channel to client.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span> <span class="n">wakeupChannel_</span><span class="p">;</span> <span class="c1">// 该通道将会纳入poller_来管理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Functor</span><span class="o">&gt;</span> <span class="n">pendingFunctors_</span><span class="p">;</span> <span class="c1">// @BuardedBy mutex_   即将发生的回调，即在IO线程中执行需要执行回调函数集合
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>TimerQueue的更新和删除Timer会用到EventLoop::runInLoop函数，该函数的实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 在I/O线程中执行某个回调函数，该函数可以跨线程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">runInLoop</span><span class="p">(</span><span class="k">const</span> <span class="n">Functor</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">isInLoopThread</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果是当前IO线程调用runInLoop，则同步调用cb
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cb</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果是其它线程调用runInLoop，则异步地将cb添加到队列，以便让EventLoop所在的线程执行这个回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">queueInLoop</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以更新Timer为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimerInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timer</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果该代码时是在EventLoop所在线程中执行，那么TimerQueue::addTimerInLoop会立刻执行，否则TimerQueue::addTimerInLoop将通过queueInLoop函数送入到待执行函数队列中，queueInLoop定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">queueInLoop</span><span class="p">(</span><span class="k">const</span> <span class="n">Functor</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MutexLockGuard</span> <span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pendingFunctors_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 1. 调用queueInLoop的线程不是IO线程需要唤醒
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 2. 或者调用queueInLoop的线程是IO线程，并且此时正在调用任务队列(pendingFunctors_)，需要唤醒。
</span></span></span><span class="line"><span class="cl"><span class="cm">   *     =》 因为I/O处于callingPendingFunctors_状态，任务队列(pendingFunctors_)中的任务执行完可能会处于阻塞状态(poll没事件发生)，新加入的任务无法执行。
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 只有I/O线程的事件回调中调用queueInLoop才不需要唤醒
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInLoopThread</span><span class="p">()</span> <span class="o">||</span> <span class="n">callingPendingFunctors_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeup</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数会判断是否是在EventLoop所处线程中执行，如果不是的话则调用wakeup()函数。到这里先解释下跨线程调用的原理。一个EventLoop中有一个wakeupFd_文件描述符(eventfd 是一个比 pipe 更高效的线程间事件通知机制，一方面它比 pipe 少用一个 file descripor，节省了资源；另一方面，eventfd 的缓冲区管理也简单得多，全部&quot;buffer&quot; 只有定长8 bytes，不像 pipe 那样可能有不定长的真正 buffer)，该文件描述符在构造函数初始化列表中完成初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">createEventfd</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">evtfd</span> <span class="o">=</span> <span class="o">::</span><span class="n">eventfd</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EFD_NONBLOCK</span> <span class="o">|</span> <span class="n">EFD_CLOEXEC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">evtfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed in eventfd&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">abort</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">evtfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">::</span><span class="n">EventLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">looping_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeupFd_</span><span class="p">(</span><span class="n">createEventfd</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而且EventLoop也为该wakeuFd_文件描述符提供了一个Channel，该Channel的生命周期由EventLoop对象负责：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span> <span class="n">wakeupChannel_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该Channel也在构造函数中完成了初始化工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">::</span><span class="n">EventLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">looping_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeupFd_</span><span class="p">(</span><span class="n">createEventfd</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeupChannel_</span><span class="p">(</span><span class="k">new</span> <span class="n">Channel</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">wakeupFd_</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">wakeupChannel_</span><span class="o">-&gt;</span><span class="n">setReadCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EventLoop</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// we are always reading the wakeupfd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//这里设置会将wakeupChannel_注册到Poller对象中，实现事件循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">wakeupChannel_</span><span class="o">-&gt;</span><span class="n">enableReading</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该Channel也加入到了Poller事件监听中，并且设置了&quot;读事件&quot;回调函数为EventLoop::handleRead：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// eventfd 事件处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">handleRead</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint64_t</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">wakeupFd_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">one</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">one</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_ERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;EventLoop::handleRead() reads &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; bytes instead of 8&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在回到queueInLoop函数中，可以正式介绍wake()函数了，wakeup函数功能就是向wakeupFd_写入东西，然后促使Poller的poll函数返回：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 唤醒，写uint64_t类型的字节就可产生可读事件，达到唤醒的目的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">wakeup</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint64_t</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ssize_t n = sockets::write(wakeupFd_, &amp;one, sizeof one);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">wakeupFd_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">one</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">one</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_ERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;EventLoop::wakeup() writes &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; bytes instead of 8&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">quit_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">activeChannels_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">pollReturnTime_</span> <span class="o">=</span> <span class="n">poller_</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">kPollTimeMs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">activeChannels_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">doPendingFunctors</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后进而调用doPendingFunctors函数，在该函数中执行这些跨线程调用的&quot;未决函数&quot;：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//在IO线程中执行一些回调任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">doPendingFunctors</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Functor</span><span class="o">&gt;</span> <span class="n">functors</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">callingPendingFunctors_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MutexLockGuard</span> <span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//可以减小临界区的长度(意味着不会阻塞其它线程的queueInLoop())，另一方面，也避免了死锁(因为Functor可能再次调用queueInLoop())
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">functors</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">pendingFunctors_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">functors</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">functors</span><span class="p">[</span><span class="n">i</span><span class="p">]();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">callingPendingFunctors_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样即使是跨线程调用某些函数，这些函数也不会立刻执行，而是存入该pendingFunctors_集合中等待wake，然后在EventLoop线程中&quot;打包&quot;执行。</p>
<p>需要注意的是：</p>
<ul>
<li>不是简单地在临界区内依次调用Functor，而是把回调列表swap到functors中，这样一方面减小了临界区的长度(意味着不会阻塞其它线程的queueInLoop())，另一方面，也避免了死锁(因为Functor可能再次调用queueInLoop())</li>
<li>由于doPendingFunctors()调用的Functor可能再次调用queueInLoop(cb)，这时，queueInLoop()就必须wakeup()，否则新增的cb可能就不能及时调用了</li>
<li>muduo没有反复执行doPendingFunctors()直到pendingFunctors为空，这是有意的，否则IO线程可能陷入死循环，无法处理IO事件。</li>
</ul>
<h3 id="145-析构函数与资源销毁">14.5 析构函数与资源销毁</h3>
<p>整个EventLoop中创建了如下资源：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">::</span><span class="n">EventLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">looping_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">poller_</span><span class="p">(</span><span class="n">Poller</span><span class="o">::</span><span class="n">newDefaultPoller</span><span class="p">(</span><span class="k">this</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">timerQueue_</span><span class="p">(</span><span class="k">new</span> <span class="n">TimerQueue</span><span class="p">(</span><span class="k">this</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeupFd_</span><span class="p">(</span><span class="n">createEventfd</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeupChannel_</span><span class="p">(</span><span class="k">new</span> <span class="n">Channel</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">wakeupFd_</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然而这些资源除了wakeupFd_以外都是使用智能指针来管理的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Poller</span><span class="o">&gt;</span> <span class="n">poller_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">TimerQueue</span><span class="o">&gt;</span> <span class="n">timerQueue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">wakeupFd_</span><span class="p">;</span> <span class="c1">// 用于eventfd
</span></span></span><span class="line"><span class="cl"><span class="c1">// unlike in TimerQueue, which is an internal class,
</span></span></span><span class="line"><span class="cl"><span class="c1">// we don&#39;t expose Channel to client.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span> <span class="n">wakeupChannel_</span><span class="p">;</span> <span class="c1">// 该通道将会纳入poller_来管理
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>所以析构函数只需要释放wakeupFd_文件描述符即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">::~</span><span class="n">EventLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//析构，EventLoop对象一定不会是looping状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">looping_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">wakeupFd_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">t_loopInThisThread</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="15-muduo-事件监听总结">15. muduo 事件监听总结</h2>
<h3 id="151-channel及其文件描述符如何加入到poller中">15.1 Channel及其文件描述符如何加入到Poller中</h3>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="../../imgs/muduo/net_1.jpg"
    data-srcset="../../imgs/muduo/net_1.jpg, ../../imgs/muduo/net_1.jpg 1.5x, ../../imgs/muduo/net_1.jpg 2x"
    data-sizes="auto"
    alt="../../imgs/muduo/net_1.jpg"
    title="../../imgs/muduo/net_1.jpg"/></p>
<h3 id="152-eventloop如何获取活跃的channel并处理相关事件">15.2 EventLoop如何获取活跃的Channel并处理相关事件</h3>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="../../imgs/muduo/net_2.jpg"
    data-srcset="../../imgs/muduo/net_2.jpg, ../../imgs/muduo/net_2.jpg 1.5x, ../../imgs/muduo/net_2.jpg 2x"
    data-sizes="auto"
    alt="../../imgs/muduo/net_2.jpg"
    title="../../imgs/muduo/net_2.jpg"/></p>
<h3 id="153-eventloop如何处理定时器">15.3 EventLoop如何处理定时器</h3>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="../../imgs/muduo/net_3.jpg"
    data-srcset="../../imgs/muduo/net_3.jpg, ../../imgs/muduo/net_3.jpg 1.5x, ../../imgs/muduo/net_3.jpg 2x"
    data-sizes="auto"
    alt="../../imgs/muduo/net_3.jpg"
    title="../../imgs/muduo/net_3.jpg"/></p>
<h3 id="154-eventloop与跨线程调用函数">15.4 EventLoop与跨线程调用函数</h3>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="../../imgs/muduo/net_4.jpg"
    data-srcset="../../imgs/muduo/net_4.jpg, ../../imgs/muduo/net_4.jpg 1.5x, ../../imgs/muduo/net_4.jpg 2x"
    data-sizes="auto"
    alt="../../imgs/muduo/net_4.jpg"
    title="../../imgs/muduo/net_4.jpg"/></p>
<ul>
<li>调用queueInLoop的线程不是当前IO线程需要唤醒</li>
<li>或者调用queueInLoop的线程是当前IO线程，并且此时正在调用pending functor，需要唤醒</li>
<li>只有IO线程的事件回调中调用queueInLoop才不需要唤醒</li>
</ul>
<h2 id="16-eventloopthread">16. EventLoopThread</h2>
<p>任何一个线程，只要创建并运行了EventLoop，都称之为IO线程，所以IO线程不一定是主线程。</p>
<p>muduo并发模型one loop per thread + threadpool，为了方便今后使用，定义了EventLoopThread类，该类封装了IO线程。EventLoopThread创建了一个线程，然后在线程函数中创建了一个EvenLoop对象并调用EventLoop::loop。</p>
<p>由于该EventLoopThread类会在一个线程中启动一个EventLoop，所以持有如下变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="n">thread_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>构造函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoopThread</span><span class="o">::</span><span class="n">EventLoopThread</span><span class="p">(</span><span class="k">const</span> <span class="n">ThreadInitCallback</span><span class="o">&amp;</span> <span class="n">cb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">exiting_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">thread_</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EventLoopThread</span><span class="o">::</span><span class="n">threadFunc</span><span class="p">,</span> <span class="k">this</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">mutex_</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="n">cond_</span><span class="p">(</span><span class="n">mutex_</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">callback_</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从构造函数中可以看出，该EventLoop默认是没有初始化的，线程绑定的执行函数是EventLoopThread::threadFunc。除此之外，构造函数中还初始化了互斥锁和条件变量，它们作用会在后面分析。</p>
<p>构造函数中还传入了一个ThreadInitCallback类型的函数对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ThreadInitCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ThreadInitCallback</span> <span class="n">callback_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是用作线程启动初始化执行的用户函数，如果用户想在线程初始化时执行一些函数，那么就可以在EventLoopThread构造函数中传入该函数，默认情况下EventLoopThread会创建一个空函数作为线程初始化函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoopThread</span><span class="p">(</span><span class="k">const</span> <span class="n">ThreadInitCallback</span> <span class="o">&amp;</span><span class="n">cb</span> <span class="o">=</span> <span class="n">ThreadInitCallback</span><span class="p">());</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么，如何启动一个IO线程呢？使用EventLoopThread::startLoop便可以&quot;启动&quot;一个IO线程，这里的&quot;启动&quot;只的是启动IO线程，而不是线程，因为构造函数在已经初始化一个线程了，光启动该线程还不能称为&quot;IO线程&quot;，因为EventLoop还没有初始化，EventLoopThread::startLoop会通过条件变量一直等待，直到EventLoop被初始化，条件满足时才返回该EventLoop地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">EventLoopThread</span><span class="o">::</span><span class="n">startLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">thread_</span><span class="p">.</span><span class="n">started</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">thread_</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MutexLockGuard</span> <span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">loop_</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">cond_</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么EventLoop在哪里初始化，条件变量又如何被通知呢？这些问题都在线程执行函数中完成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoopThread</span><span class="o">::</span><span class="n">threadFunc</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 线程初始化函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">callback_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">callback_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MutexLockGuard</span> <span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// loop_指针指向了一个栈上的对象，threadFunc函数退出之后，这个指针就失效了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// threadFunc函数退出，就意味着线程退出了，EventLoopThread对象也就没有存在的价值了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因而不会有什么大的问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loop_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cond_</span><span class="p">.</span><span class="n">notify</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// assert(exiting_);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当EventLoopThread类创建后，会在构造函数阶段创建一个线程，而该线程便执行threadFunc函数，如果用户传入了&quot;线程初始化函数&quot;，那么在这里便会优先执行该函数，然后初始化所持有的EventLoop，并发让条件满足(loop_!=NULL)，然后启动EventLoop的事件循环(loop.loop())。</p>
<p>这一过程下来，当一个EventLoopThread 被创建后，该EventLoopThread 对象内部也创建并启动了一个EventLoop对象，用户代码需要startLoop函数来获取该EventLoop对象，然后让该EventLoop对象和一些Channel绑定，让Channel中的文件描述符加入事件监听中。所以该EventLoop可以在其他线程里被调用，这就是为什么EventLoop中还提供了runInLoop函数的原因，也为后续的EventLoopThreadPool做出铺垫。</p>
<blockquote>
<p>调用startLoop函数一定会发生在两个线程中，例如：main线程调用startLoop函数，那么startLoop内部会创建一个线程(可以理解为I/O线程)，startLoop函数返回的EventLoop对象一定是I/O线程线程创建的对象。</p>
</blockquote>
<p>最后的析构函数则做了些收尾工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoopThread</span><span class="o">::~</span><span class="n">EventLoopThread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">exiting_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">quit</span><span class="p">();</span> <span class="c1">// 退出IO线程，让IO线程的loop循环退出，从而退出了IO线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">thread_</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面是一个简单的使用案例，可以帮助理解EventLoopThread的使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoopThread.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">runInThread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;runInThread(): pid = %d, tid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main(): pid = %d, tid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">EventLoopThread</span> <span class="n">loopThread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loopThread</span><span class="p">.</span><span class="n">startLoop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 异步调用runInThread，即将runInThread添加到loop对象所在IO线程，让该IO线程执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">loop</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">runInThread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// runAfter内部也调用了runInLoop，所以这里也是异步调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">loop</span><span class="o">-&gt;</span><span class="n">runAfter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">runInThread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="o">-&gt;</span><span class="n">quit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;exit main().</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="17-eventloopthreadpool">17. EventLoopThreadPool</h2>
<p>该类的作用就是&quot;事先缓存多个EventLoopThread&quot;，所以该类中需要有保存这些EventLoopThread及其EventLoop的数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">ptr_vector</span><span class="o">&lt;</span><span class="n">EventLoopThread</span><span class="o">&gt;</span> <span class="n">threads_</span><span class="p">;</span> <span class="c1">// IO线程列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">EventLoop</span> <span class="o">*&gt;</span> <span class="n">loops_</span><span class="p">;</span>             <span class="c1">// EventLoop列表
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过setThreadNum函数来设置需要创建多少个IO线程(创建后的调整)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setThreadNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">numThreads</span><span class="p">)</span> <span class="p">{</span> <span class="n">numThreads_</span> <span class="o">=</span> <span class="n">numThreads</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果用户传入数量为0(默认构造函数中设置为0)，那么该EventLoopThreadPool就会作为IO线程，EventLoopThreadPool内也持有一个EventLoop：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoopThreadPool</span><span class="o">::</span><span class="n">EventLoopThreadPool</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">baseLoop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">baseLoop_</span><span class="p">(</span><span class="n">baseLoop</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">started_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">numThreads_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用EventLoopThreadPool::start函数创建numThreads_个EventLoopThread。如果numThreads_为0且有线程初始化函数需要执行，那么就在EventLoopThreadPool所处线程中执行该函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoopThreadPool</span><span class="o">::</span><span class="n">start</span><span class="p">(</span><span class="k">const</span> <span class="n">ThreadInitCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">started_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">baseLoop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">started_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">EventLoopThread</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EventLoopThread</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">threads_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">loops_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span><span class="o">-&gt;</span><span class="n">startLoop</span><span class="p">());</span> <span class="c1">// 启动EventLoopThread线程，在进入事件循环之前，会调用cb
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">numThreads_</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 只有一个EventLoop，在这个EventLoop进入事件循环之前，调用cb
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cb</span><span class="p">(</span><span class="n">baseLoop_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>考虑到负载均衡，该类还实现了一个基于轮询方法来选择要使用的EventLoop(IO线程)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">EventLoopThreadPool</span><span class="o">::</span><span class="n">getNextLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">baseLoop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">baseLoop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果loops_为空(即numThreads_为0)，则loop指向baseLoop_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果不为空，按照round-robin(RR，轮叫)的调度方式选择一个EventLoop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loops_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// round-robin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loop</span> <span class="o">=</span> <span class="n">loops_</span><span class="p">[</span><span class="n">next_</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">next_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">next_</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">loops_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">next_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="18-网络套接字相关">18. 网络套接字相关</h2>
<h3 id="181-sockets">18.1 sockets</h3>
<p>该类定义于SocketsOps.h中，它提供了众多对socket套接字操作的函数，该类比较简单，各个函数之间也很少互相调用，基本就是将网络套接字API封装了一遍：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Creates a non-blocking socket file descriptor,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// abort if any error.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 创建一个非阻塞套接字，如果创建失败就终止程序abort
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">createNonblockingOrDie</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bindOrDie</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">listenOrDie</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="nf">readv</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iovcnt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">shutdownWrite</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">toIpPort</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">toIp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">fromIpPort</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">getSocketError</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="nf">getLocalAddr</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="nf">getPeerAddr</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">isSelfConnect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="182-inetaddress">18.2 InetAddress</h3>
<p>该类主要提供了一些地址转换的函数(例如从网络字节序到本地字节序)。</p>
<h3 id="183-socket">18.3 Socket</h3>
<p>该类使用了前面两个类中的函数，主要是对socket套接字操作的进一步封装，还包括一些setsockopt的选项操作封装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">/// abort if address in use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">bindAddress</span><span class="p">(</span><span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">localaddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">/// abort if address in use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">listen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// On success, returns a non-negative integer that is
</span></span></span><span class="line"><span class="cl"><span class="c1">/// a descriptor for the accepted socket, which has been
</span></span></span><span class="line"><span class="cl"><span class="c1">/// set to non-blocking and close-on-exec. *peeraddr is assigned.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// On error, -1 is returned, and *peeraddr is untouched.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="n">InetAddress</span> <span class="o">*</span><span class="n">peeraddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">shutdownWrite</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// Nagle
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 算法是频繁发一些小的数据包，会攒在一起发送，合并包发送。一般来说这个延迟时间是200毫秒
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Enable/disable TCP_NODELAY (disable/enable Nagle&#39;s algorithm).
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">// Nagle算法可以一定程度上避免网络拥塞
</span></span></span><span class="line"><span class="cl"><span class="c1">// TCP_NODELAY选项可以禁用Nagle算法
</span></span></span><span class="line"><span class="cl"><span class="c1">// 禁用Nagle算法，可以避免连续发包出现延迟，这对于编写低延迟的网络服务很重要
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setTcpNoDelay</span><span class="p">(</span><span class="kt">bool</span> <span class="n">on</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Enable/disable SO_REUSEADDR
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setReuseAddr</span><span class="p">(</span><span class="kt">bool</span> <span class="n">on</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Enable/disable SO_KEEPALIVE
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">//TCP keepalive是指定期探测连接是否存在，如果应用层有心跳的话，这个选项不是必需要设置的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setKeepAlive</span><span class="p">(</span><span class="kt">bool</span> <span class="n">on</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="19-buffer的设计">19. Buffer的设计</h2>
<h2 id="20-acceptor-分析">20. Acceptor 分析</h2>
<p>套接字TCP服务器编程中，服务器需要一个监听套接字，该套接字用于监听客户端连接。</p>
<p>&ldquo;监听套接字&quot;也是一个文件描述符，一个文件描述符在muduo中应该和一个Channel联系。<strong>muduo网络库将专用于监听连接的套接字操作封装成了Acceptor</strong>。所以一个Acceptor中一定会有一个套接字socket和一个Channel，有了Channel一定会关联一个EventLoop：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Socket</span> <span class="n">acceptSocket_</span><span class="p">;</span>   <span class="c1">// listening socket(即server socket)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Channel</span> <span class="n">acceptChannel_</span><span class="p">;</span> <span class="c1">// 用于观察acceptSocket_的readable事件，并回调Accptor::handleRead()
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其构造函数如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Acceptor</span><span class="o">::</span><span class="n">Acceptor</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span> <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">listenAddr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">acceptSocket_</span><span class="p">(</span><span class="n">sockets</span><span class="o">::</span><span class="n">createNonblockingOrDie</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Channel对象都是通过EventLoop对象注册的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">acceptChannel_</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">acceptSocket_</span><span class="p">.</span><span class="n">fd</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">      <span class="n">listenning_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">idleFd_</span><span class="p">(</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;/dev/null&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_CLOEXEC</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">idleFd_</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">acceptSocket_</span><span class="p">.</span><span class="n">setReuseAddr</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span> <span class="c1">// 设置了监听套接字地址复用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">acceptSocket_</span><span class="p">.</span><span class="n">bindAddress</span><span class="p">(</span><span class="n">listenAddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">acceptChannel_</span><span class="p">.</span><span class="n">setReadCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Acceptor</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中idleFd_的作用会在后面介绍。在构造函数中初始化了acceptSocket_，并将该Socket管理的监听套接字和acceptChannel_关联。然后在构造函数中设置了监听套接字地址复用，并绑定了传入参数的监听地址结构，最后设置了acceptChannel_的读事件函数Acceptor::handleRead，当监听套接字上有连接事件时将会出发该回调函数，该回调函数将在后面详细介绍。</p>
<p>在设置完acceptChannel_的回调函数后，即构造函数初始化结束后，acceptChannel_还是没有和EventLoop中的Poller关联，因为一个Channel如果要和Poller关联，那么必须要调用enablexxx函数，enablexxx函数内部又会调用update函数，这样才能达成关联。所以如果要达成这个目的，还需要有该函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Acceptor</span><span class="o">::</span><span class="n">listen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">listenning_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">acceptSocket_</span><span class="p">.</span><span class="n">listen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">acceptChannel_</span><span class="p">.</span><span class="n">enableReading</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建套接字后还需要设置套接字监听，并和Poller关联，这样一来，如果有客户连接，那么将调用Acceptor::handleRead函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//调用accept(2)来接受新连接，并回调用户callback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Acceptor</span><span class="o">::</span><span class="n">handleRead</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="nf">peerAddr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME loop until no more
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">connfd</span> <span class="o">=</span> <span class="n">acceptSocket_</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peerAddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">connfd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// string hostport = peerAddr.toIpPort();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// LOG_TRACE &lt;&lt; &#34;Accepts of &#34; &lt;&lt; hostport;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">newConnectionCallback_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">newConnectionCallback_</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">peerAddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Read the section named &#34;The special problem of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// accept()ing when you can&#39;t&#34; in libev&#39;s doc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// By Marc Lehmann, author of livev.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//创建的文件描述符太多了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EMFILE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">idleFd_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//由于我们使用的是电频触发，这个accept会一直触发，所以采用一个空闲的文件描述符，关闭idleFd_，再用来接收这个accept的idleFd_，再关闭idleFd_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">idleFd_</span> <span class="o">=</span> <span class="o">::</span><span class="n">accept</span><span class="p">(</span><span class="n">acceptSocket_</span><span class="p">.</span><span class="n">fd</span><span class="p">(),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">idleFd_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">idleFd_</span> <span class="o">=</span> <span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;/dev/null&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该函数中调用了accetp函数来接收连接，先看连接成功的情况(connfd &gt;= 0)，在该代码分支会将该连接客户端套接字及其地址传入newConnectionCallback_处理，newConnectionCallback_可以通过如下函数来设置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setNewConnectionCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">NewConnectionCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">newConnectionCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以理解，在setNewConnectionCallback中必然会处理客户端连接套接字，至于muduo如何处理，在TcpConnection中会介绍。如果该函数没有设置，也就是默认不处理该连接套接字，那么直接关闭该套接字。</p>
<p>接下来再看看else分支情况。else分支中会判断errno 是否为 EMFILE，如果发生该情况则说明系统文件描述符用尽了，需要处理。由于我们使用的是电频触发，这个accept会一直触发，所以这里利用一个空闲的文件描述符来处理这个问题，它是在Acceptor初始化列表中就创建了。首先关闭idleFd_(空闲文件描述符)，再用来接收这个accept的acceptSocket_，再关闭它，最后再创建一个空闲的描述符。</p>
<p>最后是析构函数，在该函数中将释放监听套接字资源，去除与其相关的Channel及销毁空闲的文件描述符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Acceptor</span><span class="o">::~</span><span class="n">Acceptor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 移除Channel需要保证它处于：kNoneEvent状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">acceptChannel_</span><span class="p">.</span><span class="n">disableAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">acceptChannel_</span><span class="p">.</span><span class="n">remove</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">idleFd_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="21-tcpconnection">21. TcpConnection</h2>
<p>Acceptor代表了监听连接的套接字listenfd，那么TcpConnection 就代表了已连接的客户端套接字connfd。</p>
<h3 id="211-设计思想">21.1 设计思想</h3>
<p><strong>TcpConnection 代表的是客户端连接套接字</strong>，所以TcpConnection 内部一定会管理一个文件描述符，以及该文件描述符对应的Channel，该Channel也需要关联一个EventLoop：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span> <span class="n">socket_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span> <span class="n">channel_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于TcpConnection中的socket_，TcpConnection还使用了两个地址结构来分别保存本机IP地址和对等方IP地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">InetAddress</span> <span class="n">localAddr_</span><span class="p">;</span> <span class="c1">// 保存本机IP地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">InetAddress</span> <span class="n">peerAddr_</span><span class="p">;</span>  <span class="c1">// 对等方IP地址
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用一个状态来标识当前套接字的连接状态(已断开，正在连接(三次握手)，已连接，正在断开(四次挥手)状态)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">StateE</span> <span class="p">{</span> <span class="n">kDisconnected</span><span class="p">,</span> <span class="n">kConnecting</span><span class="p">,</span> <span class="n">kConnected</span><span class="p">,</span> <span class="n">kDisconnecting</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">StateE</span> <span class="n">state_</span><span class="p">;</span>    <span class="c1">// FIXME: use atomic variable
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些变量都在构造函数中被初始化了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">TcpConnection</span><span class="o">::</span><span class="n">TcpConnection</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">nameArg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">localAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">peerAddr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">loop</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">      <span class="n">name_</span><span class="p">(</span><span class="n">nameArg</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">state_</span><span class="p">(</span><span class="n">kConnecting</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">socket_</span><span class="p">(</span><span class="k">new</span> <span class="n">Socket</span><span class="p">(</span><span class="n">sockfd</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">      <span class="n">channel_</span><span class="p">(</span><span class="k">new</span> <span class="n">Channel</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">      <span class="n">localAddr_</span><span class="p">(</span><span class="n">localAddr</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">peerAddr_</span><span class="p">(</span><span class="n">peerAddr</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">highWaterMark_</span><span class="p">(</span><span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setReadCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 通道可写事件到来的时候，回调TcpConnection::handleWrite
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setWriteCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleWrite</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 连接关闭，回调TcpConnection::handleClose
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setCloseCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleClose</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 发生错误，回调TcpConnection::handleError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setErrorCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleError</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_DEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpConnection::ctor[&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;] at &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">this</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="s">&#34; fd=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">socket_</span><span class="o">-&gt;</span><span class="n">setKeepAlive</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>构造函数初始化列表中的name_指的是该TcpConnection的名字，需要传入。highWaterMark_&ldquo;高水位&quot;标识在后面会介绍。</li>
<li>构造函数将state_ 设置为了kConnecting状态，意思是还没有完成连接，当然还有kConnected和kDisconnected两种状态，这在后面会具体介绍。</li>
<li>在构造函数中设置了Channel的读、写、关闭和错误回调函数，这些回调函数的具体内容会在后续介绍。</li>
<li>构造函数中，设置了socket_-&gt;setKeepAlive(true)，设置套接字保持连接(TCP心跳)。</li>
</ul>
<p>构造函数调用之后，该连接套接字还没有让EventLoop中的Poller监听，因为Channel还没有调用enableXXX函数，该函数会在建立连接回调TcpConnection::connectEstablished函数，这在后续会详细介绍。</p>
<p><strong>总之，一个TcpConnection代表了一个连接套接字及其Channel</strong>。</p>
<h3 id="212-tcp-网络编程的本质">21.2 TCP 网络编程的本质</h3>
<p>TCP 网络编程最本质的是处理三个半事件：</p>
<ul>
<li>(1) 连接的建立，包括服务端接受(accept) 新连接和客户端成功发起(connect) 连接。TCP 连接一旦建立，客户端和服务端是平等的，可以各自收发数据。</li>
<li>(2) 连接的断开，包括主动断开(close 或shutdown) 和被动断开(read(2) 返回0)。</li>
<li>(3) 消息到达，文件描述符可读。这是最为重要的一个事件，对它的处理方式决定了网络编程的风格(阻塞还是非阻塞，如何处理分包，应用层的缓冲如何设计等等)。</li>
<li>(3.5) 消息发送完毕，这算半个。对于低流量的服务，可以不必关心这个事件；另外，这里&quot;发送完毕&quot;是指将数据写入操作系统的缓冲区，将由TCP 协议栈负责数据的发送与重传，不代表对方已经收到数据。</li>
</ul>
<p>对于这&quot;三个半事件&rdquo;，在TcpConnection中体现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TcpConnection</span><span class="o">&gt;</span> <span class="n">TcpConnectionPtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ConnectionCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">CloseCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">WriteCompleteCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// the data has been read to (buf, len)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Buffer</span> <span class="o">*</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">)</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MessageCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ConnectionCallback</span> <span class="n">connectionCallback_</span><span class="p">;</span>       <span class="c1">// 连接的建立
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">MessageCallback</span> <span class="n">messageCallback_</span><span class="p">;</span>             <span class="c1">// 消息的到达
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">WriteCompleteCallback</span> <span class="n">writeCompleteCallback_</span><span class="p">;</span> <span class="c1">// 消息发送完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">CloseCallback</span> <span class="n">closeCallback_</span><span class="p">;</span>                 <span class="c1">// 连接的断开
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">defaultConnectionCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">defaultMessageCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">,</span> <span class="n">Buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>并提供了如下函数来设置这些回调函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setConnectionCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">ConnectionCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">connectionCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setMessageCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">MessageCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">messageCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setWriteCompleteCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">WriteCompleteCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">writeCompleteCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// Internal use only.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setCloseCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">CloseCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">closeCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这几个函数都是在TcpServer中传递的，所以在后续的TcpServer分析中会具体介绍这些函数。</p>
<h3 id="213-发送和接收缓冲区">21.3 发送和接收缓冲区</h3>
<p>TcpConnection使用Buffer作为发送和接收缓冲区：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Buffer</span> <span class="n">inputBuffer_</span><span class="p">;</span>   <span class="c1">// 应用层接收缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1">// FIXME: use list&lt;Buffer&gt; as output buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Buffer</span> <span class="n">outputBuffer_</span><span class="p">;</span>  <span class="c1">// 应用层发送缓冲区
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="214-连接事件处理">21.4 连接事件处理</h3>
<p>TcpConnection 中有：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">connectEstablished</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnecting</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">setState</span><span class="p">(</span><span class="n">kConnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[3] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">shared_from_this</span><span class="p">().</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// enable_shared_from_this是一个以其派生类为模板类型参数的基类模板，继承它，派生类的this指针就能变成一个shared_ptr。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">tie</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">enableReading</span><span class="p">();</span> <span class="c1">// TcpConnection所对应的通道加入到Poller关注
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">connectionCallback_</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[4] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">shared_from_this</span><span class="p">().</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数不是TcpConnection调用的，是在TcpServer设置调用的，现在只需要了解即可。该函数在建立连接时会被调用，该函数设置连接状态为kConnected(如果之前没有连接)，然后会调用Channel的tie和enableReading函数，让该监听套接字及其Channel和EventLoop的Poller绑定。最后调用connectionCallback_。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/codingmengmeng/p/9123874.html"target="_blank" rel="external nofollow noopener noreferrer">关于boost中enable_shared_from_this类的原理分析</a></p>
</blockquote>
<h3 id="215-读事件处理">21.5 &ldquo;读&quot;事件处理</h3>
<p>在构造函数中做过如下设置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setReadCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>TcpConnection::handleRead定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleRead</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">savedErrno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">inputBuffer_</span><span class="p">.</span><span class="n">readFd</span><span class="p">(</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">savedErrno</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">messageCallback_</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">inputBuffer_</span><span class="p">,</span> <span class="n">receiveTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">handleClose</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">errno</span> <span class="o">=</span> <span class="n">savedErrno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpConnection::handleRead&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">handleError</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>具体读的过程会调用Buffer::readFd函数，该函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 结合栈上的空间，避免内存使用过大，提高内存使用率
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果有5K个连接，每个连接就分配64K+64K的缓冲区的话，将占用640M内存，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 而大多数时候，这些缓冲区的使用率很低
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ssize_t</span> <span class="n">Buffer</span><span class="o">::</span><span class="n">readFd</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">savedErrno</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// saved an ioctl()/FIONREAD call to tell how much to read
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 节省一次ioctl系统调用(获取有多少可读数据)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span> <span class="n">extrabuf</span><span class="p">[</span><span class="mi">65536</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">iovec</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">size_t</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">writableBytes</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第一块缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">writerIndex_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">writable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第二块缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">extrabuf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">extrabuf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">readv</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">savedErrno</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">writable</span><span class="p">)</span> <span class="c1">//第一块缓冲区足够容纳
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">writerIndex_</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="c1">// 当前缓冲区，不够容纳，因而数据被接收到了第二块缓冲区extrabuf，将其append至buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">writerIndex_</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">append</span><span class="p">(</span><span class="n">extrabuf</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">writable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// if (n == writable + sizeof extrabuf)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//   goto line_30;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数利用了readv函数、iovec结构体和Buffer。vec[0]指向的是Buffer的写指针地址，vec[1]指向的是extrabuf的地址。这样做是为了双保险，如果读出的数据比较小，Buffer可以容纳，那么就全部读到Buffer中了，如果读出的数据很多，Buffer不够用了，那么还有65535字节的缓冲区可以接收这些数据，读出来的一些数据就保持在了Buffer中，剩下数据在extrabuf里，所以需要将在extrabuf中的数据再次append到Buffer中，Buffer也会适当扩容，最后所有数据都在Buffer中了。</p>
<blockquote>
<p><a href="https://blog.csdn.net/KingCat666/article/details/75269373"target="_blank" rel="external nofollow noopener noreferrer">linux ioctl()函数详解</a></p>
</blockquote>
<p>现在回到TcpConnection::handleRead中，如果读取到数据，则调用messageCallback_；如果读取到数据为0，说明客户端已经断开连接，那么调用handleClose()函数来关闭连接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleClose</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; state = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnected</span> <span class="o">||</span> <span class="n">state_</span> <span class="o">==</span> <span class="n">kDisconnecting</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// we don&#39;t close fd, leave it to dtor, so we can find leaks easily.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">setState</span><span class="p">(</span><span class="n">kDisconnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">disableAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">TcpConnectionPtr</span> <span class="nf">guardThis</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">connectionCallback_</span><span class="p">(</span><span class="n">guardThis</span><span class="p">);</span> <span class="c1">// 这一行，可以不调用=》没懂
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[7] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">guardThis</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// must be the last line
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">closeCallback_</span><span class="p">(</span><span class="n">guardThis</span><span class="p">);</span> <span class="c1">// 调用TcpServer::removeConnection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[11] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">guardThis</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数设置state_为kDisconnected，将连接套接字及其Channel从EventLoop的Poller中解除监听，然后依次调用connectionCallback_和closeCallback_函数。<strong>断开连接也属于connectionCallback_</strong>。  ？？？？？？？？？？</p>
<p>如果读取出现错误，那么将调用handleError函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleError</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">getSocketError</span><span class="p">(</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_ERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpConnection::handleError [&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name_</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="s">&#34;] - SO_ERROR = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">strerror_tl</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将错误输出到日志中。</p>
<h3 id="216-发送数据">21.6 发送数据</h3>
<p>在TcpConnection中提供了如下函数发送数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// void send(string&amp;&amp; message); // C++11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">send</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">send</span><span class="p">(</span><span class="k">const</span> <span class="n">StringPiece</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// void send(Buffer&amp;&amp; message); // C++11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">send</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span> <span class="c1">// this one will swap data
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用重载技术编写了三个send函数，这里只介绍参数为Buffer的那个，其余的大体类似：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 线程安全，可以跨线程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">send</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">loop_</span><span class="o">-&gt;</span><span class="n">isInLoopThread</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">sendInLoop</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">peek</span><span class="p">(),</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">readableBytes</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">buf</span><span class="o">-&gt;</span><span class="n">retrieveAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">sendInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">buf</span><span class="o">-&gt;</span><span class="n">retrieveAllAsString</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// std::forward&lt;string&gt;(message)));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>无论是在当前EventLoop线程还是跨线程调用，它们都最终调用了TcpConnection::sendInLoop函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">sendInLoop</span><span class="p">(</span><span class="k">const</span> <span class="n">StringPiece</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">sendInLoop</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>进一步调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">sendInLoop</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">  loop_-&gt;assertInLoopThread();
</span></span></span><span class="line"><span class="cl"><span class="cm">  sockets::write(channel_-&gt;fd(), data, len);
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssize_t</span> <span class="n">nwrote</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">error</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kDisconnected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_WARN</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;disconnected, give up writing&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// if no thing in output queue, try writing directly
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 通道没有关注可写事件并且发送缓冲区没有数据，直接write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">isWriting</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">readableBytes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">nwrote</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">(),</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">nwrote</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">remaining</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">nwrote</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 写完了，回调writeCompleteCallback_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">writeCompleteCallback_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">queueInLoop</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">writeCompleteCallback_</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="c1">// nwrote &lt; 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">nwrote</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EWOULDBLOCK</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpConnection::sendInLoop&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EPIPE</span><span class="p">)</span> <span class="c1">// FIXME: any others?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">error</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">remaining</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 没有错误，并且还有未写完的数据(说明内核发送缓冲区满，要将未写完的数据添加到output buffer中)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;I am going to write more data&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">oldLen</span> <span class="o">=</span> <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">readableBytes</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果超过highWaterMark_(高水位标)，回调highWaterMarkCallback_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">oldLen</span> <span class="o">+</span> <span class="n">remaining</span> <span class="o">&gt;=</span> <span class="n">highWaterMark_</span> <span class="o">&amp;&amp;</span> <span class="n">oldLen</span> <span class="o">&lt;</span> <span class="n">highWaterMark_</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">highWaterMarkCallback_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">queueInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">highWaterMarkCallback_</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">oldLen</span> <span class="o">+</span> <span class="n">remaining</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">nwrote</span><span class="p">,</span> <span class="n">remaining</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">isWriting</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">enableWriting</span><span class="p">();</span> <span class="c1">// 关注POLLOUT事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该函数中会调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">isWriting</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">readableBytes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>判断该Channel有没有使能&quot;写&rdquo;。在第一次调用该函数时是没有使能&quot;写&quot;的，前面只是使能了&quot;读&rdquo;，关注读事件。而且会判断Buffer的输出缓冲区内是否有数据，如果是第一次调用了该函数，那么发送缓冲区内肯定是没有有数据的，只不过第一次调用时还没有使能&quot;写&quot;，所以该判断成立，直接调用write函数写入数据，如果数据写入比较少，一次性就发送完了，那么直接调用writeCompleteCallback_，结束该分支。如果一次性没有写完，那么代码会跳转到该分支执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它会继续判断，当前的Buffer缓冲区里的数据长度(oldLen)与需要发送数据长度(remaining)之和是否大于&quot;高水位标志&quot;highWaterMark_，而且Buffer缓冲区内的数据小于highWaterMark_，是否设置了&quot;高水位标志&quot;回调函数highWaterMarkCallback_，如果设置了，那么执行highWaterMarkCallback_函数。然后将发送数据中没有发送的部分拷贝到Buffer中，然后使能&quot;写&quot;。接下来的数据就交给Poller返回后调用TcpConnection::handleWrite函数处理了。</p>
<h3 id="217-写事件处理">21.7 &ldquo;写&quot;事件处理</h3>
<p>在构造函数中做过如下设置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 通道可写事件到来的时候，回调TcpConnection::handleWrite
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setWriteCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleWrite</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当需要向连接套接字中写入数据时，TcpConnection::handleWrite将被调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 内核发送缓冲区有空间了，回调该函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleWrite</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">isWriting</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">(),</span> <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">peek</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                               <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">readableBytes</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">retrieve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">outputBuffer_</span><span class="p">.</span><span class="n">readableBytes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 发送缓冲区已清空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">disableWriting</span><span class="p">();</span> <span class="c1">// 停止关注POLLOUT事件，以免出现busy loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">writeCompleteCallback_</span><span class="p">)</span> <span class="c1">// 回调writeCompleteCallback_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 应用层发送缓冲区被清空，就回调用writeCompleteCallback_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">queueInLoop</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">writeCompleteCallback_</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 发送缓冲区已清空并且连接状态是kDisconnecting，要关闭连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kDisconnecting</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">shutdownInLoop</span><span class="p">();</span> <span class="c1">// 只关闭写的这一半，进入半关闭状态(close SHUT_WR)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;I am going to write more data&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpConnection::handleWrite&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// if (state_ == kDisconnecting)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//   shutdownInLoop();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Connection fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="s">&#34; is down, no more writing&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当客户端套接字变得可写时，调用write往套接字中写入Buffer内容，如果写完了，那么设置Channel，客户端套接字停止&quot;写行为&rdquo;。如果设置了writeCompleteCallback_，则调用writeCompleteCallback_函数。</p>
<blockquote>
<p>当内核发送缓冲区有空间了，回调handleWrite函数，调用write往套接字中写入Buffer内容，如果写完了，那么设置Channel，客户端套接字停止&quot;写行为&quot;。那么已经取消关注了可写的事件，在什么地方又得重新设置再次关注可写事件呢？客户端每次发送数据都是通过send函数，它就在内部调用了enableWriting函数。</p>
</blockquote>
<p>如果当前TcpConnection状态为kDisconnecting，说明没有连接，则调用shutdownInLoop函数，关闭该套接字的写端，但仍然可以读：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">shutdownInLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">isWriting</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// we are not writing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">socket_</span><span class="o">-&gt;</span><span class="n">shutdownWrite</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当调用如下函数后，状态为kDisconnecting：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">shutdown</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME: use compare and swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">setState</span><span class="p">(</span><span class="n">kDisconnecting</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// FIXME: shared_from_this()?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">shutdownInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用该函数来断开连接。</p>
<h2 id="22-tcpserver">22. TcpServer</h2>
<p>TcpServer中融合了前面讲过的几乎所有东西。</p>
<h3 id="221-io-线程">22.1 I/O 线程</h3>
<p>TcpServer 正如其名，是一个服务器，而且是一个可以支持多线程Reactor的服务器，所以该服务器必须要有诸多IO线程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>  <span class="c1">// the acceptor loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">EventLoopThreadPool</span><span class="o">&gt;</span> <span class="n">threadPool_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它们在构造函数中被初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">TcpServer</span><span class="o">::</span><span class="n">TcpServer</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">InetAddress</span><span class="o">&amp;</span> <span class="n">listenAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">nameArg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">loop</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">threadPool_</span><span class="p">(</span><span class="k">new</span> <span class="n">EventLoopThreadPool</span><span class="p">(</span><span class="n">loop</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">nextConnId_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可通过该函数来创建多少个IO线程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpServer</span><span class="o">::</span><span class="n">setThreadNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">numThreads</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">numThreads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">threadPool_</span><span class="o">-&gt;</span><span class="n">setThreadNum</span><span class="p">(</span><span class="n">numThreads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="222-acceptor">22.2 Acceptor</h3>
<p>TcpServer使用Acceptor来操作监听套接字，而且需要一个监听套接字地址和端口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">TcpServer</span><span class="o">::</span><span class="n">TcpServer</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">InetAddress</span><span class="o">&amp;</span> <span class="n">listenAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">nameArg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">loop</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">hostport_</span><span class="p">(</span><span class="n">listenAddr</span><span class="p">.</span><span class="n">toIpPort</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">acceptor_</span><span class="p">(</span><span class="k">new</span> <span class="n">Acceptor</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">listenAddr</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Acceptor::handleRead函数中会回调用TcpServer::newConnection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// _1对应的是socket文件描述符，_2对应的是对等方的地址(InetAddress)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">acceptor_</span><span class="o">-&gt;</span><span class="n">setNewConnectionCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpServer</span><span class="o">::</span><span class="n">newConnection</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时的Acceptor还没有加入事件监听中（没有调用Acceptor::listen()）。Acceptor需要TcpServer传入一个函数来处理连接事件（Acceptor只负责处理连接，所以只关注读事件）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">acceptChannel_</span><span class="p">.</span><span class="n">setReadCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Acceptor</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Acceptor</span><span class="o">::</span><span class="n">handleRead</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">connfd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">newConnectionCallback_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">newConnectionCallback_</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">peerAddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而该函数便是TcpServer::newConnection，该函数在下面详细介绍。</p>
<h3 id="223-启动服务器">22.3 启动服务器</h3>
<p>调用该函数即可启动服务器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 该函数多次调用是无害的
</span></span></span><span class="line"><span class="cl"><span class="c1">// 该函数可以跨线程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">TcpServer</span><span class="o">::</span><span class="n">start</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">started_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">started_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">threadPool_</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">threadInitCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acceptor_</span><span class="o">-&gt;</span><span class="n">listenning</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// get_pointer：返回原生指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Acceptor</span><span class="o">::</span><span class="n">listen</span><span class="p">,</span> <span class="n">get_pointer</span><span class="p">(</span><span class="n">acceptor_</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数首先启动了IO线程池，并传入线程初始化函数，TcpServer中threadInitCallback_定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ThreadInitCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ThreadInitCallback</span> <span class="n">threadInitCallback_</span><span class="p">;</span> <span class="c1">// IO线程池中的线程在进入事件循环前，会回调用此函数
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可通过该函数设置这一回调函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setThreadInitCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">ThreadInitCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">threadInitCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在初始化IO后便启动了Acceptor，Acceptor加入了事件循环。值得一提的是，如果IO线程池设置线程数量为0，那么全局只有一个EventLoop，threadPool_中的EventLoop也是指向TcpServer中的EventLoop。</p>
<h3 id="224-处理客户端连接">22.4 处理客户端连接</h3>
<p>Acceptor 绑定的&quot;读事件&quot;回调函数是newConnection，当有客户端连接时该函数将会被调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpServer</span><span class="o">::</span><span class="n">newConnection</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">peerAddr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 按照轮叫的方式选择一个EventLoop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">EventLoop</span> <span class="o">*</span><span class="n">ioLoop</span> <span class="o">=</span> <span class="n">threadPool_</span><span class="o">-&gt;</span><span class="n">getNextLoop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span> <span class="s">&#34;:%s#%d&#34;</span><span class="p">,</span> <span class="n">hostport_</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">nextConnId_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">++</span><span class="n">nextConnId_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">string</span> <span class="n">connName</span> <span class="o">=</span> <span class="n">name_</span> <span class="o">+</span> <span class="n">buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">LOG_INFO</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpServer::newConnection [&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;] - new connection [&#34;</span>
</span></span><span class="line"><span class="cl">           <span class="o">&lt;&lt;</span> <span class="n">connName</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;] from &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">peerAddr</span><span class="p">.</span><span class="n">toIpPort</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="nf">localAddr</span><span class="p">(</span><span class="n">sockets</span><span class="o">::</span><span class="n">getLocalAddr</span><span class="p">(</span><span class="n">sockfd</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME poll with zero timeout to double confirm the new connection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// FIXME use make_shared if necessary
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/*TcpConnectionPtr conn(new TcpConnection(loop_,
</span></span></span><span class="line"><span class="cl"><span class="cm">                                          connName,
</span></span></span><span class="line"><span class="cl"><span class="cm">                                          sockfd,
</span></span></span><span class="line"><span class="cl"><span class="cm">                                          localAddr,
</span></span></span><span class="line"><span class="cl"><span class="cm">                                          peerAddr));*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">TcpConnectionPtr</span> <span class="nf">conn</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="k">new</span> <span class="n">TcpConnection</span><span class="p">(</span><span class="n">ioLoop</span><span class="p">,</span> <span class="n">connName</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">localAddr</span><span class="p">,</span> <span class="n">peerAddr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[1] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">connections_</span><span class="p">[</span><span class="n">connName</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[2] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setConnectionCallback</span><span class="p">(</span><span class="n">connectionCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setMessageCallback</span><span class="p">(</span><span class="n">messageCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setWriteCompleteCallback</span><span class="p">(</span><span class="n">writeCompleteCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setCloseCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpServer</span><span class="o">::</span><span class="n">removeConnection</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span> <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// conn-&gt;connectEstablished();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ioLoop</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">connectEstablished</span><span class="p">,</span> <span class="n">conn</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[5] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数调用后，TcpServer将从threadPool_轮询方式获取一个EventLoop，让该EventLoop来处理新连接客户端套接字事件。接下来会创建一个TcpConnection，然后将该TcpConnection保存到connections_中，该成员变量定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">TcpConnectionPtr</span><span class="o">&gt;</span> <span class="n">ConnectionMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ConnectionMap</span> <span class="n">connections_</span><span class="p">;</span> <span class="c1">// 连接列表
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再设置该TcpConnection的对应的回调事件，其中connectionCallback_和messageCallback_在构造函数中设置了默认处理函数，这两个默认函数里没有做任何实事：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ConnectionCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// the data has been read to (buf, len)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Buffer</span> <span class="o">*</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">)</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MessageCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ConnectionCallback</span> <span class="n">connectionCallback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">MessageCallback</span> <span class="n">messageCallback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">TcpServer</span><span class="o">::</span><span class="n">TcpServer</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span> <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">listenAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">nameArg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="p">...</span>
</span></span><span class="line"><span class="cl">      <span class="n">connectionCallback_</span><span class="p">(</span><span class="n">defaultConnectionCallback</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">messageCallback_</span><span class="p">(</span><span class="n">defaultMessageCallback</span><span class="p">),</span> <span class="n">started_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以通过如下函数来设置这些回调函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">/// Set connection callback.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Not thread safe.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 设置连接到来或者连接关闭回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setConnectionCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">ConnectionCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">connectionCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// Set message callback.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Not thread safe.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 设置消息到来回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setMessageCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">MessageCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">messageCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// Set write complete callback.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Not thread safe.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setWriteCompleteCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">WriteCompleteCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">writeCompleteCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是，连接关闭回调函数绑定的是TcpServer::removeConnection：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpServer</span><span class="o">::</span><span class="n">removeConnection</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span><span class="o">&amp;</span> <span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpServer</span><span class="o">::</span><span class="n">removeConnectionInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">conn</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpServer</span><span class="o">::</span><span class="n">removeConnectionInLoop</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_INFO</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpServer::removeConnectionInLoop [&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name_</span>
</span></span><span class="line"><span class="cl">           <span class="o">&lt;&lt;</span> <span class="s">&#34;] - connection &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[8] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">connections_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[9] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="o">*</span><span class="n">ioLoop</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">getLoop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">ioLoop</span><span class="o">-&gt;</span><span class="n">queueInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">connectDestroyed</span><span class="p">,</span> <span class="n">conn</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// loop_-&gt;queueInLoop(
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    boost::bind(&amp;TcpConnection::connectDestroyed, conn));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[10] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这一串函数将该TcpConnection从TcpServer的connections_中删除，TcpServer与该TcpConnection没有任何关系了，然后调用TcpConnection::connectDestroyed将该TcpConnection的连接套接字及其Channel与EventLoop及其Poller解除联系，这样一来就彻底除掉该TcpConnection了。</p>
<h3 id="225-释放资源">22.5 释放资源</h3>
<p>将connections_保存的所有TcpConnection全部去除，去除方法和前面TcpServer::removeConnectionInLoop去除单个TcpConnection的方法是一样的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">TcpServer</span><span class="o">::~</span><span class="n">TcpServer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpServer::~TcpServer [&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;] destructing&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">ConnectionMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">(</span><span class="n">connections_</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">       <span class="n">it</span> <span class="o">!=</span> <span class="n">connections_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">TcpConnectionPtr</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">// 释放当前所控制的对象，引用计数减一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">conn</span><span class="o">-&gt;</span><span class="n">getLoop</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">connectDestroyed</span><span class="p">,</span> <span class="n">conn</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">conn</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">// 释放当前所控制的对象，引用计数减一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="23-connector">23. Connector</h2>
<p>Connector 是为TcpClient所调用的，一个客户端需要一个套接字来与服务端通信，muduo 使用Connector 来封装这个与服务端通信的套接字（如同Acceptor 封装了监听客户端连接的套接字）。</p>
<h3 id="231-设计思想">23.1 设计思想</h3>
<p>前面说到，该Connector 封装了一个客户端用于连接服务器的套接字，本着muduo中 Every Fd is Channel 的精神，Connector也同样遵循这样的准测：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>                             <span class="c1">// 所属EventLoop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span> <span class="n">channel_</span><span class="p">;</span>          <span class="c1">// Connector所对应的Channel
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是成员变量中却没有套接字，该套接字是在建立连接时才创建的，待创建成功才与channel_绑定：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">connect</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">createNonblockingOrDie</span><span class="p">();</span> <span class="c1">// 创建非阻塞套接字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">serverAddr_</span><span class="p">.</span><span class="n">getSockAddrInet</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而且从构造函数来看，该Channel也没有和EventLoop绑定，至于为什么这样做，在后面会详细介绍。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Connector</span><span class="o">::</span><span class="n">Connector</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span> <span class="k">const</span> <span class="n">InetAddress</span><span class="o">&amp;</span> <span class="n">serverAddr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">serverAddr_</span><span class="p">(</span><span class="n">serverAddr</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">connect_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">state_</span><span class="p">(</span><span class="n">kDisconnected</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">retryDelayMs_</span><span class="p">(</span><span class="n">kInitRetryDelayMs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_DEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ctor[&#34;</span> <span class="o">&lt;&lt;</span> <span class="k">this</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;]&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>构造函数中需要传入一个EventLoop和一个服务端地址结构，至于初始化列表中的后三个变量，在本文后续会详细介绍。</p>
<h3 id="232-连接服务端">23.2 连接服务端</h3>
<p>调用Connector::start函数可启动Connector：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 可以跨线程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">start</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">connect_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Connector</span><span class="o">::</span><span class="n">startInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span> <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数又进而调用Connector::startInLoop函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">startInLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kDisconnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">connect_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">connect</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_DEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;do not connect&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于一开始构造函数对state_的设置，assert(state_ == kDisconnected)成立。在Connector::start中已经将connect_设置为true，所以直接调用connect()函数，该函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">connect</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">createNonblockingOrDie</span><span class="p">();</span> <span class="c1">// 创建非阻塞套接字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">serverAddr_</span><span class="p">.</span><span class="n">getSockAddrInet</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">savedErrno</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">savedErrno</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EINPROGRESS</span><span class="p">:</span> <span class="c1">// 非阻塞套接字，未连接成功返回码是EINPROGRESS表示正在连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">case</span> <span class="nl">EINTR</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EISCONN</span><span class="p">:</span> <span class="c1">// 连接成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">connecting</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EAGAIN</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EADDRINUSE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EADDRNOTAVAIL</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">ECONNREFUSED</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">ENETUNREACH</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">retry</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span> <span class="c1">// 重连
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EACCES</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EPERM</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EAFNOSUPPORT</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EALREADY</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EBADF</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EFAULT</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">ENOTSOCK</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;connect error in Connector::startInLoop &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">savedErrno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span> <span class="c1">// 不能重连，关闭sockfd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Unexpected error in Connector::startInLoop &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">savedErrno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// connectErrorCallback_();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该函数中会创建一个非阻塞的套接字，并调用sockets::connect函数，如果连接成功则调用connecting函数，如果是连接超时，非阻塞套接字返回，那么调用retry函数，其他情况下都是出现错误，直接关闭该套接字。retry这种情况会在下一节内容中介绍，这部分主要关注connecting函数的调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">connecting</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">setState</span><span class="p">(</span><span class="n">kConnecting</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">channel_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Channel与sockfd关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Channel</span><span class="p">(</span><span class="n">loop_</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置可写回调函数，这时候如果socket没有错误，sockfd就处于可写状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setWriteCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Connector</span><span class="o">::</span><span class="n">handleWrite</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span> <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 设置错误回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setErrorCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Connector</span><span class="o">::</span><span class="n">handleError</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span> <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// channel_-&gt;tie(shared_from_this()); is not working,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// as channel_ is not managed by shared_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">enableWriting</span><span class="p">();</span> <span class="c1">// 让Poller关注可写事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数将state_设置为kConnecting状态，重置channel_的值，绑定EventLoop和连接成功的套接字sockfd，设置Channel的&quot;写&quot;和&quot;错误&quot;回调函数，并使能&quot;写&quot;，这样一来，Channel及其连接套接字就在EventLoop的Poller中了。</p>
<p>Connector::handleWrite和Connector::handleError两个函数会在下几节介绍。</p>
<h3 id="233-错误处理与重连">23.3 错误处理与重连</h3>
<p>当连接套接字上出现错误时将调用该函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">handleError</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_ERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Connector::handleError&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnecting</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">removeAndResetChannel</span><span class="p">();</span> <span class="c1">// 从poller中移除关注，并将channel置空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">getSocketError</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;SO_ERROR = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">strerror_tl</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">retry</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该函数中会调用removeAndResetChannel函数，removeAndResetChannel会清除该连接套接字Channel和EventLoop的Poller绑定，释放channel_智能指针所管理的内存，并将该连接套接字返回：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Connector</span><span class="o">::</span><span class="n">removeAndResetChannel</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">disableAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">();</span> <span class="c1">// 从poller移除关注
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Can&#39;t reset channel_ here, because we are inside Channel::handleEvent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 不能在这里重置channel_，因为正在调用Channel::handleEvent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">queueInLoop</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Connector</span><span class="o">::</span><span class="n">resetChannel</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span> <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">resetChannel</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">// channel_ 置空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>回到Connector::handleError函数，在清理资源并获取到产生错误的sockfd后，该函数会再调用retry函数尝试连接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 采用back-off策略重连，即重连时间逐渐延长，0.5s, 1s, 2s, ...直至30s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">retry</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">setState</span><span class="p">(</span><span class="n">kDisconnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">connect_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_INFO</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Connector::retry - Retry connecting to &#34;</span>
</span></span><span class="line"><span class="cl">             <span class="o">&lt;&lt;</span> <span class="n">serverAddr_</span><span class="p">.</span><span class="n">toIpPort</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; in &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">retryDelayMs_</span>
</span></span><span class="line"><span class="cl">             <span class="o">&lt;&lt;</span> <span class="s">&#34; milliseconds. &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注册一个定时操作，重连
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runAfter</span><span class="p">(</span><span class="n">retryDelayMs_</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Connector</span><span class="o">::</span><span class="n">startInLoop</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">    <span class="n">retryDelayMs_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">retryDelayMs_</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kMaxRetryDelayMs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_DEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;do not connect&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在介绍retry函数之前需要了解这两个常量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kMaxRetryDelayMs</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// 30秒，最大重连延迟时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kInitRetryDelayMs</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>      <span class="c1">// 0.5秒，初始状态，连接不上，0.5秒后重连
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>kInitRetryDelayMs指的是过500ms便发动一次连接，尝试连接到服务器；kMaxRetryDelayMs指的是尝试超时连接总时间为30*1000ms。在retry函数中调用了runAfter定时函数来尝试连接。</p>
<h3 id="234-处理写事件">23.4 处理&quot;写&quot;事件</h3>
<p>如果socket没有错误，sockfd就处于可写状态，函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">handleWrite</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Connector::handleWrite &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnecting</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">removeAndResetChannel</span><span class="p">();</span> <span class="c1">// 从poller中移除关注，并将channel置空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// socket可写并不意味着连接一定建立成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 还需要用getsockopt(sockfd, SOL_SOCKET, SO_ERROR, ...)再次确认一下。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">getSocketError</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="c1">// 有错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_WARN</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Connector::handleWrite - SO_ERROR = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span>
</span></span><span class="line"><span class="cl">               <span class="o">&lt;&lt;</span> <span class="n">strerror_tl</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">retry</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>                           <span class="c1">// 重连
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">sockets</span><span class="o">::</span><span class="n">isSelfConnect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">))</span> <span class="c1">// 自连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_WARN</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Connector::handleWrite - Self connect&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">retry</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span> <span class="c1">// 重连
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span>           <span class="c1">// 连接成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">setState</span><span class="p">(</span><span class="n">kConnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">connect_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">newConnectionCallback_</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span> <span class="c1">// 回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// what happened?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kDisconnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该函数中只是获取到连接成功套接字的文件描述符sockfd，并且将Channel清除，然后调用newConnectionCallback_函数，该函数在TcpClient中传入。为什么要将该连接Channel移除是有原因的，客户端连接套接字只有一个，而Connector中已经将该套接字与自己的Channel绑定了，只是负责连接而已，connect函数调用成功该套接字则变得可写，这时的Connector已经完成任务了，需要将该套接字的所有权转让给TcpClient，所以调用了newConnectionCallback_函数，而该函数在TcpClient中给该套接字绑定了一个新的Channel，该Channel和Connector中的Channel同属于一个EventLoop，所以转移所有权需要彻底，Connector中的Channel必须要被移除，否则将导致&quot;串台&quot;。</p>
<h3 id="235-重置连接">23.5 重置连接</h3>
<p>&ldquo;断线重连&quot;和&quot;重置连接&quot;是两个概念，&ldquo;断线重连&quot;指的是在已经连接成功的情况下又断开连接，再多次尝试连接；&ldquo;重置连接&quot;指的是放弃之前的连接，从零开始连接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 不能跨线程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">restart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">setState</span><span class="p">(</span><span class="n">kDisconnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">retryDelayMs_</span> <span class="o">=</span> <span class="n">kInitRetryDelayMs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">connect_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">startInLoop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="24-tcpclient">24. TcpClient</h2>
<p>在上一章的Connector中说到&quot;在该函数中只是获取到连接成功套接字的文件描述符sockfd，并且将Channel清除，然后调用newConnectionCallback_函数，该函数在TcpClient中传入&rdquo;，Connector::handleWrite函数是被TcpClient调用的，那么我们先一窥newConnectionCallback_函数究竟。</p>
<p>在此之前，先看看TcpClient中的Connector：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Connector</span><span class="o">&gt;</span> <span class="n">ConnectorPtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConnectorPtr</span> <span class="n">connector_</span><span class="p">;</span>                      <span class="c1">// 用于主动发起连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">TcpClient</span><span class="o">::</span><span class="n">TcpClient</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">InetAddress</span><span class="o">&amp;</span> <span class="n">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">loop</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">connector_</span><span class="p">(</span><span class="k">new</span> <span class="n">Connector</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">serverAddr</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">name_</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置连接成功回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">connector_</span><span class="o">-&gt;</span><span class="n">setNewConnectionCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpClient</span><span class="o">::</span><span class="n">newConnection</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME setConnectFailedCallback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LOG_INFO</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpClient::TcpClient[&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name_</span>
</span></span><span class="line"><span class="cl">           <span class="o">&lt;&lt;</span> <span class="s">&#34;] - connector &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">get_pointer</span><span class="p">(</span><span class="n">connector_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在构造函数中，Connector被设置了新连接回调函数TcpClient::newConnection，也就是前面的newConnectionCallback_，该函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpClient</span><span class="o">::</span><span class="n">newConnection</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="nf">peerAddr</span><span class="p">(</span><span class="n">sockets</span><span class="o">::</span><span class="n">getPeerAddr</span><span class="p">(</span><span class="n">sockfd</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span> <span class="s">&#34;:%s#%d&#34;</span><span class="p">,</span> <span class="n">peerAddr</span><span class="p">.</span><span class="n">toIpPort</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">nextConnId_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">++</span><span class="n">nextConnId_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">string</span> <span class="n">connName</span> <span class="o">=</span> <span class="n">name_</span> <span class="o">+</span> <span class="n">buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="nf">localAddr</span><span class="p">(</span><span class="n">sockets</span><span class="o">::</span><span class="n">getLocalAddr</span><span class="p">(</span><span class="n">sockfd</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME poll with zero timeout to double confirm the new connection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// FIXME use make_shared if necessary
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">TcpConnectionPtr</span> <span class="nf">conn</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="k">new</span> <span class="n">TcpConnection</span><span class="p">(</span><span class="n">loop_</span><span class="p">,</span> <span class="n">connName</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">localAddr</span><span class="p">,</span> <span class="n">peerAddr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setConnectionCallback</span><span class="p">(</span><span class="n">connectionCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setMessageCallback</span><span class="p">(</span><span class="n">messageCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setWriteCompleteCallback</span><span class="p">(</span><span class="n">writeCompleteCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setCloseCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpClient</span><span class="o">::</span><span class="n">removeConnection</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span> <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MutexLockGuard</span> <span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">connection_</span> <span class="o">=</span> <span class="n">conn</span><span class="p">;</span> <span class="c1">// 保存TcpConnection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">connectEstablished</span><span class="p">();</span> <span class="c1">// 这里回调connectionCallback_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数将连接成功的socfd封装为一个TcpConnection，并设置&quot;三个半&quot;回调事件函数。好的，到了这里就解释了前面Connector为什么不自己持有一个sockfd、为什么要在连接成功时清空Channel等诸多问题。拿到连接成功套接字后，创建TcpConnection与服务器进行数据交换。</p>
<h2 id="25-阶段性总结">25. 阶段性总结</h2>
<p>一张图总结服务/客户端调用关系：</p>
<p><img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="../../imgs/muduo/muduo.jpg"
    data-srcset="../../imgs/muduo/muduo.jpg, ../../imgs/muduo/muduo.jpg 1.5x, ../../imgs/muduo/muduo.jpg 2x"
    data-sizes="auto"
    alt="Muduo"
    title="Muduo"/></p>
<ul>
<li>TcpConnection负责一个客户端连接成功套接字</li>
<li>Acceptor负责一个服务器listen套接字</li>
<li>Connector负责一个客户端connect套接字</li>
<li>TcpServer中持有Acceptor，通过Acceptor获取新的连接套接字，然后TcpServer会为该连接套接字建立一个TcpConnection，然后往该TcpConnection中传递用户需要TcpServer相应事件对应的函数，用户传入的函数其实是和TcpConnection中的Channel间接绑定，然后在事件触发后被Channel间接执行。</li>
<li>TcpClient中持有Connector，通过Connector里的Channel绑定一个连接套接字，在连接成功后，Connector会将该套接字转让给TcpClient，TcpClient中会为该连接套接字建立一个TcpConnection，然后往该TcpConnection中传递用户需要TcpClient相应事件对应的函数，用户传入的函数其实是和TcpConnection中的Channel间接绑定，然后在事件触发后被Channel间接执行。</li>
</ul>
</div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title=2022-12-12&#32;00:00:00>Updated on 2022-12-12&nbsp;</span>
      </div><div class="post-info-license">
          <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
        </div></div>
    <div class="post-info-line">
      <div class="post-info-md"></div>
      <div class="post-info-share">
        <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" data-title="muduo网络库源码学习" data-hashtags="muduo"><i class="fa-brands fa-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" data-hashtag="muduo"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" data-title="muduo网络库源码学习"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
      </div>
    </div>
  </div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/tags/muduo/' class="post-tag">muduo</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/c&#43;&#43;_primer_5th/" class="post-nav-item" rel="prev" title="c&#43;&#43; primer 5th 要点记录"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>c&#43;&#43; primer 5th 要点记录</a>
      <a href="/posts/hugo%E6%90%AD%E5%BB%BA/" class="post-nav-item" rel="next" title="Hugo的安装和FixIt 主题">Hugo的安装和FixIt 主题<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></main><footer class="footer">
    <div class="footer-container"><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2022</span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="Back to Top"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><noscript>
    <div class="noscript-warning">Theme FixIt works best with JavaScript enabled.</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/autocomplete/autocomplete.min.js" defer></script><script src="/lib/lunr/lunr.min.js" defer></script><script src="/lib/lazysizes/lazysizes.min.js" async defer></script><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/typeit/index.umd.js" defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":-1},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"data":{"typeit-header-desktop":"Home","typeit-header-title-mobile":"Home"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","maxResultLength":10,"noResultsFound":"No results found","snippetLength":30},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"typeit-header-desktop":["typeit-header-desktop"],"typeit-header-title-mobile":["typeit-header-title-mobile"]},"duration":-1,"speed":100}};</script><script src="/js/theme.min.js" defer></script></body>
</html>
