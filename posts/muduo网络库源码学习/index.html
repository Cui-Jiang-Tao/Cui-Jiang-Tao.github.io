<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>muduo网络库源码学习 - Notes</title><meta name="author" content="cjt">
<meta name="author-link" content="">
<meta name="description" content="源码参考：Muduo 第二部分：Muduo网络库 10. 初探EventLoop 10.1 什么都不做的EventLoop 一个EventLoop就是一个事件循环" /><meta name="keywords" content='muduo' /><meta itemprop="name" content="muduo网络库源码学习">
<meta itemprop="description" content="源码参考：Muduo 第二部分：Muduo网络库 10. 初探EventLoop 10.1 什么都不做的EventLoop 一个EventLoop就是一个事件循环"><meta itemprop="datePublished" content="2022-12-06T00:00:00+00:00" />
<meta itemprop="dateModified" content="2022-12-18T00:00:00+00:00" />
<meta itemprop="wordCount" content="52133">
<meta itemprop="keywords" content="muduo," /><meta property="og:title" content="muduo网络库源码学习" />
<meta property="og:description" content="源码参考：Muduo 第二部分：Muduo网络库 10. 初探EventLoop 10.1 什么都不做的EventLoop 一个EventLoop就是一个事件循环" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-06T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-12-18T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="muduo网络库源码学习"/>
<meta name="twitter:description" content="源码参考：Muduo 第二部分：Muduo网络库 10. 初探EventLoop 10.1 什么都不做的EventLoop 一个EventLoop就是一个事件循环"/>
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" /><link rel="prev" href="https://cui-jiang-tao.github.io/posts/c&#43;&#43;_primer_5th/" /><link rel="next" href="https://cui-jiang-tao.github.io/posts/hugo%E6%90%AD%E5%BB%BA/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "muduo网络库源码学习",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/cui-jiang-tao.github.io\/posts\/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0\/"
    },"genre": "posts","keywords": "muduo","wordcount":  52133 ,
    "url": "https:\/\/cui-jiang-tao.github.io\/posts\/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0\/","datePublished": "2022-12-06T00:00:00+00:00","dateModified": "2022-12-18T00:00:00+00:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "cjt"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="fixed" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="wide"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="Notes"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span><span id="typeit-header-desktop" class="typeit"></span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 文章</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="Switch Theme">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="Notes"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw' aria-hidden='true'></i></span><span id="typeit-header-title-mobile" class="typeit"></span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> 文章</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> 分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> 标签</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><main class="container"><aside class="toc" id="toc-auto"><h2 class="toc-title">Contents&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside>

  <aside class="aside-custom">
    </aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>muduo网络库源码学习</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><i class="fa-solid fa-user-circle" aria-hidden="true"></i>
      cjt</span></span>
          <span class="post-category">included in <a href="/categories/c/c++/"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> c/c++</a></span></div>
      <div class="post-meta-line"><span title="published on 2022-12-06 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden="true"></i><time datetime="2022-12-06">2022-12-06</time></span>&nbsp;<span title="Updated on 2022-12-18 00:00:00"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden="true"></i><time datetime="2022-12-18">2022-12-18</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>52133 words</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>105 minutes</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>Contents</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#10-初探eventloop">10. 初探EventLoop</a>
      <ul>
        <li><a href="#101-什么都不做的eventloop">10.1 什么都不做的EventLoop</a></li>
        <li><a href="#102-one-loop-per-thread">10.2 one loop per thread</a></li>
        <li><a href="#103-事件循环">10.3 事件循环</a></li>
      </ul>
    </li>
    <li><a href="#11-channel">11. Channel</a>
      <ul>
        <li><a href="#111-channel与文件描述符">11.1 Channel与文件描述符</a></li>
        <li><a href="#112-设置监听回调函数">11.2 设置监听回调函数</a></li>
        <li><a href="#113-channel与eventloop关系">11.3 Channel与EventLoop关系</a></li>
        <li><a href="#114-响应事件">11.4 响应事件</a></li>
      </ul>
    </li>
    <li><a href="#12-poller">12. Poller</a>
      <ul>
        <li><a href="#121-poller">12.1 Poller</a></li>
        <li><a href="#122-poller分析">12.2 Poller分析</a>
          <ul>
            <li><a href="#1221-pollpoller和eventloop关系">12.2.1 PollPoller和EventLoop关系</a></li>
            <li><a href="#1222-pollpoller和channel的关系">12.2.2 PollPoller和Channel的关系</a></li>
            <li><a href="#1223-update-和-remove-channel">12.2.3 update 和 remove Channel</a></li>
            <li><a href="#1224-poll">12.2.4 poll</a></li>
          </ul>
        </li>
        <li><a href="#123-epollpoller-分析">12.3 EPollPoller 分析</a>
          <ul>
            <li><a href="#1231-epollpoller和eventloop关系">12.3.1 EPollPoller和EventLoop关系</a></li>
            <li><a href="#1232-epollpoller和channel的关系">12.3.2 EPollPoller和Channel的关系</a></li>
            <li><a href="#1233-update-和-remove-channel">12.3.3 update 和 remove Channel</a></li>
            <li><a href="#1234-poll">12.3.4 poll</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#13-定时器">13. 定时器</a>
      <ul>
        <li><a href="#131-timerfd_系列定时器">13.1 timerfd_*系列定时器</a></li>
        <li><a href="#132-timer-分析">13.2 Timer 分析</a></li>
        <li><a href="#133-timerid-分析">13.3 TimerId 分析</a></li>
        <li><a href="#134-timerqueue">13.4 TimerQueue</a>
          <ul>
            <li><a href="#1341-timerqueue-设计原理">13.4.1 TimerQueue 设计原理</a></li>
            <li><a href="#1342-向timerqueue-中添加一个timer">13.4.2 向TimerQueue 中添加一个Timer</a></li>
            <li><a href="#1343-获取超时timer">13.4.3 获取超时Timer</a></li>
            <li><a href="#1344-向timerqueue-中取消一个timer">13.4.4 向TimerQueue 中取消一个Timer</a></li>
            <li><a href="#1345-重置超时timer">13.4.5 重置超时Timer</a></li>
            <li><a href="#1346-析构函数与资源销毁">13.4.6 析构函数与资源销毁</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#14-深入-eventloop">14. 深入 EventLoop</a>
      <ul>
        <li><a href="#141-eventloop-与-channel">14.1 EventLoop 与 Channel</a></li>
        <li><a href="#142-eventloop-与-timerqueue">14.2 EventLoop 与 TimerQueue</a></li>
        <li><a href="#143-eventloop-与-poller">14.3 EventLoop 与 Poller</a></li>
        <li><a href="#144-跨线程执行函数">14.4 跨线程执行函数</a></li>
        <li><a href="#145-析构函数与资源销毁">14.5 析构函数与资源销毁</a></li>
      </ul>
    </li>
    <li><a href="#15-muduo-事件监听总结">15. muduo 事件监听总结</a>
      <ul>
        <li><a href="#151-channel及其文件描述符如何加入到poller中">15.1 Channel及其文件描述符如何加入到Poller中</a></li>
        <li><a href="#152-eventloop如何获取活跃的channel并处理相关事件">15.2 EventLoop如何获取活跃的Channel并处理相关事件</a></li>
        <li><a href="#153-eventloop如何处理定时器">15.3 EventLoop如何处理定时器</a></li>
        <li><a href="#154-eventloop与跨线程调用函数">15.4 EventLoop与跨线程调用函数</a></li>
      </ul>
    </li>
    <li><a href="#16-eventloopthread">16. EventLoopThread</a></li>
    <li><a href="#17-eventloopthreadpool">17. EventLoopThreadPool</a></li>
    <li><a href="#18-网络套接字相关">18. 网络套接字相关</a>
      <ul>
        <li><a href="#181-endian">18.1 Endian</a></li>
        <li><a href="#182-socketsops">18.2 SocketsOps</a>
          <ul>
            <li><a href="#1821-补充知识">18.2.1 补充知识</a></li>
            <li><a href="#1822-源码分析">18.2.2 源码分析</a></li>
          </ul>
        </li>
        <li><a href="#183-inetaddress">18.3 InetAddress</a></li>
        <li><a href="#184-socket">18.4 Socket</a></li>
      </ul>
    </li>
    <li><a href="#19-buffer">19. Buffer</a>
      <ul>
        <li><a href="#191-设计思想">19.1 设计思想</a></li>
        <li><a href="#192-几个重要的成员函数">19.2 几个重要的成员函数</a></li>
      </ul>
    </li>
    <li><a href="#20-acceptor">20. Acceptor</a></li>
    <li><a href="#21-tcpconnection">21. TcpConnection</a>
      <ul>
        <li><a href="#211-设计思想">21.1 设计思想</a></li>
        <li><a href="#212-tcp-网络编程的本质">21.2 TCP 网络编程的本质</a></li>
        <li><a href="#213-发送和接收缓冲区">21.3 发送和接收缓冲区</a></li>
        <li><a href="#214-连接事件处理">21.4 连接事件处理</a></li>
        <li><a href="#215-读事件处理">21.5 &ldquo;读&quot;事件处理</a></li>
        <li><a href="#216-发送数据">21.6 发送数据</a></li>
        <li><a href="#217-写事件处理">21.7 &ldquo;写&quot;事件处理</a></li>
        <li><a href="#218-tcpconnection生存期管理">21.8 TcpConnection生存期管理</a></li>
      </ul>
    </li>
    <li><a href="#22-tcpserver">22. TcpServer</a>
      <ul>
        <li><a href="#221-io-线程">22.1 I/O 线程</a></li>
        <li><a href="#222-acceptor">22.2 Acceptor</a></li>
        <li><a href="#223-启动服务器">22.3 启动服务器</a></li>
        <li><a href="#224-处理客户端连接">22.4 处理客户端连接</a></li>
        <li><a href="#225-释放资源">22.5 释放资源</a></li>
      </ul>
    </li>
    <li><a href="#23-connector">23. Connector</a>
      <ul>
        <li><a href="#231-设计思想">23.1 设计思想</a></li>
        <li><a href="#232-连接服务端">23.2 连接服务端</a></li>
        <li><a href="#233-错误处理与重连">23.3 错误处理与重连</a></li>
        <li><a href="#234-处理写事件">23.4 处理&quot;写&quot;事件</a></li>
        <li><a href="#235-重置连接">23.5 重置连接</a></li>
      </ul>
    </li>
    <li><a href="#24-tcpclient">24. TcpClient</a></li>
    <li><a href="#25-tcp网络编程本质">25 TCP网络编程本质</a>
      <ul>
        <li><a href="#251-连接建立">25.1 连接建立</a></li>
        <li><a href="#252-消息到达">25.2 消息到达</a></li>
        <li><a href="#253-消息发送完毕">25.3 消息发送完毕</a></li>
        <li><a href="#254-连接断开">25.4 连接断开</a>
          <ul>
            <li><a href="#2541-被动断开">25.4.1 被动断开</a></li>
            <li><a href="#2542-主动断开">25.4.2 主动断开</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#26-阶段性总结">26. 阶段性总结</a></li>
    <li><a href="#test">Test</a>
      <ul>
        <li><a href="#eventloop">EventLoop</a></li>
        <li><a href="#timerqueue">TimerQueue</a></li>
        <li><a href="#eventloopthread">EventLoopThread</a></li>
        <li><a href="#acceptor">Acceptor</a></li>
        <li><a href="#tcpserver">TcpServer</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><blockquote>
<p>源码参考：<a href="https://github.com/Cui-Jiang-Tao/large_concurrency/tree/master/muduo"target="_blank" rel="external nofollow noopener noreferrer">Muduo</a></p>
</blockquote>
<h1 id="第二部分muduo网络库">第二部分：Muduo网络库</h1>
<h2 id="10-初探eventloop">10. 初探EventLoop</h2>
<h3 id="101-什么都不做的eventloop">10.1 什么都不做的EventLoop</h3>
<p>一个EventLoop就是一个事件循环，下面将通过一个&quot;什么都不做的EventLoop&quot;来大致描述下muduo中EventLoop的功能。</p>
<p>&ldquo;什么都不做的EventLoop&quot;有如下几个特点：</p>
<ul>
<li>one loop per thread意思是说每个线程最多只能有一个EventLoop对象。</li>
<li>EventLoop对象构造的时候，会检查当前线程是否已经创建了其他EventLoop对象，如果已创建，终止程序(LOG_FATAL)</li>
<li>EventLoop构造函数会记住本对象所属线程(threadId_)。</li>
<li>创建了EventLoop对象的线程称为IO线程，其功能是运行事件循环(EventLoop::loop)</li>
</ul>
<h3 id="102-one-loop-per-thread">10.2 one loop per thread</h3>
<p>这里指的是一个EventLoop只属于一个线程(但一个线程可以拥有多个EventLoop)，在muduo中，如果EventLoop一旦被创建，EventLoop会保持所属线程的一份tid拷贝，作为标识。如果该EventLoop被其他线程调用则会报错，muduo中使用EventLoop::assertInLoopThread()函数来判断该EventLoop对象是否是在所属线程中执行。</p>
<h3 id="103-事件循环">10.3 事件循环</h3>
<p>一个EventLoop里其实是调用了poll/epoll来跟踪所关注的文件描述符的，当有文件描述符上有事件发生时，EventLoop会得到那些发生事件的文件描述符信息。</p>
<h2 id="11-channel">11. Channel</h2>
<p>Channel，可以理解为是一个&quot;通道&rdquo;，该&quot;通道&quot;中绑定了一个文件描述符及其所关注事件、注册的读写事件等信息。</p>
<h3 id="111-channel与文件描述符">11.1 Channel与文件描述符</h3>
<p>一个Channel管理一个文件描述符，在创建Channel时需要指定：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Channel</span><span class="o">::</span><span class="n">Channel</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd__</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">fd_</span><span class="p">(</span><span class="n">fd__</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该文件描述符的关注事件可以用如下代码表示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">Channel</span><span class="o">::</span><span class="n">kNoneEvent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                <span class="c1">//没有事件：0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">Channel</span><span class="o">::</span><span class="n">kReadEvent</span> <span class="o">=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLPRI</span><span class="p">;</span> <span class="c1">//可读事件：3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">Channel</span><span class="o">::</span><span class="n">kWriteEvent</span> <span class="o">=</span> <span class="n">POLLOUT</span><span class="p">;</span>         <span class="c1">//可写事件：4
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些宏定义在poll.h头文件中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/* Event types that can be polled for.  These bits may be set in `events&#39;
</span></span></span><span class="line"><span class="cl"><span class="cm">   to indicate the interesting event types; they will appear in `revents&#39;
</span></span></span><span class="line"><span class="cl"><span class="cm">   to indicate the status of the file descriptor.  */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define POLLIN		0x001		</span><span class="cm">/* There is data to read.  */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define POLLPRI		0x002		</span><span class="cm">/* There is urgent data to read.  */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define POLLOUT		0x004		</span><span class="cm">/* Writing now will not block.  */</span><span class="cp">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在Channel内部也定义了events_和revents_来标记文件描述符所关注的事件以及实际发生的事件，该方法和struct pollfd 结构体类似：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">events_</span><span class="p">;</span>  <span class="c1">// 关注的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">revents_</span><span class="p">;</span> <span class="c1">// poll/epoll返回的事件，即实际监听到发生的事件类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>muduo提供了下面这些函数来设置文件描述符关注事件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">enableReading</span><span class="p">()</span> <span class="p">{</span> <span class="n">events_</span> <span class="o">|=</span> <span class="n">kReadEvent</span><span class="p">;</span> <span class="n">update</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">enableWriting</span><span class="p">()</span> <span class="p">{</span> <span class="n">events_</span> <span class="o">|=</span> <span class="n">kWriteEvent</span><span class="p">;</span> <span class="n">update</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">disableWriting</span><span class="p">()</span> <span class="p">{</span> <span class="n">events_</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">kWriteEvent</span><span class="p">;</span> <span class="n">update</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">disableAll</span><span class="p">()</span> <span class="p">{</span> <span class="n">events_</span> <span class="o">=</span> <span class="n">kNoneEvent</span><span class="p">;</span> <span class="n">update</span><span class="p">();</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中update函数的作用就是将该Channel及其绑定的文件描述符和EventLoop中的poll/epoll关联起来。</p>
<p>muduo也提供了下面函数来获取和设置文件描述符及其事件的状态，其中需要注意的是set_revents函数，该函数是被poll/epoll类中调用的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">fd</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fd_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">events</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">events_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">set_revents</span><span class="p">(</span><span class="kt">int</span> <span class="n">revt</span><span class="p">)</span> <span class="p">{</span> <span class="n">revents_</span> <span class="o">=</span> <span class="n">revt</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// used by pollers
</span></span></span><span class="line"><span class="cl"><span class="c1">// int revents() const { return revents_; }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">isNoneEvent</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">events_</span> <span class="o">==</span> <span class="n">kNoneEvent</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="112-设置监听回调函数">11.2 设置监听回调函数</h3>
<p>Channel中可以设置读、写、错误和关闭事件的回调函数，通过函数模板的方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">EventCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Timestamp</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ReadEventCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ReadEventCallback</span> <span class="n">readCallback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">EventCallback</span> <span class="n">writeCallback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">EventCallback</span> <span class="n">closeCallback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">EventCallback</span> <span class="n">errorCallback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setReadCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadEventCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">readCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setWriteCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">EventCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">writeCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setCloseCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">EventCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">closeCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setErrorCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">EventCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">errorCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="113-channel与eventloop关系">11.3 Channel与EventLoop关系</h3>
<p>一个Channel一定会关联一个EventLoop，和文件描述符一样，在构造函数中需要传入。一旦关联该EventLoop，EventLoop就可对该Channel操作。</p>
<h3 id="114-响应事件">11.4 响应事件</h3>
<p>muduo中定义了该函数来响应Channel所绑定的文件描述符发生事件及其回调函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//处理绑定的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Channel</span><span class="o">::</span><span class="n">handleEvent</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">tied_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">guard</span> <span class="o">=</span> <span class="n">tie_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">//确定shared_ptr指针还存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">guard</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">handleEventWithGuard</span><span class="p">(</span><span class="n">receiveTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">handleEventWithGuard</span><span class="p">(</span><span class="n">receiveTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * poll函数的事件标志符值：
</span></span></span><span class="line"><span class="cl"><span class="cm">*    常量	                 说明
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLIN	        普通或优先级带数据可读
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLRDNORM    	普通数据可读
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLRDBAND    	优先级带数据可读
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLPRI	        高优先级数据可读
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLOUT	        普通数据可写
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLWRNORM	    普通数据可写
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLWRBAND	    优先级带数据可写
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLERR	        发生错误
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLHUP	        对方描述符挂起
</span></span></span><span class="line"><span class="cl"><span class="cm">    POLLNVAL	    描述字不是一个打开的文件
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="c1">//开始选择性处理Channel对象绑定的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Channel</span><span class="o">::</span><span class="n">handleEventWithGuard</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">eventHandling_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">//处于处理事件中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// close
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">((</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="n">POLLHUP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">logHup_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_WARN</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Channel::handle_event() POLLHUP&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//符合关闭套接字的事件，回调close函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">closeCallback_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">closeCallback_</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//Invalid polling request.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="n">POLLNVAL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_WARN</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Channel::handle_event() POLLNVAL&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLNVAL</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">errorCallback_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">errorCallback_</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// read
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLPRI</span> <span class="o">|</span> <span class="n">POLLRDHUP</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">readCallback_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">readCallback_</span><span class="p">(</span><span class="n">receiveTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">revents_</span> <span class="o">&amp;</span> <span class="n">POLLOUT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">writeCallback_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">writeCallback_</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">eventHandling_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//事件已处理完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数会根据revents_判断该文件描述符上实际发生的事件类型，然后调用相关的注册的回调函数。例如如果是有POLLIN(读事件)产生，那么将调用readCallback_回调函数。</p>
<p>那么什么时候handleEvent函数会执行呢，在poll/epoll返回时，EventLoop对象在loop循环中会拿到有事件发生的Channel集合，并逐一执行它们的handleEvent函数。</p>
<h2 id="12-poller">12. Poller</h2>
<h3 id="121-poller">12.1 Poller</h3>
<p>Poller是一个抽象类，指的是muduo封装的PollPoller、EPollPoller及其父类Poller的总称。在muduo中定义了一个Poller类，该类中定义了一些PollPoller和EPollPoller必须要实现的函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">virtual</span> <span class="n">Timestamp</span> <span class="nf">poll</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMs</span><span class="p">,</span> <span class="n">ChannelList</span><span class="o">*</span> <span class="n">activeChannels</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">updateChannel</span><span class="p">(</span><span class="n">Channel</span><span class="o">*</span> <span class="n">channel</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">removeChannel</span><span class="p">(</span><span class="n">Channel</span><span class="o">*</span> <span class="n">channel</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个Channel管理一个文件描述符fd的所有信息与操作，但如果要将文件描述符和poll/epoll关联和注册事件监听，Poller也需要关联Channel并提供相关操作的函数。但是由于poll/epoll的poll函数和操作的方法及其数据结构不同，所以这些具体的实现还是要放在PollPoller和EPollPoller中。</p>
<p>muduo提供了两种事件循环的类PollPoller和EPollPoller，同时也提供了该函数来选择使用哪一个：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Poller</span> <span class="o">*</span><span class="n">Poller</span><span class="o">::</span><span class="n">newDefaultPoller</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">getenv</span><span class="p">(</span><span class="s">&#34;MUDUO_USE_POLL&#34;</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nf">PollPoller</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nf">EPollPoller</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="122-poller分析">12.2 Poller分析</h3>
<h4 id="1221-pollpoller和eventloop关系">12.2.1 PollPoller和EventLoop关系</h4>
<p>一个EventLoop关联一个PollPoller，Channel的update会调用EventLoop的update函数，而EventLoop又调用Poller相关的函数。EventLoop之所以能够&quot;事件循环&quot;也是其内部调用Poller的poll函数。</p>
<h4 id="1222-pollpoller和channel的关系">12.2.2 PollPoller和Channel的关系</h4>
<p>Channel管理了一个文件描述符，在muduo中，一个Channel可以看作是一个文件描述符的&quot;代表&quot;，如果要操作一个文件描述符，则必须是通过该文件描述符对应的Channel。PollPoller需要监听和返回这些文件描述符上注册和实际发生的事件，所以必须提供操作Channel的函数和数据结构。下面这两个数据结构用于保存文件描述符及其Channel：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">struct</span> <span class="nc">pollfd</span><span class="o">&gt;</span> <span class="n">PollFdList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Channel</span><span class="o">*&gt;</span> <span class="n">ChannelMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PollFdList</span> <span class="n">pollfds_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ChannelMap</span> <span class="n">channels_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>pollfds_的作用非常明显，因为poll函数需要一个struct pollfd的数组地址，所以该结构是用于poll函数参数。</li>
<li>channels_则是用于管理注册的Channel的，key是Channel对应的文件描述符fd，value就是该Channel的地址，使用map数据结构可以很方便地对Channel进行查找和删除。</li>
</ul>
<h4 id="1223-update-和-remove-channel">12.2.3 update 和 remove Channel</h4>
<p><strong>1. updateChannel 函数</strong></p>
<p>由于需要更新一个Channel，所以该函数的参数只有Channel的一份指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 主要时将Channel负责的文件描述符(fd)注册到Poller对象中, 或更新Poller对象
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">PollPoller</span><span class="o">::</span><span class="n">updateChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Poller</span><span class="o">::</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; events = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// index &lt; 0说明是一个新的通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// a new one, add to pollfds_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">())</span> <span class="o">==</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">pollfd</span> <span class="n">pfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">pfd</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">pfd</span><span class="p">.</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// channel-&gt;revents()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pollfds_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">channels_</span><span class="p">[</span><span class="n">pfd</span><span class="p">.</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span> <span class="c1">//通过文件描述符(fd) 映射 Channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// update existing one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//已存在的Channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">())</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// index的取值必定在channels_.size()内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 更新pollfds_容器的信息(struct pollfd)
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">pollfd</span> <span class="o">&amp;</span><span class="n">pfd</span> <span class="o">=</span> <span class="n">pollfds_</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// pfd.fd == -1 代表此Chanel不需被Poller::poll检测
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">||</span> <span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">pfd</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">pfd</span><span class="p">.</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//如果不再关注该Channel中文件描述符事件，则直接将该文件描述符赋值为其相反数减一。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将一个通道暂时更改为不关注事件，但不从Poller中移除该通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">isNoneEvent</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// ignore this pollfd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 暂时忽略该文件描述符的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 这里pfd.fd 可以直接设置为-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 这样子设置是为了removeChannel优化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>channel-&gt;index() &lt; 0</code>分支：</p>
<ul>
<li>当一个Channel创建后默认设置自身的index_为-1，所以对于新创建的Channel如果被更新，那么一定是走<code>channel-&gt;index() &lt; 0</code>分支的。既然该Channel是刚创建并且是第一次和PollPoller关联，那么PollPoller中一定不会存在该Channel的信息，所以使用了该断言。</li>
<li>再接下来就是构造一个pollfd结构体并将该结构体的文件信息通过Channel保存起来，供下次poll函数调用。</li>
<li>需要注意的是，上面Channel的index_被设置为当前pollfds_的实际长度减一，这也是为了方便快速获取到pollfds_向量中的对应的文件描述符，有了该文件描述又可以很快从channels_中获取到该Channel，这个过程的代价很小，几乎不需要遍历。</li>
</ul>
<p>接下来分析<code>channel-&gt;index() &gt; 0</code> 的情况：</p>
<ul>
<li>发生这种情况也意味着该Channel之前已经注册到该PollPoller中了，但是由于一些原因需要修改该文件描述符的关注事件，对于这种情况的Channel将调用else分支代码。</li>
<li>代码中两个assert断言该Channel是否已经和PollPoller关联，如果关联则取出该pollfd数组中的该Channel对应的文件描述符及其结构体，更新该结构体中文件描述符监听事件。如果不再关注该Channel中文件描述符事件，则直接将该文件描述符赋值为其相反数减一。</li>
</ul>
<p><strong>2. removeChannel 函数</strong></p>
<p>使用该函数之前一般需要调用 updateChannel 函数设置不再关注该Channel对应的文件描述符上的事件。</p>
<p>该函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">PollPoller</span><span class="o">::</span><span class="n">removeChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Poller</span><span class="o">::</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">())</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">isNoneEvent</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="k">struct</span> <span class="nc">pollfd</span> <span class="o">&amp;</span><span class="n">pfd</span> <span class="o">=</span> <span class="n">pollfds_</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">pfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">pfd</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pfd</span><span class="p">.</span><span class="n">events</span> <span class="o">==</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">pollfds_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里移除的算法复杂度是O(1)，将待删除元素与最后一个元素交换再pop_back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">channelAtEnd</span> <span class="o">=</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">iter_swap</span><span class="p">(</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//不再关注该Channel中文件描述符事件，通过这种方式获取原有的下标(key)位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">channelAtEnd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">channelAtEnd</span> <span class="o">=</span> <span class="o">-</span><span class="n">channelAtEnd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">channels_</span><span class="p">[</span><span class="n">channelAtEnd</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pollfds_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>首先三个断言确认该Channel已经和PollPoller关联而且确认该Channel上的文件描述符事件不再关注，然后找到该Channel文件描述符在pollfds_数组中的位置，将该Channel从Channels_中去除，将该文件描述符对应的pollfd从pollfds_数组中去除。</li>
<li>从pollfs_数组中去除一个pollfd，Muduo使用了一个技巧，如果要去除的pollfd结构是数组中的最后一个元素，则调用pop_back函数直接弹出，否则将该元素和数组中最后一个元素交换位置，然后弹出最后一个元素，这样保证了pollfds_数组元素是连续的，不存在中间缺失的情况。</li>
</ul>
<h4 id="1224-poll">12.2.4 poll</h4>
<p>poll函数是在EventLoop中调用的，EventLoop希望通过该函数获取到当前的活动Channel(文件描述符上有事件发生)集合，所以会传入一个ChannelList* activeChannels作为poll的参数，该结构是一个vector集合，保存Channel的地址，定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">*&gt;</span> <span class="n">ChannelList</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>poll函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * poll机制与select机制类似，通过管理文件描述符来进行轮询，效率更高，并且处理的连接个数不受内核的限制。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 通过poll的方式进行轮询，通过Poller::fillActiveChannels得到活跃事件
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">Timestamp</span> <span class="n">PollPoller</span><span class="o">::</span><span class="n">poll</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMs</span><span class="p">,</span> <span class="n">ChannelList</span> <span class="o">*</span><span class="n">activeChannels</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// XXX pollfds_ shouldn&#39;t change
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">numEvents</span> <span class="o">=</span> <span class="o">::</span><span class="n">poll</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">pollfds_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">timeoutMs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="nf">now</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">numEvents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="n">numEvents</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; events happended&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fillActiveChannels</span><span class="p">(</span><span class="n">numEvents</span><span class="p">,</span> <span class="n">activeChannels</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">numEvents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; nothing happended&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;PollPoller::poll()&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>该函数的第一个参数是超时时间，第二个参数是EventLoop中需要的活动通道集合。该函数的内部也是调用了poll函数，当poll返回时，该函数会获取当前时间戳，作为函数返回值使用。</li>
</ul>
<p>poll的返回值：</p>
<ul>
<li>如果poll返回为0，则说明poll超时但没有发生任何事件；</li>
<li>如果poll为负值，则说明poll系统调用失败；</li>
<li>如果poll正常返回一个整数，则说明当前有文件描述符活动，需要获取这些文件描述符对应的Channel，并返回给EventLoop，这里使用了fillActiveChannels来获取这些活跃的通道；</li>
</ul>
<p>fillActiveChannels函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * struct pollfd {
</span></span></span><span class="line"><span class="cl"><span class="cm">    int fd;         	  // 用于检测的文件描述符
</span></span></span><span class="line"><span class="cl"><span class="cm">    short events;         // 等待的事件类型
</span></span></span><span class="line"><span class="cl"><span class="cm">    short revents;        // 实际发生的事件类型
</span></span></span><span class="line"><span class="cl"><span class="cm">  } ;
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">  通过fd 获得发生事件的Chanel集合
</span></span></span><span class="line"><span class="cl"><span class="cm">**/</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">PollPoller</span><span class="o">::</span><span class="n">fillActiveChannels</span><span class="p">(</span><span class="kt">int</span> <span class="n">numEvents</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">ChannelList</span> <span class="o">*</span><span class="n">activeChannels</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">PollFdList</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">pfd</span> <span class="o">=</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="n">pfd</span> <span class="o">!=</span> <span class="n">pollfds_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">numEvents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">pfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pfd</span><span class="o">-&gt;</span><span class="n">revents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">--</span><span class="n">numEvents</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">ChannelMap</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">pfd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">ch</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">==</span> <span class="n">pfd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_revents</span><span class="p">(</span><span class="n">pfd</span><span class="o">-&gt;</span><span class="n">revents</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// pfd-&gt;revents = 0;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">activeChannels</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是Channel的index_，在PollPoller中，如果index_为-1，则说明该Channel是新的需要加入的通道；如果index_&gt;0，则说明该Channel已经和PollPoller关联了，index_的值用于在pollfds_数组中查找文件描述符对应的pollfd如果index_为其他负值，则说明该文件描述符将不被关注，该Channel也将被移除。</p>
<h3 id="123-epollpoller-分析">12.3 EPollPoller 分析</h3>
<h4 id="1231-epollpoller和eventloop关系">12.3.1 EPollPoller和EventLoop关系</h4>
<p>一个EventLoop关联一个EPollPoller，Channel的update会调用EventLoop的update函数，而EventLoop又调用Poller相关的函数。EventLoop之所以能够&quot;事件循环&quot;也是其内部调用Poller的poll函数。</p>
<h4 id="1232-epollpoller和channel的关系">12.3.2 EPollPoller和Channel的关系</h4>
<p>Channel管理了一个文件描述符，在muduo中，一个Channel可以看作是一个文件描述符的&quot;代表&quot;，如果要操作一个文件描述符，则必须是通过该文件描述符对应的Channel。EPollPoller需要监听和返回这些文件描述符上注册和实际发生的事件，所以必须提供操作Channel的函数和数据结构。下面这两个数据结构用于保存文件描述符及其Channel：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">struct</span> <span class="nc">epoll_event</span><span class="o">&gt;</span> <span class="n">EventList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Channel</span><span class="o">*&gt;</span> <span class="n">ChannelMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventList</span> <span class="n">events_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ChannelMap</span> <span class="n">channels_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>EventList events_的作用非常明显，因为epoll函数需要一个struct epoll_event的数组地址，所以该结构是用于epoll_wait函数参数。ChannelMap channels_则是用于管理注册的Channel的，key是Channel对应的文件描述符fd，value就是该Channel的地址，使用map数据结构可以很方便的对Channel进行查找和操作。</p>
<h4 id="1233-update-和-remove-channel">12.3.3 update 和 remove Channel</h4>
<p><strong>1. updateChannel 函数</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//将Channel加入epoll中管理，updateChannel方法一定是I/O线程调用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">updateChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Poller</span><span class="o">::</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; events = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kNew</span> <span class="o">||</span> <span class="n">index</span> <span class="o">==</span> <span class="n">kDeleted</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// a new one, add with EPOLL_CTL_ADD
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kNew</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">==</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">channels_</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="c1">// index == kDeleted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//也就是说，当Channel对象的无事件，可以通过index_来标识为删除状态，并不会从channels_容器中移除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">kAdded</span><span class="p">);</span>     <span class="c1">//设置Channel对象为添加状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">update</span><span class="p">(</span><span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span> <span class="c1">//添加到epoll中监视
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// update existing one with EPOLL_CTL_MOD/DEL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//更新已存在的Channel描述符，修改或删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kAdded</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//当Channel对象不绑定事件，那么就从epoll的监视中移除，并设置Channel对象为删除状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">isNoneEvent</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">update</span><span class="p">(</span><span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">kDeleted</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">//更新epoll中监视的Channel对象的信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">update</span><span class="p">(</span><span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数的作用和PollPoller函数作用是一样的。当一个Channel的index_为-1时则说明这个Channel并没有和EPollPoller关联，如果index_为2，则说明该通道被取消过关注，如果为1则说明该Channel已经和EPollPoller关联，需要更新相关文件描述符的一些监听事件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">kNew</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>        <span class="c1">//还没有和EPollPoller关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">kAdded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1">//该Channel已经和EPollPoller关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">kDeleted</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>     <span class="c1">//该通道被取消关注
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果index_是kNew或者kDeleted，则说明需要将该通道和该EPollPoller关联，设置index_为kAdded，然后调用update函数将该通道和EPollPoller关联：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//更新Channel对象绑定的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">operation</span><span class="p">,</span> <span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">epoll_event</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">event</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd_</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">operation</span> <span class="o">==</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;epoll_ctl op=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">operation</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; fd=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_SYSFATAL</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;epoll_ctl op=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">operation</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; fd=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>update函数内部也是调用了epoll_ctl函数。需要注意的是，epoll_event里并没有设置文件描述符，而是用了event.data.ptr指针保存了Channel，毕竟Channel中包含的文件描述符信息更加丰富。</p>
<p>如果index_已经是added状态，那么判断该Channel中文件描述符是否被设置为&quot;不关注&quot;，如果是的话，直接调用updata函数将该文件描述符移除epoll事件监听，否则更新该文件描述符结构的events监听事件。</p>
<p><strong>2. removeChannel 函数</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 将Channel对象从channels_容器和epoll监控中移除，此操作必须是I/O线程调用的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">removeChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Poller</span><span class="o">::</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channels_</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">isNoneEvent</span><span class="p">());</span> <span class="c1">//要移除的Channel对象本身一定是无事件的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 要移除的Channel对象应该就可能处于关联状态、也可能处于被取消关注状态(kDeleted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kAdded</span> <span class="o">||</span> <span class="n">index</span> <span class="o">==</span> <span class="n">kDeleted</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 处于关联状态，说明epoll还在监视它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">kAdded</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">update</span><span class="p">(</span><span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 重新设置Channel为未被管理的初始状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_index</span><span class="p">(</span><span class="n">kNew</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数将取消对Channel对应的文件描述的事件监听，然后将该Channel从channels_中删除。</p>
<h4 id="1234-poll">12.3.4 poll</h4>
<p>poll函数是在EventLoop中调用的，EventLoop希望通过该函数获取到当前的活动Channel(文件描述符上有事件发生)集合，所以会传入一个ChannelList* activeChannels作为poll的参数，该结构是一个vector集合，保存Channel的地址，定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">*&gt;</span> <span class="n">ChannelList</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>poll函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Timestamp</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">poll</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMs</span><span class="p">,</span> <span class="n">ChannelList</span> <span class="o">*</span><span class="n">activeChannels</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//活跃的事件数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">numEvents</span> <span class="o">=</span> <span class="o">::</span><span class="n">epoll_wait</span><span class="p">(</span><span class="n">epollfd_</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">events_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                               <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">events_</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">timeoutMs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="nf">now</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">numEvents</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="n">numEvents</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; events happended&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fillActiveChannels</span><span class="p">(</span><span class="n">numEvents</span><span class="p">,</span> <span class="n">activeChannels</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//活跃的事件数量太多了，扩容，动态调整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numEvents</span><span class="p">)</span> <span class="o">==</span> <span class="n">events_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">events_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">events_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">numEvents</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; nothing happended&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// numEvents &lt; 0 的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;EPollPoller::poll()&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数的第一个参数是超时时间，第二个参数是EventLoop中需要的活动通道集合。该函数的内部也是调用了epoll_wait函数，该函数需要一个额外的文件描述符作为epollfd_，该文件描述符在构造函数初始化参数中中已经初始化了。</p>
<p>当epoll_wait返回时，获取当前时间戳，作为EPollPoller::poll函数返回值使用。</p>
<ul>
<li>如果epoll_wait返回为0，则说明epoll_wait超时且没有发生任何事件；</li>
<li>如果poll为负值，则说明poll系统调用失败；</li>
<li>如果poll正常返回一个整数，则说明当前有文件描述符活动，需要获取这些文件描述符对应的Channel，并返回给EventLoop，这里使用了fillActiveChannels来获取这些活跃的通道，当活跃的文件描述达到events_数组大小时，该数组将会扩容一倍，以满足更多需求，也减少了vector动态扩张的次数。</li>
</ul>
<p>fillActiveChannels函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EPollPoller</span><span class="o">::</span><span class="n">fillActiveChannels</span><span class="p">(</span><span class="kt">int</span> <span class="n">numEvents</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">ChannelList</span> <span class="o">*</span><span class="n">activeChannels</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//活跃的事件数量不可能比装所有事件的容器的元素数量多
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numEvents</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">events_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEvents</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Channel</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">events_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// NDEBUG模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#ifndef NDEBUG
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">channel</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">ChannelMap</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">channels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">==</span> <span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">    <span class="n">channel</span><span class="o">-&gt;</span><span class="n">set_revents</span><span class="p">(</span><span class="n">events_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">activeChannels</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是EPollPoller的文件描述符epollfd_，由于EPollPoller是采用RAII技法编写的，在构造函数中创建了文件描述符epollfd_，那么在析构函数中也应该关闭epollfd_并释放资源：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EPollPoller</span><span class="o">::~</span><span class="n">EPollPoller</span><span class="p">()</span> <span class="p">{</span> <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">epollfd_</span><span class="p">);</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="13-定时器">13. 定时器</h2>
<p>muduo的定时器由三个类实现，TimerId、Timer、TimerQueue，用户只能看到第一个类，其它两个都是内部实现细节。</p>
<h3 id="131-timerfd_系列定时器">13.1 timerfd_*系列定时器</h3>
<p>muduo选择了timerfd_*系列作为定时器。</p>
<p>下面这组函数便是操作timerfd的系统调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/timerfd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">timerfd_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">clockid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">timerfd_settime</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="o">*</span><span class="n">new_value</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="o">*</span><span class="n">old_value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">timerfd_gettime</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="o">*</span><span class="n">curr_value</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>timerfd_create</strong>，它是用来创建一个定时器描述符timerfd</p>
<ul>
<li>第一个参数：clockid指定时间类型，有两个值：
<ul>
<li>CLOCK_REALTIME :Systemwide realtime clock. 系统范围内的实时时钟</li>
<li>CLOCK_MONOTONIC:以固定的速率运行，从不进行调整和复位 ,它不受任何系统time-of-day时钟修改的影响</li>
</ul>
</li>
<li>第二个参数：flags可以是0或者O_CLOEXEC/O_NONBLOCK。</li>
<li>返回值：timerfd(文件描述符)</li>
</ul>
<p><strong>timerfd_settime</strong>，该函数作用是用来启动或关闭有fd指定的定时器。在讲解该函数前，先理解两个相关结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">timespec</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">time_t</span> <span class="n">tv_sec</span><span class="p">;</span>      <span class="cm">/* Seconds */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span>   <span class="n">tv_nsec</span><span class="p">;</span>     <span class="cm">/* Nanoseconds */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">itimerspec</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">it_interval</span><span class="p">;</span>  <span class="cm">/* Interval for periodic timer */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">it_value</span><span class="p">;</span>     <span class="cm">/* Initial expiration */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二个结构体itimerspec就是timerfd要设置的超时结构体，它的成员it_value表示定时器第一次超时时间，it_interval表示之后的超时时间即每隔多长时间超时</p>
<p>下面正式分析该函数的参数和返回值：</p>
<p>参数：</p>
<ul>
<li>fd：timerfd，有timerfd_create函数返回</li>
<li>flags：1代表设置的是绝对时间；为0代表相对时间</li>
<li>fnew_value：指定新的超时时间，设定new_value.it_value非零则启动定时器，否则关闭定时器，如果new_value.it_interval为0，则定时器只定时一次，即初始那次，否则之后每隔设定时间超时一次</li>
<li>old_value：不为null，则返回定时器这次设置之前的超时时间</li>
</ul>
<p><strong>timerfd_gettime</strong>，此函数用于获得定时器距离下次超时还剩下的时间。如果调用时定时器已经到期，并且该定时器处于循环模式(设置超时时间时struct itimerspec::it_interval不为0)，那么调用此函数之后定时器重新开始计时。</p>
<h3 id="132-timer-分析">13.2 Timer 分析</h3>
<p>一个定时器会在某一个时刻执行某个任务，而且有可能是&quot;定时执行&quot;，所以，一个Timer里封装了该Timer的超时时间(定时时间)、任务的执行周期等信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">TimerCallback</span> <span class="n">callback_</span><span class="p">;</span>  <span class="c1">//定时执行函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Timestamp</span> <span class="n">expiration_</span><span class="p">;</span>          <span class="c1">// 超时时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">double</span> <span class="n">interval_</span><span class="p">;</span>         <span class="c1">// 执行间隔
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">bool</span> <span class="n">repeat_</span><span class="p">;</span>             <span class="c1">// 是否重复定时执行任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int64_t</span> <span class="n">sequence_</span><span class="p">;</span>        <span class="c1">// 序列号，每个Tmier的序列号都不一样
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其中sequence_是通过对一个静态变量的原子增加来保证独一无二的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">AtomicInt64</span> <span class="n">s_numCreated_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该原子操作会在Timer构造函数初始化列表中完成初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Timer</span><span class="p">(</span><span class="k">const</span> <span class="n">TimerCallback</span><span class="o">&amp;</span> <span class="n">cb</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">when</span><span class="p">,</span> <span class="kt">double</span> <span class="n">interval</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">callback_</span><span class="p">(</span><span class="n">cb</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">expiration_</span><span class="p">(</span><span class="n">when</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">interval_</span><span class="p">(</span><span class="n">interval</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">repeat_</span><span class="p">(</span><span class="n">interval</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">sequence_</span><span class="p">(</span><span class="n">s_numCreated_</span><span class="p">.</span><span class="n">incrementAndGet</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Timer也提供了一些列函数来操作和获取这些变量值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">run</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">callback_</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//触发事件的时间戳
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Timestamp</span> <span class="nf">expiration</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">expiration_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">repeat</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">repeat_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="nf">sequence</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sequence_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">restart</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">numCreated</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s_numCreated_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果要重新设置该Timer的超时时间，可以通过下面这个函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果是重复的累加的，加入累加的时间重新设置到期时间，否则设置为失效时间
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Timer</span><span class="o">::</span><span class="n">restart</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">repeat_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 重新计算下一个超时时刻
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">expiration_</span> <span class="o">=</span> <span class="n">addTime</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">interval_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置无效的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">expiration_</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="o">::</span><span class="n">invalid</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="133-timerid-分析">13.3 TimerId 分析</h3>
<p>TimerId 中保存了一个Timer，以及该TimerId的序列号，同时将TimerQueue 设置为友元类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Timer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// An opaque identifier, for canceling Timer.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">TimerId</span> <span class="o">:</span> <span class="k">public</span> <span class="n">muduo</span><span class="o">::</span><span class="n">copyable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">TimerId</span><span class="p">()</span> <span class="o">:</span> <span class="n">timer_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">sequence_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">TimerId</span><span class="p">(</span><span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">seq</span><span class="p">)</span> <span class="o">:</span> <span class="n">timer_</span><span class="p">(</span><span class="n">timer</span><span class="p">),</span> <span class="n">sequence_</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// default copy-ctor, dtor and assignment are okay
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">class</span> <span class="nc">TimerQueue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timer</span> <span class="o">*</span><span class="n">timer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">sequence_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="134-timerqueue">13.4 TimerQueue</h3>
<h4 id="1341-timerqueue-设计原理">13.4.1 TimerQueue 设计原理</h4>
<p>一个TimerQueue 会关联一个EventLoop，一个TimerQueue中会绑定一个文件描述符timerfd以及Channel。该TimerQueue中保存众多的Timer，并且将这些Timer根据其超时时间从小到大放入一个集合中，其中最近超时时间将设置为timerfd的超时时间(也就是说将最近超时时间关联到timerfd上)，到了该时间，timerfd上会有读事件发生，然后定时器会将定时在该超时时间到真正处理该读事件之间的Timer获取到，执行这些Timer的定时函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// FIXME: use unique_ptr&lt;Timer&gt; instead of raw pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1">// unique_ptr是C++ 11标准的一个独享所有权的智能指针
</span></span></span><span class="line"><span class="cl"><span class="c1">// 无法得到指向同一对象的两个unique_ptr指针
</span></span></span><span class="line"><span class="cl"><span class="c1">// 但可以进行移动构造与移动赋值操作，即所有权可以移动到另一个对象(而非拷贝构造)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">Timer</span> <span class="o">*&gt;</span> <span class="n">Entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">TimerList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Timer</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">ActiveTimer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">ActiveTimer</span><span class="o">&gt;</span> <span class="n">ActiveTimerSet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span> <span class="c1">// 所属EventLoop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">timerfd_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Channel</span> <span class="n">timerfdChannel_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Timer list sorted by expiration
</span></span></span><span class="line"><span class="cl"><span class="c1">// set中的元素都是排好序的, 用于存储Timer，同时将Timer的到期时间戳作为key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TimerList</span> <span class="n">timers_</span><span class="p">;</span> <span class="c1">// timers_是按到期时间排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// for cancel()
</span></span></span><span class="line"><span class="cl"><span class="c1">// timers_与activeTimers_保存的是相同的数据 =》 利于操作，空间换效率吧？？？
</span></span></span><span class="line"><span class="cl"><span class="c1">// timers_是按到期时间排序，activeTimers_是按对象地址排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ActiveTimerSet</span> <span class="n">activeTimers_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">callingExpiredTimers_</span><span class="p">;</span>      <span class="c1">//用来确定是否正在调用回调函数的定时器/* atomic */
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ActiveTimerSet</span> <span class="n">cancelingTimers_</span><span class="p">;</span> <span class="c1">// 保存的是被取消的定时器
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>TimerQueue 的构造函数如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 一个TimerQueue只对应一个Eventloop和一个内部构造的Channel(构造对象时，默认绑定一个定时器对象timerfd_)
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 同时设置Channel的回调函数TimerQueue::handleRead
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">TimerQueue</span><span class="o">::</span><span class="n">TimerQueue</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span> <span class="n">timerfd_</span><span class="p">(</span><span class="n">createTimerfd</span><span class="p">()),</span> <span class="n">timerfdChannel_</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">timerfd_</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">timers_</span><span class="p">(),</span> <span class="n">callingExpiredTimers_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">timerfdChannel_</span><span class="p">.</span><span class="n">setReadCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// we are always reading the timerfd, we disarm it with timerfd_settime.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">timerfdChannel_</span><span class="p">.</span><span class="n">enableReading</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>构造函数中使用了createTimerfd来创建一个定时器文件描述符，该函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 创建定时器，生成一个定时器对象，返回与之关联的文件描述符timerfd。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">createTimerfd</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">timerfd</span> <span class="o">=</span> <span class="o">::</span><span class="n">timerfd_create</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">TFD_NONBLOCK</span> <span class="o">|</span> <span class="n">TFD_CLOEXEC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">timerfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSFATAL</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed in timerfd_create&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">timerfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>构造函数中Channel绑定的&quot;读事件&quot;回调函数是TimerQueue::handleRead，该函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * I/O线程才可调用
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 用来设置关联的Channel的回调函数
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">handleRead</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="nf">now</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 清除该事件，避免一直触发，并记录触发TimerQueue::handleRead回调函数的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">readTimerfd</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 获取该时刻之前所有的定时器列表(即超时定时器列表)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">expired</span> <span class="o">=</span> <span class="n">getExpired</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">callingExpiredTimers_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// safe to callback outside critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expired</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">expired</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里回调定时器处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">callingExpiredTimers_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 不是一次性定时器，需要重启
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">reset</span><span class="p">(</span><span class="n">expired</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果定时器超时，那么将执行该回调函数，该回调函数会调用readTimerfd函数先处理文件描述符事件，readTimerfd 函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 清除定时器，避免一直触发，并记录传入的时间戳
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">readTimerfd</span><span class="p">(</span><span class="kt">int</span> <span class="n">timerfd</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint64_t</span> <span class="n">howmany</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">timerfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">howmany</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">howmany</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TimerQueue::handleRead() &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">howmany</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; at &#34;</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="n">now</span><span class="p">.</span><span class="n">toString</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">howmany</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_ERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TimerQueue::handleRead() reads &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="s">&#34; bytes instead of 8&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在处理完文件描述符读事件后调用getExpired函数获取从文件描述符事件发生到当前时间内超时的Timer，然后遍历该集合，获取到Timer并执行其run函数(run函数中执行的是Timer真正的定时函数)。处理完这些超时的Timer后调用reset函数来重置这些Timer的定时任务，因为有些Timer是设置为循环执行的，所以还要重新设置它们的下一次执行时间。</p>
<h4 id="1342-向timerqueue-中添加一个timer">13.4.2 向TimerQueue 中添加一个Timer</h4>
<p>TimerQueue使用addTimer函数来向队列中添加一个Timer：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 添加一个新Timer，并及时更新；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果TimerList中元素只有一个或插入的Timer最快到期，马上重新设置TimerQueue对象绑定的timerfd的超时时间
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">TimerId</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimer</span><span class="p">(</span><span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">when</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="kt">double</span> <span class="n">interval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 该对象将存储到TimerList中
</span></span></span><span class="line"><span class="cl"><span class="cm">   * =&gt; std::set&lt;std::pair&lt;Timestamp, Timer*&gt;&gt; TimerList;
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Timer</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">when</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimerInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timer</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// addTimerInLoop(timer);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nf">TimerId</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数需要传入一个定时回调函数，一个超时时间戳和定时周期，TimerCallback的原型如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">TimerCallback</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建一个Timer，然后通过EventLoop调用TimerQueue::addTimerInLoop函数，最后TimerQueue::addTimer返回一个TimerId。runInLoop的实现细节在后面章节会解释，addTimerInLoop函数的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * I/O线程才可调用
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimerInLoop</span><span class="p">(</span><span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 插入一个定时器，有可能会使得最早到期的定时器发生改变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">earliestChanged</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">earliestChanged</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 重置定时器的超时时刻(timerfd_settime)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">resetTimerfd</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数又调用了insert函数，insert定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 返回值，插入的Timer是否是最早到期的时间;说明：插入的Timer元素是有序timers_(set集合)的第一个元素或唯一的元素为true
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 功能：插入一个std::pair&lt;Timestamp，Timer*&gt;对象，将参数timer的到期时间戳作为std::pair的first，Timner对象作为sencond
</span></span></span><span class="line"><span class="cl"><span class="cm"> * activeTimers_ 和 timers_两个容器保存的Timer对象是一样的，仅仅内存分布不同而已
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 最早到期时间是否改变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">earliestChanged</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="n">when</span> <span class="o">=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">TimerList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果timers_为空或者when小于timers_中的最早到期时间(这个插入的Timer是集合第一个到期的时间戳)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">timers_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">||</span> <span class="n">when</span> <span class="o">&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">earliestChanged</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 插入到timers_中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TimerList</span><span class="o">::</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">timers_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Entry</span><span class="p">(</span><span class="n">when</span><span class="p">,</span> <span class="n">timer</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// result.first代表插入的元素的iterator，result.second代表元素是否插入成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 插入到activeTimers_中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">ActiveTimerSet</span><span class="o">::</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">activeTimers_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ActiveTimer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">earliestChanged</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>insert函数会获取到该Timer的超时时间，如果该Timer的超时时间是最近的(比之前从小到大排列的超时集合最小的还小)，说明该Timer的定时函数是最早执行的，所以设置标志earliestChanged = true，然后将该Timer加入到timers_和activeTimers_中，然后返回earliestChanged。</p>
<p>回到TimerQueue::addTimerInLoop函数，该函数在插入一个Timer后，判断earliestChanged，如果该项为true，那么也需要重新设置TimerQueue的timerfd_的定时时间，则调用resetTimerfd函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 重置定时器的超时时间，重新设置Timer文件描述符(Timerfd)的超时时间，启动或停止定时器
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">resetTimerfd</span><span class="p">(</span><span class="kt">int</span> <span class="n">timerfd</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">expiration</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// wake up loop by timerfd_settime()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="n">newValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="n">oldValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newValue</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">newValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldValue</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">oldValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">newValue</span><span class="p">.</span><span class="n">it_value</span> <span class="o">=</span> <span class="n">howMuchTimeFromNow</span><span class="p">(</span><span class="n">expiration</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//启动或停止定时器，依据newValue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">::</span><span class="n">timerfd_settime</span><span class="p">(</span><span class="n">timerfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newValue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;timerfd_settime()&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1343-获取超时timer">13.4.3 获取超时Timer</h4>
<p>getExpired函数会获取到将小于传入时间戳now的Timer，将这些Timer的Entry保存到一个vector中并返回，同时删除timers_和activeTimers_中的这些和Timer相关的部分。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * rvo优化
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 返回一个到期时间std::vector&lt;Entry&gt;的容器
</span></span></span><span class="line"><span class="cl"><span class="cm"> * =》typedef std::pair&lt;Timestamp,Timer*&gt; Entry;
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">getExpired</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">expired</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// std::pair作为set的key时，比较pair 是先比较first, first相同再比较second
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Entry</span> <span class="nf">sentry</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Timer</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">UINTPTR_MAX</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 返回第一个未到期的Timer的迭代器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// lower_bound的含义是返回第一个值&gt;=sentry的元素的iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 即*end &gt;= sentry，从而end-&gt;first &gt; now
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">TimerList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">sentry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// timers_的集合全是过期的时间戳，或者？？？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">timers_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">||</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 将到期的定时器插入到expired中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">,</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">expired</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 从timers_中移除到期的定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">timers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 从activeTimers_中移除到期的定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expired</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">expired</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ActiveTimer</span> <span class="nf">timer</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">expired</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1344-向timerqueue-中取消一个timer">13.4.4 向TimerQueue 中取消一个Timer</h4>
<p>muduo使用cancle来取消一个Timer：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancel</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timerId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancelInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timerId</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数又调用了TimerQueue::cancelInLoop：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * I/O线程才可调用
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancelInLoop</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timerId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ActiveTimer</span> <span class="nf">timer</span><span class="p">(</span><span class="n">timerId</span><span class="p">.</span><span class="n">timer_</span><span class="p">,</span> <span class="n">timerId</span><span class="p">.</span><span class="n">sequence_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 查找该定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ActiveTimerSet</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">Entry</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">(),</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span> <span class="c1">// FIXME: no delete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                      <span class="c1">// please,如果用了unique_ptr,这里就不需要手动删除了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">activeTimers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">callingExpiredTimers_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 已经到期，并且正在调用回调函数的定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">timers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">activeTimers_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数以TimerId的方式从TimerQueue中删除相关Timer内容，如果该当前TimerQueue已经有超时事件产生(handleRead中callingExpiredTimers_设置为true)，TimerQueue::getExpired会删除超时的Timer，那么还需要将该Timer保存到&quot;待取消定时器队列&quot;中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">ActiveTimerSet</span> <span class="n">cancelingTimers_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1345-重置超时timer">13.4.5 重置超时Timer</h4>
<p>handleRead函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * I/O线程才可调用
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 用来设置关联的Channel的回调函数
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">handleRead</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="nf">now</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 清除该事件，避免一直触发，并记录触发TimerQueue::handleRead回调函数的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">readTimerfd</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 获取该时刻之前所有的定时器列表(即超时定时器列表)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">expired</span> <span class="o">=</span> <span class="n">getExpired</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">callingExpiredTimers_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// safe to callback outside critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expired</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">expired</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里回调定时器处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">callingExpiredTimers_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 不是一次性定时器，需要重启
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">reset</span><span class="p">(</span><span class="n">expired</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果已经去除队列中的超时定时器集合，这些集合的定时任务也处理完了之后还需要reset这些集合，因为一个定时器Timer可能设置了repeat_和interval_，需要重新设置下一次Timer的执行时间。reset函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 对已经过期的队列进行处理，如果是重复调用的，重新设置新的到期时间并加入Timer队列中继续监控；重新设置TimerQueue对象绑定的fd到期时间
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">reset</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">expired</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="n">nextExpire</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expired</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="n">it</span> <span class="o">!=</span> <span class="n">expired</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ActiveTimer</span> <span class="nf">timer</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果是重复的定时器并且是未取消定时器，则重启该定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">repeat</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="o">==</span> <span class="n">cancelingTimers_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//如果是重复的累加的，加入累加的时间重新设置到期时间，否则设置为失效时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">restart</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//将累加后新的Timer插入到Timer队列中，继续监控
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 一次性定时器或者已被取消的定时器是不能重置的，因此删除该定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// FIXME move to a free list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">delete</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span> <span class="c1">// FIXME: no delete please
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timers_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// //得到队列中第一个要到期的时间，获取最早到期的定时器超时时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">nextExpire</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">expiration</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//队列中还未到期的时间是有效的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">nextExpire</span><span class="p">.</span><span class="n">valid</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 重置定时器的超时时刻(timerfd_settime)，重新设置TimerQueue对象绑定的fd到期时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">resetTimerfd</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">,</span> <span class="n">nextExpire</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数会检查这些超时的定时器Timer，如果是设置了repeat_为true并且不在&quot;取消定时器队列&quot;中则重置下一次定时器执行时间，否则(如一次性定时任务，或者取消了但未能避免执行)则直接删除。在执行handleRead时也会将cancelingTimers_清空。最后设置TimerQueue的timerfd_最近定时时间，准备下一次执行定时事件的到来。</p>
<h4 id="1346-析构函数与资源销毁">13.4.6 析构函数与资源销毁</h4>
<p>关闭timerfd_文件描述符，释放管理的所有Timer资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">TimerQueue</span><span class="o">::~</span><span class="n">TimerQueue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">timerfd_</span><span class="p">);</span> <span class="c1">//关闭关联的描述符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// do not remove channel, since we&#39;re in EventLoop::dtor();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">TimerList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">timers_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="14-深入-eventloop">14. 深入 EventLoop</h2>
<p>已经分析过一个&quot;什么都不做的EventLoop&quot;，muduo中的EventLoop有如下几个特点：</p>
<ul>
<li>one loop per thread意思是说每个线程最多只能有一个EventLoop对象。</li>
<li>EventLoop对象构造的时候，会检查当前线程是否已经创建了其他EventLoop对象，如果已创建，终止程序(LOG_FATAL)</li>
<li>EventLoop构造函数会记住本对象所属线程(threadId_)。</li>
<li>创建了EventLoop对象的线程称为IO线程，其功能是运行事件循环(EventLoop::loop)</li>
</ul>
<p>下面将深入具体分析muduo中的EventLoop的实现。</p>
<h3 id="141-eventloop-与-channel">14.1 EventLoop 与 Channel</h3>
<p>&ldquo;一个Channel会关联一个EventLoop&rdquo;，当Channel设置了监听文件描述符关注事件类型后会调用update函数，Channel中的update函数也是间接调用EventLoop的updateChannel函数，然后又间接调用Poller的updateChannel函数，该函数将会将该Channel及其相关文件描述符和Poller的事件监听联系起来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//将Chanel注册到Poller对象的polldfs数组中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Channel</span><span class="o">::</span><span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">updateChannel</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">updateChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">ownerLoop</span><span class="p">()</span> <span class="o">==</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">poller_</span><span class="o">-&gt;</span><span class="n">updateChannel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样地，Channel的remove函数也是间接调用EventLoop的removeChannel函数来删除自身，Poller的removeChannel函数会取消该Channel及其文件描述符的事件监听，并不再保存该Channel及其文件描述符任何信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 调用这个函数之前确保调用disableAll
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Channel</span><span class="o">::</span><span class="n">remove</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">isNoneEvent</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">removeChannel</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">removeChannel</span><span class="p">(</span><span class="n">Channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">ownerLoop</span><span class="p">()</span> <span class="o">==</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">eventHandling_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">currentActiveChannel_</span> <span class="o">==</span> <span class="n">channel</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">           <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">activeChannels_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">activeChannels_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">channel</span><span class="p">)</span> <span class="o">==</span>
</span></span><span class="line"><span class="cl">               <span class="n">activeChannels_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">poller_</span><span class="o">-&gt;</span><span class="n">removeChannel</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="142-eventloop-与-timerqueue">14.2 EventLoop 与 TimerQueue</h3>
<p>EventLoop中持有一个TimerQueue，并在构造函数中完成了该TimerQueue的初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">TimerQueue</span><span class="o">&gt;</span> <span class="n">timerQueue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">::</span><span class="n">EventLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">looping_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">timerQueue_</span><span class="p">(</span><span class="k">new</span> <span class="n">TimerQueue</span><span class="p">(</span><span class="k">this</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来是一组定时器操作函数，用于添加定时器任务：</p>
<p>EventLoop.h</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Runs callback at &#39;time&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Safe to call from other threads.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">//直接回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TimerId</span> <span class="nf">runAt</span><span class="p">(</span><span class="k">const</span> <span class="n">Timestamp</span> <span class="o">&amp;</span><span class="n">time</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Runs callback after @c delay seconds.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Safe to call from other threads.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">//延期回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TimerId</span> <span class="nf">runAfter</span><span class="p">(</span><span class="kt">double</span> <span class="n">delay</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Runs callback every @c interval seconds.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Safe to call from other threads.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">//以interval的频率回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TimerId</span> <span class="nf">runEvery</span><span class="p">(</span><span class="kt">double</span> <span class="n">interval</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Cancels the timer.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Safe to call from other threads.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">cancel</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timerId</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>EventLoop.cpp</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">TimerId</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">runAt</span><span class="p">(</span><span class="k">const</span> <span class="n">Timestamp</span> <span class="o">&amp;</span><span class="n">time</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">timerQueue_</span><span class="o">-&gt;</span><span class="n">addTimer</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">TimerId</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">runAfter</span><span class="p">(</span><span class="kt">double</span> <span class="n">delay</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="nf">time</span><span class="p">(</span><span class="n">addTime</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span> <span class="n">delay</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">runAt</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">TimerId</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">runEvery</span><span class="p">(</span><span class="kt">double</span> <span class="n">interval</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="nf">time</span><span class="p">(</span><span class="n">addTime</span><span class="p">(</span><span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">(),</span> <span class="n">interval</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">timerQueue_</span><span class="o">-&gt;</span><span class="n">addTimer</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">cancel</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timerId</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">timerQueue_</span><span class="o">-&gt;</span><span class="n">cancel</span><span class="p">(</span><span class="n">timerId</span><span class="p">);</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>本质上这些函数也是调用了TimerQueue的addTimer和cancel函数，需要关注的是addTimer和cancel函数内部都是通过EventLoop::runInLoop函数调用的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 添加一个新Timer，并及时更新；
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果TimerList中元素只有一个或插入的Timer最快到期，马上重新设置TimerQueue对象绑定的timerfd的超时时间
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">TimerId</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimer</span><span class="p">(</span><span class="k">const</span> <span class="n">TimerCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">,</span> <span class="n">Timestamp</span> <span class="n">when</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="kt">double</span> <span class="n">interval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 该对象将存储到TimerList中
</span></span></span><span class="line"><span class="cl"><span class="cm">   * std::set&lt;std::pair&lt;Timestamp, std::unique_ptr&lt;Timer&gt;&gt;&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Timer</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">when</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimerInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timer</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// addTimerInLoop(timer);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nf">TimerId</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancel</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timerId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">cancelInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timerId</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// cancelInLoop(timerId);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用EventLoop::runInLoop能够保证该bind函数是在EventLoop所在线程内执行的，哪怕这个函数是在别的线程里被调用，关于EventLoop::runInLoop函数，后面的章节再分析它是如何实现跨线程安全调用的。</p>
<h3 id="143-eventloop-与-poller">14.3 EventLoop 与 Poller</h3>
<p>一个EventLoop持有一个poller：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Poller</span><span class="o">&gt;</span> <span class="n">poller_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">::</span><span class="n">EventLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">looping_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">poller_</span><span class="p">(</span><span class="n">Poller</span><span class="o">::</span><span class="n">newDefaultPoller</span><span class="p">(</span><span class="k">this</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Poller::newDefaultPoller会根据系统环境来选择是使用PollPoller还是EPollPoller：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Poller</span> <span class="o">*</span><span class="n">Poller</span><span class="o">::</span><span class="n">newDefaultPoller</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">getenv</span><span class="p">(</span><span class="s">&#34;MUDUO_USE_POLL&#34;</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nf">PollPoller</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nf">EPollPoller</span><span class="p">(</span><span class="n">loop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>EventLoop的核心函数loop便是调用了Poller的loop函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 事件循环，该函数不能跨线程调用
</span></span></span><span class="line"><span class="cl"><span class="c1">// 只能在创建该对象的线程中调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">looping_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 断言当前处于创建该对象的线程中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">looping_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">quit_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;EventLoop &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">this</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; start looping&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//::poll(NULL, 0, 5*1000);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">quit_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">activeChannels_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//执行完Poller::poll()的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pollReturnTime_</span> <span class="o">=</span> <span class="n">poller_</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">kPollTimeMs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">activeChannels_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//++iteration_;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">Logger</span><span class="o">::</span><span class="n">logLevel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">Logger</span><span class="o">::</span><span class="n">TRACE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">printActiveChannels</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO sort channel by priority
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">eventHandling_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">//标识事件正在处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">ChannelList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">activeChannels_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">         <span class="n">it</span> <span class="o">!=</span> <span class="n">activeChannels_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">currentActiveChannel_</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">currentActiveChannel_</span><span class="o">-&gt;</span><span class="n">handleEvent</span><span class="p">(</span><span class="n">pollReturnTime_</span><span class="p">);</span> <span class="c1">//事件处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">currentActiveChannel_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">eventHandling_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//标识事件已处理完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 让IO线程也能执行一些计算任务，IO不忙的时候，处于阻塞状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">doPendingFunctors</span><span class="p">();</span> <span class="c1">// 执行其他线程或者本线程添加的一些回调任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;EventLoop &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">this</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; stop looping&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">looping_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数通过调用Poller的poll函数，将活跃Channel保存到activeChannels_中，然后遍历这些Channel，执行它们的handleEvent函数，最后执行doPendingFunctors函数，该函数将在下一节介绍。</p>
<h3 id="144-跨线程执行函数">14.4 跨线程执行函数</h3>
<p>为了实现跨线程调用函数，muduo使用了如下数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">callingPendingFunctors_</span><span class="p">;</span> <span class="c1">//判断是否IO线程处理一些回调任务中=&gt;pendingFunctors_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">wakeupFd_</span><span class="p">;</span> <span class="c1">// 用于eventfd
</span></span></span><span class="line"><span class="cl"><span class="c1">// unlike in TimerQueue, which is an internal class,
</span></span></span><span class="line"><span class="cl"><span class="c1">// we don&#39;t expose Channel to client.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span> <span class="n">wakeupChannel_</span><span class="p">;</span> <span class="c1">// 该通道将会纳入poller_来管理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Functor</span><span class="o">&gt;</span> <span class="n">pendingFunctors_</span><span class="p">;</span> <span class="c1">// @BuardedBy mutex_   即将发生的回调，即在IO线程中执行需要执行回调函数集合
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>TimerQueue的更新和删除Timer会用到EventLoop::runInLoop函数，该函数的实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 在I/O线程中执行某个回调函数，该函数可以跨线程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">runInLoop</span><span class="p">(</span><span class="k">const</span> <span class="n">Functor</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">isInLoopThread</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果是当前IO线程调用runInLoop，则同步调用cb
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cb</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果是其它线程调用runInLoop，则异步地将cb添加到队列，以便让EventLoop所在的线程执行这个回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">queueInLoop</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以更新Timer为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TimerQueue</span><span class="o">::</span><span class="n">addTimerInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">timer</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果该代码时是在EventLoop所在线程中执行，那么TimerQueue::addTimerInLoop会立刻执行，否则TimerQueue::addTimerInLoop将通过queueInLoop函数送入到待执行函数队列中，queueInLoop定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">queueInLoop</span><span class="p">(</span><span class="k">const</span> <span class="n">Functor</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MutexLockGuard</span> <span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pendingFunctors_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 1. 调用queueInLoop的线程不是IO线程需要唤醒
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 2. 或者调用queueInLoop的线程是IO线程，并且此时正在调用任务队列(pendingFunctors_)，需要唤醒。
</span></span></span><span class="line"><span class="cl"><span class="cm">   *     =》 因为I/O处于callingPendingFunctors_状态，任务队列(pendingFunctors_)中的任务执行完可能会处于阻塞状态(poll没事件发生)，新加入的任务无法执行。
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 只有I/O线程的事件回调中调用queueInLoop才不需要唤醒
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInLoopThread</span><span class="p">()</span> <span class="o">||</span> <span class="n">callingPendingFunctors_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeup</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数会判断是否是在EventLoop所处线程中执行，如果不是的话则调用wakeup()函数。</p>
<p>先解释下跨线程调用的原理：一个EventLoop中有一个wakeupFd_文件描述符(eventfd 是一个比 pipe 更高效的线程间事件通知机制，一方面它比 pipe 少用一个 file descripor，节省了资源；另一方面，eventfd 的缓冲区管理也简单得多，全部&quot;buffer&quot; 只有定长8 bytes，不像 pipe 那样可能有不定长的真正 buffer)，该文件描述符在构造函数初始化列表中完成初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">createEventfd</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">evtfd</span> <span class="o">=</span> <span class="o">::</span><span class="n">eventfd</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">EFD_NONBLOCK</span> <span class="o">|</span> <span class="n">EFD_CLOEXEC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">evtfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed in eventfd&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">abort</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">evtfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">::</span><span class="n">EventLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">looping_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeupFd_</span><span class="p">(</span><span class="n">createEventfd</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而且EventLoop也为该wakeuFd_文件描述符提供了一个Channel，该Channel的生命周期由EventLoop对象负责：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span> <span class="n">wakeupChannel_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该Channel也在构造函数中完成了初始化工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">::</span><span class="n">EventLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">looping_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeupFd_</span><span class="p">(</span><span class="n">createEventfd</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeupChannel_</span><span class="p">(</span><span class="k">new</span> <span class="n">Channel</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">wakeupFd_</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">wakeupChannel_</span><span class="o">-&gt;</span><span class="n">setReadCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EventLoop</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// we are always reading the wakeupfd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//这里设置会将wakeupChannel_注册到Poller对象中，实现事件循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">wakeupChannel_</span><span class="o">-&gt;</span><span class="n">enableReading</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该Channel也加入到了Poller事件监听中，并且设置了&quot;读事件&quot;回调函数为EventLoop::handleRead：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// eventfd 事件处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">handleRead</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint64_t</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">wakeupFd_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">one</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">one</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_ERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;EventLoop::handleRead() reads &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; bytes instead of 8&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在回到queueInLoop函数中，可以正式介绍wake()函数了，wakeup函数功能就是向wakeupFd_写入东西，然后促使Poller的poll函数返回：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 唤醒，写uint64_t类型的字节就可产生可读事件，达到唤醒的目的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">wakeup</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint64_t</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ssize_t n = sockets::write(wakeupFd_, &amp;one, sizeof one);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">wakeupFd_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">one</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">one</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_ERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;EventLoop::wakeup() writes &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; bytes instead of 8&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">quit_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">activeChannels_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">pollReturnTime_</span> <span class="o">=</span> <span class="n">poller_</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">kPollTimeMs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">activeChannels_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">doPendingFunctors</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后进而调用doPendingFunctors函数，在该函数中执行这些跨线程调用的&quot;未决函数&quot;：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//在IO线程中执行一些回调任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">doPendingFunctors</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Functor</span><span class="o">&gt;</span> <span class="n">functors</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">callingPendingFunctors_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MutexLockGuard</span> <span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//可以减小临界区的长度(意味着不会阻塞其它线程的queueInLoop())，另一方面，也避免了死锁(因为Functor可能再次调用queueInLoop())
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">functors</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">pendingFunctors_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">functors</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">functors</span><span class="p">[</span><span class="n">i</span><span class="p">]();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">callingPendingFunctors_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样即使是跨线程调用某些函数，这些函数也不会立刻执行，而是存入该pendingFunctors_集合中等待wake，然后在EventLoop线程中&quot;打包&quot;执行。</p>
<p>需要注意的是：</p>
<ul>
<li>不是简单地在临界区内依次调用Functor，而是把回调列表swap到functors中，这样一方面减小了临界区的长度(意味着不会阻塞其它线程的queueInLoop())，另一方面，也避免了死锁(因为Functor可能再次调用queueInLoop())</li>
<li>由于doPendingFunctors()调用的Functor可能再次调用queueInLoop(cb)，这时，queueInLoop()就必须wakeup()，否则新增的cb可能就不能及时调用了</li>
<li>muduo没有反复执行doPendingFunctors()直到pendingFunctors为空，这是有意的，否则IO线程可能陷入死循环，无法处理IO事件。</li>
</ul>
<h3 id="145-析构函数与资源销毁">14.5 析构函数与资源销毁</h3>
<p>整个EventLoop中创建了如下资源：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">::</span><span class="n">EventLoop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">looping_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">poller_</span><span class="p">(</span><span class="n">Poller</span><span class="o">::</span><span class="n">newDefaultPoller</span><span class="p">(</span><span class="k">this</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">timerQueue_</span><span class="p">(</span><span class="k">new</span> <span class="n">TimerQueue</span><span class="p">(</span><span class="k">this</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeupFd_</span><span class="p">(</span><span class="n">createEventfd</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeupChannel_</span><span class="p">(</span><span class="k">new</span> <span class="n">Channel</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">wakeupFd_</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然而这些资源除了wakeupFd_以外都是使用智能指针来管理的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Poller</span><span class="o">&gt;</span> <span class="n">poller_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">TimerQueue</span><span class="o">&gt;</span> <span class="n">timerQueue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">wakeupFd_</span><span class="p">;</span> <span class="c1">// 用于eventfd
</span></span></span><span class="line"><span class="cl"><span class="c1">// unlike in TimerQueue, which is an internal class,
</span></span></span><span class="line"><span class="cl"><span class="c1">// we don&#39;t expose Channel to client.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span> <span class="n">wakeupChannel_</span><span class="p">;</span> <span class="c1">// 该通道将会纳入poller_来管理
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>所以析构函数只需要释放wakeupFd_文件描述符即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">::~</span><span class="n">EventLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//析构，EventLoop对象一定不会是looping状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">looping_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">wakeupFd_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">t_loopInThisThread</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="15-muduo-事件监听总结">15. muduo 事件监听总结</h2>
<h3 id="151-channel及其文件描述符如何加入到poller中">15.1 Channel及其文件描述符如何加入到Poller中</h3>
<p><img loading="lazy" src="../../imgs/muduo/net_1.jpg" srcset="../../imgs/muduo/net_1.jpg, ../../imgs/muduo/net_1.jpg 1.5x, ../../imgs/muduo/net_1.jpg 2x" sizes="auto" data-title="../../imgs/muduo/net_1.jpg" data-alt="../../imgs/muduo/net_1.jpg" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h3 id="152-eventloop如何获取活跃的channel并处理相关事件">15.2 EventLoop如何获取活跃的Channel并处理相关事件</h3>
<p><img loading="lazy" src="../../imgs/muduo/net_2.jpg" srcset="../../imgs/muduo/net_2.jpg, ../../imgs/muduo/net_2.jpg 1.5x, ../../imgs/muduo/net_2.jpg 2x" sizes="auto" data-title="../../imgs/muduo/net_2.jpg" data-alt="../../imgs/muduo/net_2.jpg" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h3 id="153-eventloop如何处理定时器">15.3 EventLoop如何处理定时器</h3>
<p><img loading="lazy" src="../../imgs/muduo/net_3.jpg" srcset="../../imgs/muduo/net_3.jpg, ../../imgs/muduo/net_3.jpg 1.5x, ../../imgs/muduo/net_3.jpg 2x" sizes="auto" data-title="../../imgs/muduo/net_3.jpg" data-alt="../../imgs/muduo/net_3.jpg" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h3 id="154-eventloop与跨线程调用函数">15.4 EventLoop与跨线程调用函数</h3>
<p><img loading="lazy" src="../../imgs/muduo/net_4.jpg" srcset="../../imgs/muduo/net_4.jpg, ../../imgs/muduo/net_4.jpg 1.5x, ../../imgs/muduo/net_4.jpg 2x" sizes="auto" data-title="../../imgs/muduo/net_4.jpg" data-alt="../../imgs/muduo/net_4.jpg" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<ul>
<li>调用queueInLoop的线程不是当前IO线程需要唤醒</li>
<li>或者调用queueInLoop的线程是当前IO线程，并且此时正在调用pending functor，需要唤醒</li>
<li>只有IO线程的事件回调中调用queueInLoop才不需要唤醒</li>
</ul>
<h2 id="16-eventloopthread">16. EventLoopThread</h2>
<p>任何一个线程，只要创建并运行了EventLoop，都称之为IO线程，所以IO线程不一定是主线程。</p>
<p>muduo并发模型one loop per thread + threadpool，为了方便今后使用，定义了EventLoopThread类，该类封装了IO线程。EventLoopThread创建了一个线程，然后在线程函数中创建了一个EvenLoop对象并调用EventLoop::loop。</p>
<p>由于该EventLoopThread类会在一个线程中启动一个EventLoop，所以持有如下变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="n">thread_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>构造函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoopThread</span><span class="o">::</span><span class="n">EventLoopThread</span><span class="p">(</span><span class="k">const</span> <span class="n">ThreadInitCallback</span><span class="o">&amp;</span> <span class="n">cb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">exiting_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">thread_</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EventLoopThread</span><span class="o">::</span><span class="n">threadFunc</span><span class="p">,</span> <span class="k">this</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">mutex_</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="n">cond_</span><span class="p">(</span><span class="n">mutex_</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">callback_</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从构造函数中可以看出，该EventLoop默认是没有初始化的，线程绑定的执行函数是EventLoopThread::threadFunc。除此之外，构造函数中还初始化了互斥锁和条件变量，它们作用会在后面分析。</p>
<p>构造函数中还传入了一个ThreadInitCallback类型的函数对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ThreadInitCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ThreadInitCallback</span> <span class="n">callback_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是用作线程启动初始化执行的用户函数，如果用户想在线程初始化时执行一些函数，那么就可以在EventLoopThread构造函数中传入该函数，默认情况下EventLoopThread会创建一个空函数作为线程初始化函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoopThread</span><span class="p">(</span><span class="k">const</span> <span class="n">ThreadInitCallback</span> <span class="o">&amp;</span><span class="n">cb</span> <span class="o">=</span> <span class="n">ThreadInitCallback</span><span class="p">());</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么，如何启动一个IO线程呢？使用EventLoopThread::startLoop便可以&quot;启动&quot;一个IO线程，这里的&quot;启动&quot;指的是启动IO线程，而不是线程，因为构造函数在已经初始化一个线程了，光启动该线程还不能称为&quot;IO线程&quot;，因为EventLoop还没有初始化，EventLoopThread::startLoop会通过条件变量一直等待，直到EventLoop被初始化，条件满足时才返回该EventLoop地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">EventLoopThread</span><span class="o">::</span><span class="n">startLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">thread_</span><span class="p">.</span><span class="n">started</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">thread_</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MutexLockGuard</span> <span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">loop_</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">cond_</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么EventLoop在哪里初始化，条件变量又如何被通知呢？这些问题都在线程执行函数中完成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoopThread</span><span class="o">::</span><span class="n">threadFunc</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 线程初始化函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">callback_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">callback_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MutexLockGuard</span> <span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// loop_指针指向了一个栈上的对象，threadFunc函数退出之后，这个指针就失效了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// threadFunc函数退出，就意味着线程退出了，EventLoopThread对象也就没有存在的价值了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 因而不会有什么大的问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loop_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cond_</span><span class="p">.</span><span class="n">notify</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// assert(exiting_);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当EventLoopThread类创建后，会在构造函数阶段创建一个线程，而该线程便执行threadFunc函数，如果用户传入了&quot;线程初始化函数&quot;，那么在这里便会优先执行该函数，然后初始化所持有的EventLoop，并发让条件满足(loop_!=NULL)，然后启动EventLoop的事件循环(loop.loop())。</p>
<p>这一过程下来，当一个EventLoopThread 被创建后，该EventLoopThread 对象内部也创建并启动了一个EventLoop对象，用户代码需要startLoop函数来获取该EventLoop对象，然后让该EventLoop中的Poller对象和一些Channel绑定，让Channel中的文件描述符加入事件监听中。所以该EventLoop可以在其他线程里被调用，这就是为什么EventLoop中还提供了runInLoop函数的原因，也为后续的EventLoopThreadPool做出铺垫。</p>
<blockquote>
<p>调用startLoop函数一定会发生在两个线程中，例如：main线程调用startLoop函数，那么startLoop内部会创建一个线程(可以理解为I/O线程)，startLoop函数返回EventLoop对象到调用线程main，该EventLoop对象一定是I/O线程创建的对象。</p>
</blockquote>
<p>最后的析构函数则做了些收尾工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoopThread</span><span class="o">::~</span><span class="n">EventLoopThread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">exiting_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">quit</span><span class="p">();</span> <span class="c1">// 退出IO线程，让IO线程的loop循环退出，从而退出了IO线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">thread_</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面是一个简单的使用案例，可以帮助理解EventLoopThread的使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoopThread.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">runInThread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;runInThread(): pid = %d, tid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">threadInitFC</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;threadInitFC(): pid = %d, tid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">         <span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main(): pid = %d, tid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">EventLoopThread</span> <span class="n">loopThread</span><span class="p">(</span><span class="n">threadInitFC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loopThread</span><span class="p">.</span><span class="n">startLoop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 异步调用runInThread，即将runInThread添加到loop对象所在IO线程，让该IO线程执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">loop</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">runInThread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// runAfter内部也调用了runInLoop，所以这里也是异步调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">loop</span><span class="o">-&gt;</span><span class="n">runAfter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">runInThread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="o">-&gt;</span><span class="n">quit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;exit main().</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="17-eventloopthreadpool">17. EventLoopThreadPool</h2>
<p>该类的作用就是&quot;事先缓存多个EventLoopThread&quot;，所以该类中需要有保存这些EventLoopThread及其EventLoop的数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">ptr_vector</span><span class="o">&lt;</span><span class="n">EventLoopThread</span><span class="o">&gt;</span> <span class="n">threads_</span><span class="p">;</span> <span class="c1">// IO线程列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">EventLoop</span> <span class="o">*&gt;</span> <span class="n">loops_</span><span class="p">;</span>             <span class="c1">// EventLoop列表
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过setThreadNum函数来设置需要创建多少个IO线程(创建后的调整)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setThreadNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">numThreads</span><span class="p">)</span> <span class="p">{</span> <span class="n">numThreads_</span> <span class="o">=</span> <span class="n">numThreads</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果用户传入数量为0(默认构造函数中设置为0)，那么该EventLoopThreadPool就会作为IO线程，EventLoopThreadPool内的baseLoop_持有这个EventLoop对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoopThreadPool</span><span class="o">::</span><span class="n">EventLoopThreadPool</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">baseLoop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">baseLoop_</span><span class="p">(</span><span class="n">baseLoop</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">started_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">numThreads_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">next_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用EventLoopThreadPool::start函数创建numThreads_个EventLoopThread。如果numThreads_为0且有线程初始化函数需要执行，那么就在EventLoopThreadPool所处线程中执行该函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">EventLoopThreadPool</span><span class="o">::</span><span class="n">start</span><span class="p">(</span><span class="k">const</span> <span class="n">ThreadInitCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">started_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">baseLoop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">started_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">EventLoopThread</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EventLoopThread</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">threads_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">loops_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span><span class="o">-&gt;</span><span class="n">startLoop</span><span class="p">());</span> <span class="c1">// 启动EventLoopThread线程，在进入事件循环之前，会调用cb
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">numThreads_</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 只有一个EventLoop，在这个EventLoop进入事件循环之前，调用cb
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cb</span><span class="p">(</span><span class="n">baseLoop_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>考虑到负载均衡，该类还实现了一个基于轮询方法来选择要使用的EventLoop(IO线程)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">EventLoopThreadPool</span><span class="o">::</span><span class="n">getNextLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">baseLoop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">baseLoop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果loops_为空(即numThreads_为0)，则loop指向baseLoop_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果不为空，按照round-robin(RR，轮叫)的调度方式选择一个EventLoop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loops_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// round-robin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loop</span> <span class="o">=</span> <span class="n">loops_</span><span class="p">[</span><span class="n">next_</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">next_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">next_</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">loops_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">next_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="18-网络套接字相关">18. 网络套接字相关</h2>
<h3 id="181-endian">18.1 Endian</h3>
<p>Endian.h头文件封装了字节序转换函数(全局函数，位于muduo::net::sockets名称空间中)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef MUDUO_NET_ENDIAN_H
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MUDUO_NET_ENDIAN_H
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;endian.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">muduo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">net</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">sockets</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// the inline assembler code makes type blur,
</span></span></span><span class="line"><span class="cl"><span class="c1">// so we disable warnings for a while.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#if __GNUC_MINOR__ &gt;= 6
</span></span></span><span class="line"><span class="cl"><span class="cp">#pragma GCC diagnostic push
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#pragma GCC diagnostic ignored &#34;-Wconversion&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp">#pragma GCC diagnostic ignored &#34;-Wold-style-cast&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// posix标准
</span></span></span><span class="line"><span class="cl"><span class="c1">// 主机字节序转换成网络字节序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">hostToNetwork64</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">host64</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">htobe64</span><span class="p">(</span><span class="n">host64</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">hostToNetwork32</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">host32</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">htobe32</span><span class="p">(</span><span class="n">host32</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">uint16_t</span> <span class="nf">hostToNetwork16</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">host16</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">htobe16</span><span class="p">(</span><span class="n">host16</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 网络字节序转换成主机字节序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">networkToHost64</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">net64</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">be64toh</span><span class="p">(</span><span class="n">net64</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">networkToHost32</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">net32</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">be32toh</span><span class="p">(</span><span class="n">net32</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">uint16_t</span> <span class="nf">networkToHost16</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">net16</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">be16toh</span><span class="p">(</span><span class="n">net16</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if __GNUC_MINOR__ &gt;= 6
</span></span></span><span class="line"><span class="cl"><span class="cp">#pragma GCC diagnostic pop
</span></span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp">#pragma GCC diagnostic error &#34;-Wconversion&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp">#pragma GCC diagnostic error &#34;-Wold-style-cast&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace sockets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// namespace net
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// namespace muduo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// MUDUO_NET_ENDIAN_H
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="182-socketsops">18.2 SocketsOps</h3>
<h4 id="1821-补充知识">18.2.1 补充知识</h4>
<p>下面是几个被封装的函数原型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;arpe/inet.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//将点分十进制的ip地址转化为用于网络传输的数值格式 返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">inet_pton</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addrptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">//将数值格式转化为点分十进制的ip地址格式返回值：若成功则为指向结构的指针，若出错则为NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">inet_ntop</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addrptr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>这两个函数的family参数既可以是AF_INET(ipv4)也可以是AF_INET6(ipv6)。如果，以不被支持的地址族作为family参数，这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT.</li>
<li>第一个函数尝试转换由strptr指针所指向的字符串，并通过addrptr指针存放二进制结果，若成功则返回值为1，否则如果所指定的family而言输入字符串不是有效的表达式格式，那么返回值为0.</li>
<li>inet_ntop进行相反的转换，从数值格式(addrptr)转换到表达式(strptr)。inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。如果len太小，不足以容纳表达式结果，那么返回一个空指针，并置为errno为ENOSPC。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include&lt;sys/socket.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">getsockname</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="n">localaddr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span> <span class="c1">//用于获取与某个套接字关联的本地协议地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">getpeername</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="n">peeraddr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span>  <span class="c1">//用于获取与某个套接字关联的外地协议地址
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于这两个函数，如果函数调用成功，则返回0，如果调用出错，则返回-1。使用这两个函数，我们可以通过套接字描述符来获取自己的IP地址和连接对端的IP地址，如在未调用bind函数的TCP客户端程序上，可以通过调用getsockname()函数获取由内核赋予该连接的本地IP地址和本地端口号，还可以在TCP的服务器端accept成功后，通过getpeername()函数来获取当前连接的客户端的IP地址和端口号。</p>
<h4 id="1822-源码分析">18.2.2 源码分析</h4>
<p>该类封装了socket相关系统调用(全局函数，位于muduo::net::sockets名称空间中)。它提供了众多对socket套接字操作的函数，各个函数之间也很少互相调用，基本就是将网络套接字API封装了一遍：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef MUDUO_NET_SOCKETSOPS_H
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MUDUO_NET_SOCKETSOPS_H
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">muduo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">net</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">sockets</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Creates a non-blocking socket file descriptor,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// abort if any error.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 创建一个非阻塞套接字，如果创建失败就终止程序abort
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">createNonblockingOrDie</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bindOrDie</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">listenOrDie</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="nf">readv</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iovcnt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">shutdownWrite</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">toIpPort</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">toIp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">fromIpPort</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">getSocketError</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="nf">getLocalAddr</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="nf">getPeerAddr</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">isSelfConnect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace sockets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// namespace net
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// namespace muduo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// MUDUO_NET_SOCKETSOPS_H
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>接下来分析这些定义的函数源码，首先将sockaddr定义为了SA类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">sockaddr</span> <span class="n">SA</span><span class="p">;</span> <span class="c1">//通用地址
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>下面这两个函数将sockaddr_in类型转换为sockaddr类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 网际地址转换通用地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">SA</span> <span class="o">*</span><span class="nf">sockaddr_cast</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">SA</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">SA</span> <span class="o">*</span><span class="nf">sockaddr_cast</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">SA</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面这个函数设置套接字文件描述符为非阻塞close-on-exec，意思是调用套接字的进程如果创建了子进程，那么子进程将自动关闭这个拷贝的文件描述符，该文件的状态就不会带到子进程中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setNonBlockAndCloseOnExec</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// non-block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="o">::</span><span class="n">fcntl</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">::</span><span class="n">fcntl</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME check
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// close-on-exec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flags</span> <span class="o">=</span> <span class="o">::</span><span class="n">fcntl</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">F_GETFD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">flags</span> <span class="o">|=</span> <span class="n">FD_CLOEXEC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ret</span> <span class="o">=</span> <span class="o">::</span><span class="n">fcntl</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">F_SETFD</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME check
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><a href="https://blog.csdn.net/gettogetto/article/details/52263660"target="_blank" rel="external nofollow noopener noreferrer">浅析open函数O_CLOEXEC模式和fcntl函数FD_CLOEXEC选项</a></p>
</blockquote>
<p>接下来这个函数只是调用了socket函数返回一个文件描述符，同时也做了错误判断：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">sockets</span><span class="o">::</span><span class="n">createNonblockingOrDie</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// socket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#if VALGRIND </span><span class="c1">// 内存泄露检测工具，还能够检测文件描述符的打开状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="o">::</span><span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">sockfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSFATAL</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;sockets::createNonblockingOrDie&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">setNonBlockAndCloseOnExec</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="c1">// Linux 2.6.27以上的内核支持SOCK_NONBLOCK与SOCK_CLOEXEC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="o">::</span><span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span> <span class="o">|</span> <span class="n">SOCK_NONBLOCK</span> <span class="o">|</span> <span class="n">SOCK_CLOEXEC</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">IPPROTO_TCP</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">sockfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSFATAL</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;sockets::createNonblockingOrDie&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面这两个函数分别绑定和监听了一个套接字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">sockets</span><span class="o">::</span><span class="n">bindOrDie</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">sockaddr_cast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">),</span> <span class="k">sizeof</span> <span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSFATAL</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;sockets::bindOrDie&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">sockets</span><span class="o">::</span><span class="n">listenOrDie</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">::</span><span class="n">listen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">SOMAXCONN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSFATAL</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;sockets::listenOrDie&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面这个函数接受一个连接，如果出错则会判断错误类型，如果错误是预期错误(expected errors)，则直接退出，否则写入日志：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">sockets</span><span class="o">::</span><span class="n">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">socklen_t</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if VALGRIND
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="kt">int</span> <span class="n">connfd</span> <span class="o">=</span> <span class="o">::</span><span class="n">accept</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">sockaddr_cast</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">setNonBlockAndCloseOnExec</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="kt">int</span> <span class="n">connfd</span> <span class="o">=</span> <span class="o">::</span><span class="n">accept4</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">sockaddr_cast</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                         <span class="n">SOCK_NONBLOCK</span> <span class="o">|</span> <span class="n">SOCK_CLOEXEC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">connfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 系统调用或者库函数可能会改变errno的值，所以先保存下来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">savedErrno</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Socket::accept&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">savedErrno</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">EAGAIN</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">ECONNABORTED</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">EINTR</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">EPROTO</span><span class="p">:</span> <span class="c1">// ???
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nl">EPERM</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">EMFILE</span><span class="p">:</span> <span class="c1">// per-process lmit of open file desctiptor ???
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// expected errors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">errno</span> <span class="o">=</span> <span class="n">savedErrno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">EBADF</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">EFAULT</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">EINVAL</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">ENFILE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">ENOBUFS</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">ENOMEM</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">ENOTSOCK</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">EOPNOTSUPP</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// unexpected errors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">LOG_FATAL</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;unexpected error of ::accept &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">savedErrno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_FATAL</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;unknown error of ::accept &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">savedErrno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">connfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面这些函数都是对socket相关函数的简单封装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">sockets</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">sockaddr_cast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">),</span> <span class="k">sizeof</span> <span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="n">sockets</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// readv与read不同之处在于，接收的数据可以填充到多个缓冲区中
</span></span></span><span class="line"><span class="cl"><span class="c1">// iov 可以是一个缓冲区数组，第一个缓冲区写满就接着写第二个缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ssize_t</span> <span class="n">sockets</span><span class="o">::</span><span class="n">readv</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iovcnt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">::</span><span class="n">readv</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">iovcnt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="n">sockets</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;sockets::close&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面这个函数关闭传入套接字的写端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 只关闭写的这一半，进入半关闭状态(close SHUT_WR)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">sockets</span><span class="o">::</span><span class="n">shutdownWrite</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">shutdown</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">SHUT_WR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;sockets::shutdownWrite&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来是几个地址转换函数，网络传输地址与本地点分十进制地址转换：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 主要调用toIP函数，将sockaddr_in.sin_addr 转换成ip和端口的形式保存到buf当中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">sockets</span><span class="o">::</span><span class="n">toIpPort</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">host</span><span class="p">[</span><span class="n">INET_ADDRSTRLEN</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;INVALID&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">toIp</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">host</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 网络端口转换成主机字节序端口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">port</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">networkToHost16</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sin_port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&#34;%s:%u&#34;</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 转换ip
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">sockets</span><span class="o">::</span><span class="n">toIp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">INET_ADDRSTRLEN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 转换成点分十进制的形式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">::</span><span class="n">inet_ntop</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">socklen_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 与上面两个函数相反，将点分十进制ip转换为一个sockaddr_in.sin_addr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">sockets</span><span class="o">::</span><span class="n">fromIpPort</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                         <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">hostToNetwork16</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;sockets::fromIpPort&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面这个函数获取错误状况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">sockets</span><span class="o">::</span><span class="n">getSocketError</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">optval</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">socklen_t</span> <span class="n">optlen</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">optval</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">getsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optlen</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">optval</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面这两个函数分别获取本地地址和连接客户端地址信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 本地地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">sockets</span><span class="o">::</span><span class="n">getLocalAddr</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">localaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">localaddr</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">localaddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">socklen_t</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">localaddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">getsockname</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">sockaddr_cast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">localaddr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;sockets::getLocalAddr&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">localaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 对等端地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">sockets</span><span class="o">::</span><span class="n">getPeerAddr</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">peeraddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peeraddr</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">peeraddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">socklen_t</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">peeraddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">getpeername</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">sockaddr_cast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peeraddr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;sockets::getPeerAddr&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">peeraddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后防止自连接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">sockets</span><span class="o">::</span><span class="n">isSelfConnect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">localaddr</span> <span class="o">=</span> <span class="n">getLocalAddr</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">peeraddr</span> <span class="o">=</span> <span class="n">getPeerAddr</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">localaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">==</span> <span class="n">peeraddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">         <span class="n">localaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">==</span> <span class="n">peeraddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>自连接是指(sourceIP, sourcePort) == (destIP, destPort)。</p>
<p>自连接发生的原因:</p>
<ul>
<li>客户端在发起connect的时候，没有bind(2)</li>
<li>客户端与服务器端在同一台机器，即sourceIP = destIP，</li>
<li>服务器尚未开启，即服务器还没有在destPort端口上处于监听</li>
</ul>
<p>这些情况就有可能出现自连接，这样，服务器也无法启动了。</p>
<h3 id="183-inetaddress">18.3 InetAddress</h3>
<p>该类主要提供了一些地址转换的函数(例如从网络字节序到本地字节序)，调用了SocketsOps里的地址函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef MUDUO_NET_INETADDRESS_H
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MUDUO_NET_INETADDRESS_H
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;StringPiece.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;copyable.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">muduo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">net</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Wrapper of sockaddr_in.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This is an POD interface class.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">InetAddress</span> <span class="o">:</span> <span class="k">public</span> <span class="n">muduo</span><span class="o">::</span><span class="n">copyable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// Constructs an endpoint with given port number.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Mostly used in TcpServer listening.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 仅仅指定port，不指定ip，则ip为INADDR_ANY(即0.0.0.0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">explicit</span> <span class="n">InetAddress</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// Constructs an endpoint with given ip and port.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// @c ip should be &#34;1.2.3.4&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">InetAddress</span><span class="p">(</span><span class="k">const</span> <span class="n">StringPiece</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// Constructs an endpoint with given struct @c sockaddr_in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Mostly used when accepting new connections
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">InetAddress</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="o">:</span> <span class="n">addr_</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">string</span> <span class="nf">toIp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">string</span> <span class="nf">toIpPort</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// __attribute__ ((deprecated)) 表示该函数是过时的，被淘汰的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 这样使用该函数，在编译的时候，会发出警告
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">string</span> <span class="nf">toHostPort</span><span class="p">()</span> <span class="k">const</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">deprecated</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="n">toIpPort</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// default copy/assignment are Okay
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">getSockAddrInet</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">addr_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">setSockAddrInet</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span> <span class="n">addr_</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="nf">ipNetEndian</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">addr_</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint16_t</span> <span class="nf">portNetEndian</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">addr_</span><span class="p">.</span><span class="n">sin_port</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">addr_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace net
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// namespace muduo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// MUDUO_NET_INETADDRESS_H
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="184-socket">18.4 Socket</h3>
<p>该类使用了前面两个类中的函数，主要是对socket套接字操作的进一步封装，还包括一些setsockopt的选项操作封装：</p>
<p>首先看Socket类的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef MUDUO_NET_SOCKET_H
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MUDUO_NET_SOCKET_H
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;boost/noncopyable.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">muduo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// TCP networking.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">namespace</span> <span class="n">net</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">InetAddress</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Wrapper of socket file descriptor.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// It closes the sockfd when desctructs.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// It&#39;s thread safe, all operations are delagated to OS.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Socket</span> <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">Socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="o">:</span> <span class="n">sockfd_</span><span class="p">(</span><span class="n">sockfd</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Socket(Socket&amp;&amp;) // move constructor in C++11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">~</span><span class="n">Socket</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">fd</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sockfd_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// abort if address in use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 调用bind绑定服务器IP端口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">bindAddress</span><span class="p">(</span><span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">localaddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// abort if address in use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 调用listen监听套接字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">listen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// On success, returns a non-negative integer that is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// a descriptor for the accepted socket, which has been
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// set to non-blocking and close-on-exec. *peeraddr is assigned.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// On error, -1 is returned, and *peeraddr is untouched.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 调用accept接受新客户连接请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="n">InetAddress</span> <span class="o">*</span><span class="n">peeraddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 调用shutdown关闭服务端写通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">shutdownWrite</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* 下面四个函数都是调用setsockopt来设置一些socket选项 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// Nagle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 算法是频繁发一些小的数据包，会攒在一起发送，合并包发送。一般来说这个延迟时间是200毫秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Enable/disable TCP_NODELAY (disable/enable Nagle&#39;s algorithm).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Nagle算法可以一定程度上避免网络拥塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TCP_NODELAY选项可以禁用Nagle算法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 禁用Nagle算法，可以避免连续发包出现延迟，这对于编写低延迟的网络服务很重要
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">setTcpNoDelay</span><span class="p">(</span><span class="kt">bool</span> <span class="n">on</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Enable/disable SO_REUSEADDR
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">setReuseAddr</span><span class="p">(</span><span class="kt">bool</span> <span class="n">on</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Enable/disable SO_KEEPALIVE
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TCP keepalive是指定期探测连接是否存在，如果应用层有心跳的话，这个选项不是必需要设置的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">setKeepAlive</span><span class="p">(</span><span class="kt">bool</span> <span class="n">on</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">int</span> <span class="n">sockfd_</span><span class="p">;</span> <span class="c1">//服务器监听套接字文件描述符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// namespace net
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// namespace muduo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif </span><span class="c1">// MUDUO_NET_SOCKET_H
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Socket类使用了RAII编程方法，通过构造函数在初始化列表接管资源，在析构函数中释放资源：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">explicit</span> <span class="nf">Socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="o">:</span> <span class="n">sockfd_</span><span class="p">(</span><span class="n">sockfd</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Socket</span><span class="o">::~</span><span class="n">Socket</span><span class="p">()</span> <span class="p">{</span> <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">sockfd_</span><span class="p">);</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下来这几个函数，都是直接调用了SocketsOps中封装的socket操作函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Socket</span><span class="o">::</span><span class="n">bindAddress</span><span class="p">(</span><span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">sockets</span><span class="o">::</span><span class="n">bindOrDie</span><span class="p">(</span><span class="n">sockfd_</span><span class="p">,</span> <span class="n">addr</span><span class="p">.</span><span class="n">getSockAddrInet</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Socket</span><span class="o">::</span><span class="n">listen</span><span class="p">()</span> <span class="p">{</span> <span class="n">sockets</span><span class="o">::</span><span class="n">listenOrDie</span><span class="p">(</span><span class="n">sockfd_</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Socket</span><span class="o">::</span><span class="n">accept</span><span class="p">(</span><span class="n">InetAddress</span> <span class="o">*</span><span class="n">peeraddr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">connfd</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">accept</span><span class="p">(</span><span class="n">sockfd_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">connfd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">peeraddr</span><span class="o">-&gt;</span><span class="n">setSockAddrInet</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">connfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Socket</span><span class="o">::</span><span class="n">shutdownWrite</span><span class="p">()</span> <span class="p">{</span> <span class="n">sockets</span><span class="o">::</span><span class="n">shutdownWrite</span><span class="p">(</span><span class="n">sockfd_</span><span class="p">);</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面这个函数选项禁用Nagle算法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Socket</span><span class="o">::</span><span class="n">setTcpNoDelay</span><span class="p">(</span><span class="kt">bool</span> <span class="n">on</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">optval</span> <span class="o">=</span> <span class="n">on</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd_</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="n">TCP_NODELAY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">optval</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME CHECK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来这个函数设置地址复用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Socket</span><span class="o">::</span><span class="n">setReuseAddr</span><span class="p">(</span><span class="kt">bool</span> <span class="n">on</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">optval</span> <span class="o">=</span> <span class="n">on</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd_</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">optval</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME CHECK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来这个函数设置周期性测试连接是否存活：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Socket</span><span class="o">::</span><span class="n">setKeepAlive</span><span class="p">(</span><span class="kt">bool</span> <span class="n">on</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">optval</span> <span class="o">=</span> <span class="n">on</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd_</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_KEEPALIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">optval</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME CHECK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="19-buffer">19. Buffer</h2>
<p>Buffer类其实是封装了一个用户缓冲区，以及向这个缓冲区写数据读数据等一系列控制方法。</p>
<h3 id="191-设计思想">19.1 设计思想</h3>
<p>这个缓冲区类的实现值得参考和借鉴，以前我们写的只支持一次性全部读出和写入，而这个Buffer类可以读一点，写一点，内部逻辑稳定。这个Buffer类是vector（方便动态扩容），对外表现出std::queue的特性，它的内部原理大概就是下图这样子的，用两个游标（readerIndex_和writerIndex_）标记可读缓冲区的起始位置和空闲空间的起始位置。</p>
<p><img loading="lazy" src="../../imgs/muduo/Buffer_index.jpg" srcset="../../imgs/muduo/Buffer_index.jpg, ../../imgs/muduo/Buffer_index.jpg 1.5x, ../../imgs/muduo/Buffer_index.jpg 2x" sizes="auto" data-title="Buffer游标" data-alt="Buffer游标" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>其中需要关注的就是，随着写入数据和读入数据，蓝色的空闲空间会越来越少，prependable空间会越来越大，当什么时候空用空间耗尽了，就会向步骤4一样，把所有数据拷贝前移，重新调整。另外当整个缓冲区的prependable空间和蓝色的空闲空间都无法装下新来的数据时，那就会调用vector的resize，实现扩容机制。</p>
<h3 id="192-几个重要的成员函数">19.2 几个重要的成员函数</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 将data数据添加到缓冲区中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">append</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 获取缓冲区中长度为len的数据，并以strnig返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="nf">retrieveAsString</span><span class="p">(</span><span class="n">size_t</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 获取缓冲区所有数据，并以string返回。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="nf">retrieveAllAsString</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 确保缓冲区可写空间&gt;=len，如果不足则扩充
</span></span></span><span class="line"><span class="cl"><span class="c1">// 当你打算向缓冲区写入长度为len的数据之前，先调用这个函数，这个函数会检查你的缓冲区可写空间能不能装下长度为len的数据，如果不能，就动态扩容。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">ensureWritableBytes</span><span class="p">(</span><span class="n">size_t</span> <span class="n">len</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面这个方法主要是封装了调用了上面几个方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">/// Read data directly into buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// It may implement with readv(2)
</span></span></span><span class="line"><span class="cl"><span class="c1">/// @return result of read(2), @c errno is saved
</span></span></span><span class="line"><span class="cl"><span class="c1">// 客户端发来数据，readFd从该TCP接收缓冲区中将数据读出来并放到Buffer中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ssize_t</span> <span class="nf">readFd</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">savedErrno</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>值得说明的是，目前写数据通过将Buffer中的数据拷贝到TCP发送缓冲区中，以如下方式处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">(),</span> <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">peek</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                              <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">readableBytes</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">retrieve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="20-acceptor">20. Acceptor</h2>
<p>套接字TCP服务器编程中，服务器需要一个监听套接字，该套接字用于监听客户端连接。</p>
<p>&ldquo;监听套接字&quot;也是一个文件描述符，一个文件描述符在muduo中应该和一个Channel联系。<strong>muduo网络库将专用于监听连接的套接字操作封装成了Acceptor</strong>。所以一个Acceptor中一定会有一个套接字socket和一个Channel，有了Channel一定会关联一个EventLoop：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Socket</span> <span class="n">acceptSocket_</span><span class="p">;</span>   <span class="c1">// listening socket(即server socket)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Channel</span> <span class="n">acceptChannel_</span><span class="p">;</span> <span class="c1">// 用于观察acceptSocket_的readable事件，并回调Accptor::handleRead()
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其构造函数如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Acceptor</span><span class="o">::</span><span class="n">Acceptor</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span> <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">listenAddr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">acceptSocket_</span><span class="p">(</span><span class="n">sockets</span><span class="o">::</span><span class="n">createNonblockingOrDie</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Channel对象都是通过EventLoop对象注册的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">acceptChannel_</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">acceptSocket_</span><span class="p">.</span><span class="n">fd</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">      <span class="n">listenning_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">idleFd_</span><span class="p">(</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;/dev/null&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_CLOEXEC</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">idleFd_</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">acceptSocket_</span><span class="p">.</span><span class="n">setReuseAddr</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span> <span class="c1">// 设置了监听套接字地址复用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">acceptSocket_</span><span class="p">.</span><span class="n">bindAddress</span><span class="p">(</span><span class="n">listenAddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">acceptChannel_</span><span class="p">.</span><span class="n">setReadCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Acceptor</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中idleFd_的作用会在后面介绍。在构造函数中初始化了acceptSocket_，并将该Socket管理的监听套接字和acceptChannel_关联。然后在构造函数中设置了监听套接字地址复用，并绑定了传入参数的监听地址结构，最后设置了acceptChannel_的读事件函数Acceptor::handleRead，当监听套接字上有连接事件时将会出发该回调函数，该回调函数将在后面详细介绍。</p>
<p>在设置完acceptChannel_的回调函数后，即构造函数初始化结束后，acceptChannel_还是没有和EventLoop中的Poller关联，因为一个Channel如果要和Poller关联，那么必须要调用enablexxx函数，enablexxx函数内部又会调用update函数，这样才能达成关联。所以如果要达成这个目的，还需要有该函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Acceptor</span><span class="o">::</span><span class="n">listen</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">listenning_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">acceptSocket_</span><span class="p">.</span><span class="n">listen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">acceptChannel_</span><span class="p">.</span><span class="n">enableReading</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建套接字后还需要设置套接字监听，并和Poller关联，这样一来，如果有客户连接，那么将调用Acceptor::handleRead函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//调用accept(2)来接受新连接，并回调用户callback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Acceptor</span><span class="o">::</span><span class="n">handleRead</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="nf">peerAddr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME loop until no more
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">connfd</span> <span class="o">=</span> <span class="n">acceptSocket_</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peerAddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">connfd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// string hostport = peerAddr.toIpPort();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// LOG_TRACE &lt;&lt; &#34;Accepts of &#34; &lt;&lt; hostport;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">newConnectionCallback_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">newConnectionCallback_</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">peerAddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Read the section named &#34;The special problem of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// accept()ing when you can&#39;t&#34; in libev&#39;s doc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// By Marc Lehmann, author of livev.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//创建的文件描述符太多了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EMFILE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">idleFd_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">//由于我们使用的是电频触发，这个accept会一直触发，所以采用一个空闲的文件描述符，关闭idleFd_，再用来接收这个accept的idleFd_，再关闭idleFd_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">idleFd_</span> <span class="o">=</span> <span class="o">::</span><span class="n">accept</span><span class="p">(</span><span class="n">acceptSocket_</span><span class="p">.</span><span class="n">fd</span><span class="p">(),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">idleFd_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">idleFd_</span> <span class="o">=</span> <span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;/dev/null&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该函数中调用了accetp函数来接收连接，先看连接成功的情况(connfd &gt;= 0)，在该代码分支会将该连接客户端套接字及其地址传入newConnectionCallback_处理，newConnectionCallback_可以通过如下函数来设置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setNewConnectionCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">NewConnectionCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">newConnectionCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以理解，在setNewConnectionCallback中必然会处理客户端连接套接字，至于muduo如何处理，在TcpConnection中会介绍。如果该函数没有设置，也就是默认不处理该连接套接字，那么直接关闭该套接字。</p>
<p>接下来再看看else分支情况。else分支中会判断errno 是否为 EMFILE，如果发生该情况则说明系统文件描述符用尽了，需要处理。由于我们使用的是电频触发，这个accept会一直触发，所以这里利用一个空闲的文件描述符来处理这个问题，它是在Acceptor初始化列表中就创建了。首先关闭idleFd_(空闲文件描述符)，再用来接收这个accept的acceptSocket_，再关闭它，最后再创建一个空闲的描述符。</p>
<p>最后是析构函数，在该函数中将释放监听套接字资源，去除与其相关的Channel及销毁空闲的文件描述符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Acceptor</span><span class="o">::~</span><span class="n">Acceptor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 移除Channel需要保证它处于：kNoneEvent状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">acceptChannel_</span><span class="p">.</span><span class="n">disableAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">acceptChannel_</span><span class="p">.</span><span class="n">remove</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">idleFd_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="21-tcpconnection">21. TcpConnection</h2>
<p>Acceptor代表了监听连接的套接字listenfd，那么TcpConnection 就代表了已连接的客户端套接字connfd。</p>
<h3 id="211-设计思想">21.1 设计思想</h3>
<p><strong>TcpConnection 代表的是客户端连接套接字</strong>，所以TcpConnection 内部一定会管理一个文件描述符，以及该文件描述符对应的Channel，该Channel也需要关联一个EventLoop：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span> <span class="n">socket_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span> <span class="n">channel_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于TcpConnection中的socket_，TcpConnection还使用了两个地址结构来分别保存本机IP地址和对等方IP地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">InetAddress</span> <span class="n">localAddr_</span><span class="p">;</span> <span class="c1">// 保存本机IP地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">InetAddress</span> <span class="n">peerAddr_</span><span class="p">;</span>  <span class="c1">// 对等方IP地址
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用一个状态来标识当前套接字的连接状态(已断开，正在连接(三次握手)，已连接，正在断开(四次挥手)状态)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">StateE</span> <span class="p">{</span> <span class="n">kDisconnected</span><span class="p">,</span> <span class="n">kConnecting</span><span class="p">,</span> <span class="n">kConnected</span><span class="p">,</span> <span class="n">kDisconnecting</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">StateE</span> <span class="n">state_</span><span class="p">;</span>    <span class="c1">// FIXME: use atomic variable
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些变量都在构造函数中被初始化了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">TcpConnection</span><span class="o">::</span><span class="n">TcpConnection</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">nameArg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">localAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">peerAddr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">loop</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">      <span class="n">name_</span><span class="p">(</span><span class="n">nameArg</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">state_</span><span class="p">(</span><span class="n">kConnecting</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">socket_</span><span class="p">(</span><span class="k">new</span> <span class="n">Socket</span><span class="p">(</span><span class="n">sockfd</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">      <span class="n">channel_</span><span class="p">(</span><span class="k">new</span> <span class="n">Channel</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">      <span class="n">localAddr_</span><span class="p">(</span><span class="n">localAddr</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">peerAddr_</span><span class="p">(</span><span class="n">peerAddr</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">highWaterMark_</span><span class="p">(</span><span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setReadCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 通道可写事件到来的时候，回调TcpConnection::handleWrite
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setWriteCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleWrite</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 连接关闭，回调TcpConnection::handleClose
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setCloseCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleClose</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 发生错误，回调TcpConnection::handleError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setErrorCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleError</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_DEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpConnection::ctor[&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;] at &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">this</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="s">&#34; fd=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">socket_</span><span class="o">-&gt;</span><span class="n">setKeepAlive</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>构造函数初始化列表中的name_指的是该TcpConnection的名字，需要传入。highWaterMark_&ldquo;高水位&quot;标识在后面会介绍。</li>
<li>构造函数将state_ 设置为了kConnecting状态，意思是还没有完成连接，当然还有kConnected和kDisconnected两种状态，这在后面会具体介绍。</li>
<li>在构造函数中设置了Channel的读、写、关闭和错误回调函数，这些回调函数的具体内容会在后续介绍。</li>
<li>构造函数中，设置了socket_-&gt;setKeepAlive(true)，设置套接字保持连接(TCP心跳)。</li>
</ul>
<p>构造函数调用之后，该连接套接字还没有让EventLoop中的Poller监听，因为Channel还没有调用enableXXX函数，该函数会在建立连接回调TcpConnection::connectEstablished函数，这在后续会详细介绍。</p>
<p><strong>总之，一个TcpConnection代表了一个连接套接字及其Channel</strong>。</p>
<h3 id="212-tcp-网络编程的本质">21.2 TCP 网络编程的本质</h3>
<p>TCP 网络编程最本质的是处理三个半事件：</p>
<ul>
<li>(1) 连接的建立，包括服务端接受(accept) 新连接和客户端成功发起(connect) 连接。TCP 连接一旦建立，客户端和服务端是平等的，可以各自收发数据。</li>
<li>(2) 连接的断开，包括主动断开(close 或shutdown) 和被动断开(read(2) 返回0)。</li>
<li>(3) 消息到达，文件描述符可读。这是最为重要的一个事件，对它的处理方式决定了网络编程的风格(阻塞还是非阻塞，如何处理分包，应用层的缓冲如何设计等等)。</li>
<li>(3.5) 消息发送完毕，这算半个。对于低流量的服务，可以不必关心这个事件；另外，这里&quot;发送完毕&quot;是指将数据写入操作系统的缓冲区，将由TCP 协议栈负责数据的发送与重传，不代表对方已经收到数据。</li>
</ul>
<p>对于这&quot;三个半事件&rdquo;，在TcpConnection中体现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TcpConnection</span><span class="o">&gt;</span> <span class="n">TcpConnectionPtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ConnectionCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">CloseCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">WriteCompleteCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// the data has been read to (buf, len)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Buffer</span> <span class="o">*</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">)</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MessageCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ConnectionCallback</span> <span class="n">connectionCallback_</span><span class="p">;</span>       <span class="c1">// 连接建立或关闭后的处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">MessageCallback</span> <span class="n">messageCallback_</span><span class="p">;</span>             <span class="c1">// 收到消息后的处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">WriteCompleteCallback</span> <span class="n">writeCompleteCallback_</span><span class="p">;</span> <span class="c1">// 消息发送完后的处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">CloseCallback</span> <span class="n">closeCallback_</span><span class="p">;</span>                 <span class="c1">// 连接关闭后的处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">defaultConnectionCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">defaultMessageCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">,</span> <span class="n">Buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>并提供了如下函数，来供用户自定义这些回调函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setConnectionCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">ConnectionCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">connectionCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setMessageCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">MessageCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">messageCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setWriteCompleteCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">WriteCompleteCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">writeCompleteCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而Muduo库中定义的如下函数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">/// Internal use only.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setCloseCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">CloseCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">closeCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它与TcpServer::removeConnection或TcpClient::removeConnection函数进行绑定。</p>
<p>上面几个函数都是在TcpServer或TcpClient中传递的，所以在后续的TcpServer分析中会具体介绍这些函数。</p>
<h3 id="213-发送和接收缓冲区">21.3 发送和接收缓冲区</h3>
<p>TcpConnection使用Buffer作为发送和接收缓冲区：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Buffer</span> <span class="n">inputBuffer_</span><span class="p">;</span>   <span class="c1">// 应用层接收缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1">// FIXME: use list&lt;Buffer&gt; as output buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Buffer</span> <span class="n">outputBuffer_</span><span class="p">;</span>  <span class="c1">// 应用层发送缓冲区
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="214-连接事件处理">21.4 连接事件处理</h3>
<p>TcpConnection 中有：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">connectEstablished</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnecting</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">setState</span><span class="p">(</span><span class="n">kConnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[3] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">shared_from_this</span><span class="p">().</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// enable_shared_from_this是一个以其派生类为模板类型参数的基类模板，继承它，派生类的this指针就能变成一个shared_ptr。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">tie</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">enableReading</span><span class="p">();</span> <span class="c1">// TcpConnection所对应的通道加入到Poller关注
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">connectionCallback_</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[4] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">shared_from_this</span><span class="p">().</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数不是TcpConnection调用的，是在TcpServer设置调用的，现在只需要了解即可。该函数在建立连接时会被调用，该函数设置连接状态为kConnected(如果之前没有连接)，然后会调用Channel的tie和enableReading函数，让该监听套接字及其Channel和EventLoop的Poller绑定。最后调用connectionCallback_。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/codingmengmeng/p/9123874.html"target="_blank" rel="external nofollow noopener noreferrer">关于boost中enable_shared_from_this类的原理分析</a></p>
</blockquote>
<h3 id="215-读事件处理">21.5 &ldquo;读&quot;事件处理</h3>
<p>在构造函数中做过如下设置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setReadCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>TcpConnection::handleRead定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleRead</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">savedErrno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">inputBuffer_</span><span class="p">.</span><span class="n">readFd</span><span class="p">(</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">savedErrno</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">messageCallback_</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">inputBuffer_</span><span class="p">,</span> <span class="n">receiveTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">handleClose</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">errno</span> <span class="o">=</span> <span class="n">savedErrno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpConnection::handleRead&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">handleError</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>具体读的过程会调用Buffer::readFd函数，该函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 结合栈上的空间，避免内存使用过大，提高内存使用率
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果有5K个连接，每个连接就分配64K+64K的缓冲区的话，将占用640M内存，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 而大多数时候，这些缓冲区的使用率很低
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ssize_t</span> <span class="n">Buffer</span><span class="o">::</span><span class="n">readFd</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">savedErrno</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// saved an ioctl()/FIONREAD call to tell how much to read
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 节省一次ioctl系统调用(获取有多少可读数据)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span> <span class="n">extrabuf</span><span class="p">[</span><span class="mi">65536</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">iovec</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">size_t</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">writableBytes</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第一块缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">writerIndex_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">writable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第二块缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">extrabuf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">extrabuf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">readv</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">savedErrno</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">writable</span><span class="p">)</span> <span class="c1">//第一块缓冲区足够容纳
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">writerIndex_</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="c1">// 当前缓冲区，不够容纳，因而数据被接收到了第二块缓冲区extrabuf，将其append至buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">writerIndex_</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">append</span><span class="p">(</span><span class="n">extrabuf</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">writable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// if (n == writable + sizeof extrabuf)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//   goto line_30;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数利用了readv函数、iovec结构体和Buffer。vec[0]指向的是Buffer的写指针地址，vec[1]指向的是extrabuf的地址。这样做是为了双保险，如果读出的数据比较小，Buffer可以容纳，那么就全部读到Buffer中了，如果读出的数据很多，Buffer不够用了，那么还有65535字节的缓冲区可以接收这些数据，读出来的一些数据就保持在了Buffer中，剩下数据在extrabuf里，所以需要将在extrabuf中的数据再次append到Buffer中，Buffer也会适当扩容，最后所有数据都在Buffer中了。</p>
<p>readFd巧妙的设计，可以让用户一次性把所有TCP接收缓冲区的所有数据全部都读出来并放到用户自定义的缓冲区Buffer中。用户自定义缓冲区Buffer是有大小限制的，我们一开始不知道TCP接收缓冲区中的数据量有多少，如果一次性读出来会不会导致Buffer装不下而溢出？所以在readFd()函数中会在栈上创建一个临时空间extrabuf，然后使用readv的分散读特性，将TCP缓冲区中的数据先拷贝到Buffer中，如果Buffer容量不够，就把剩余的数据都拷贝到extrabuf中，然后再调整Buffer的容量(动态扩容)，再把extrabuf的数据拷贝到Buffer中。当这个函数结束后，extrabuf也会被释放。另外extrabuf是在栈上开辟的空间，速度比在堆上开辟还要快。</p>
<blockquote>
<p><a href="https://blog.csdn.net/KingCat666/article/details/75269373"target="_blank" rel="external nofollow noopener noreferrer">linux ioctl()函数详解</a></p>
</blockquote>
<p>现在回到TcpConnection::handleRead中，如果读取到数据，则调用messageCallback_；如果读取到数据为0，说明客户端已经断开连接，那么调用handleClose()函数来关闭连接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleClose</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; state = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnected</span> <span class="o">||</span> <span class="n">state_</span> <span class="o">==</span> <span class="n">kDisconnecting</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// we don&#39;t close fd, leave it to dtor, so we can find leaks easily.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">setState</span><span class="p">(</span><span class="n">kDisconnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">disableAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">TcpConnectionPtr</span> <span class="nf">guardThis</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">connectionCallback_</span><span class="p">(</span><span class="n">guardThis</span><span class="p">);</span> <span class="c1">// 调用连接建立或关闭后的处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[7] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">guardThis</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// must be the last line
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">closeCallback_</span><span class="p">(</span><span class="n">guardThis</span><span class="p">);</span> <span class="c1">// 调用TcpServer::removeConnection或TcpClient::removeConnection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[11] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">guardThis</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数设置state_为kDisconnected，将连接套接字及其Channel从EventLoop的Poller中解除监听，然后依次调用connectionCallback_和closeCallback_函数。<strong>断开连接也属于connectionCallback_</strong>。(连接到来或者连接关闭都会调用ConnectionCallback回调函数)</p>
<p>如果读取出现错误，那么将调用handleError函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleError</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">getSocketError</span><span class="p">(</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_ERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpConnection::handleError [&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name_</span>
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="s">&#34;] - SO_ERROR = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">strerror_tl</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将错误输出到日志中。</p>
<h3 id="216-发送数据">21.6 发送数据</h3>
<p>在TcpConnection中提供了如下函数发送数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// void send(string&amp;&amp; message); // C++11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">send</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">send</span><span class="p">(</span><span class="k">const</span> <span class="n">StringPiece</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// void send(Buffer&amp;&amp; message); // C++11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">send</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span> <span class="c1">// this one will swap data
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用重载技术编写了三个send函数，这里只介绍参数为Buffer的那个，其余的大体类似：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 线程安全，可以跨线程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">send</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">loop_</span><span class="o">-&gt;</span><span class="n">isInLoopThread</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">sendInLoop</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">peek</span><span class="p">(),</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">readableBytes</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">buf</span><span class="o">-&gt;</span><span class="n">retrieveAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">sendInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">buf</span><span class="o">-&gt;</span><span class="n">retrieveAllAsString</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// std::forward&lt;string&gt;(message)));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">sendInLoop</span><span class="p">(</span><span class="k">const</span> <span class="n">StringPiece</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">sendInLoop</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>无论是在当前EventLoop线程还是跨线程调用，它们都最终调用了TcpConnection::sendInLoop函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">sendInLoop</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">  loop_-&gt;assertInLoopThread();
</span></span></span><span class="line"><span class="cl"><span class="cm">  sockets::write(channel_-&gt;fd(), data, len);
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">ssize_t</span> <span class="n">nwrote</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">error</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kDisconnected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_WARN</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;disconnected, give up writing&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// if no thing in output queue, try writing directly
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 通道没有关注可写事件并且发送缓冲区没有数据，直接write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">isWriting</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">readableBytes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">nwrote</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">(),</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">nwrote</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">remaining</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">nwrote</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 写完了，回调writeCompleteCallback_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">writeCompleteCallback_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">queueInLoop</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">writeCompleteCallback_</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="c1">// nwrote &lt; 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">nwrote</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EWOULDBLOCK</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpConnection::sendInLoop&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EPIPE</span><span class="p">)</span> <span class="c1">// FIXME: any others?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">error</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">remaining</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 没有错误，并且还有未写完的数据(说明内核发送缓冲区满，要将未写完的数据添加到output buffer中)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;I am going to write more data&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">oldLen</span> <span class="o">=</span> <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">readableBytes</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果超过highWaterMark_(高水位标)，回调highWaterMarkCallback_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">oldLen</span> <span class="o">+</span> <span class="n">remaining</span> <span class="o">&gt;=</span> <span class="n">highWaterMark_</span> <span class="o">&amp;&amp;</span> <span class="n">oldLen</span> <span class="o">&lt;</span> <span class="n">highWaterMark_</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">highWaterMarkCallback_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">queueInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">highWaterMarkCallback_</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">oldLen</span> <span class="o">+</span> <span class="n">remaining</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">nwrote</span><span class="p">,</span> <span class="n">remaining</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">isWriting</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">enableWriting</span><span class="p">();</span> <span class="c1">// 关注POLLOUT事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该函数中会调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">isWriting</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">readableBytes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>判断该Channel有没有使能&quot;写&rdquo;。在第一次调用该函数时是没有使能&quot;写&quot;的，前面只是使能了&quot;读&rdquo;，关注读事件。而且会判断Buffer的输出缓冲区内是否有数据，如果是第一次调用了该函数，那么发送缓冲区内肯定是没有有数据的，只不过第一次调用时还没有使能&quot;写&quot;，所以该判断成立，直接调用write函数写入数据，如果数据写入比较少，一次性就发送完了，那么直接调用writeCompleteCallback_，结束该分支。如果一次性没有写完，那么代码会跳转到该分支执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它会继续判断，当前的Buffer缓冲区里的数据长度(oldLen)与需要发送数据长度(remaining)之和是否大于&quot;高水位标志&quot;highWaterMark_，而且Buffer缓冲区内的数据小于highWaterMark_，是否设置了&quot;高水位标志&quot;回调函数highWaterMarkCallback_，如果设置了，那么执行highWaterMarkCallback_函数。然后将发送数据中没有发送的部分拷贝到Buffer中，然后使能&quot;写&quot;。接下来的数据就交给Poller返回后调用TcpConnection::handleWrite函数处理了。</p>
<blockquote>
<p>因为Tcp发送缓冲区是有大小限制的，假如达到了高水位线，就没办法把发送的数据通过send()直接拷贝到Tcp发送缓冲区，而是暂存在这个outputBuffer_中，等TCP发送缓冲区有空间了，触发可写事件了，再把outputBuffer_中的数据拷贝到Tcp发送缓冲区中。</p>
</blockquote>
<h3 id="217-写事件处理">21.7 &ldquo;写&quot;事件处理</h3>
<p>在构造函数中做过如下设置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 通道可写事件到来的时候，回调TcpConnection::handleWrite
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setWriteCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleWrite</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当需要向连接套接字中写入数据时，TcpConnection::handleWrite将被调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 内核发送缓冲区有空间了，回调该函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">handleWrite</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">isWriting</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">(),</span> <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">peek</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                               <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">readableBytes</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">outputBuffer_</span><span class="p">.</span><span class="n">retrieve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">outputBuffer_</span><span class="p">.</span><span class="n">readableBytes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 发送缓冲区已清空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">disableWriting</span><span class="p">();</span> <span class="c1">// 停止关注POLLOUT事件，以免出现busy loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">writeCompleteCallback_</span><span class="p">)</span> <span class="c1">// 回调writeCompleteCallback_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 应用层发送缓冲区被清空，就回调用writeCompleteCallback_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">queueInLoop</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">writeCompleteCallback_</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 发送缓冲区已清空并且连接状态是kDisconnecting，要关闭连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kDisconnecting</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">shutdownInLoop</span><span class="p">();</span> <span class="c1">// 只关闭写的这一半，进入半关闭状态(close SHUT_WR)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;I am going to write more data&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpConnection::handleWrite&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// if (state_ == kDisconnecting)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//   shutdownInLoop();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// }
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Connection fd = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="s">&#34; is down, no more writing&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当客户端套接字变得可写时，调用write往套接字中写入Buffer内容，如果写完了，那么设置Channel，客户端套接字停止&quot;写行为&rdquo;。如果设置了writeCompleteCallback_，则调用writeCompleteCallback_函数。</p>
<blockquote>
<p>当内核发送缓冲区有空间了，回调handleWrite函数，调用write往套接字中写入Buffer内容，如果写完了，那么设置Channel，客户端套接字停止&quot;写行为&quot;。那么已经取消关注了可写的事件，在什么地方又得重新设置再次关注可写事件呢？客户端每次发送数据都是通过send函数，它就在内部调用了enableWriting函数。</p>
</blockquote>
<p>如果当前TcpConnection状态为kDisconnecting，说明没有连接，则调用shutdownInLoop函数，关闭该套接字的写端，但仍然可以读：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">shutdownInLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">channel_</span><span class="o">-&gt;</span><span class="n">isWriting</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// we are not writing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">socket_</span><span class="o">-&gt;</span><span class="n">shutdownWrite</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当调用如下函数后，状态为kDisconnecting：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">shutdown</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME: use compare and swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnected</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">setState</span><span class="p">(</span><span class="n">kDisconnecting</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// FIXME: shared_from_this()?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">shutdownInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用该函数来断开连接。</p>
<h3 id="218-tcpconnection生存期管理">21.8 TcpConnection生存期管理</h3>
<p><img loading="lazy" src="../../imgs/large_concurrency/TcpServer&amp;TcpConnection_close.png" srcset="../../imgs/large_concurrency/TcpServer&amp;TcpConnection_close.png, ../../imgs/large_concurrency/TcpServer&amp;TcpConnection_close.png 1.5x, ../../imgs/large_concurrency/TcpServer&amp;TcpConnection_close.png 2x" sizes="auto" data-title="连接关闭时序图" data-alt="连接关闭时序图" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>第5步，在TcpSever中removeConnection 移除掉TcpConnection, 正常应该在移除后销毁掉TcpConnection，但是不能销毁，如果现在销毁了TcpConnection的Channel对象也就跟着销毁了，而这时调用Channel的handleEvent() 函数，就会出现Core Dump，所以说TcpConnection 的生命期应该长于Channel对象。</p>
<p>当连接到来，创建一个TcpConnection对象，立刻用share_ptr 来管理，引用计数为1，</p>
<p>在Channel中维护一个weak_ptr(tie_)，将这个share_ptr 对象赋值给tie_，引用计数仍为1，</p>
<p>当连接关闭，在handleEvent()，将tie_提升，得到一个share_ptr 对象，引用计数就变成了2。</p>
<p>第6步TcpServer 中erase 后引用计数变为1，第七步queueInLoop 加入bind 引用计数变为2，handleEvent 执行完引用计数减1变为1，bind执行完后引用计数变为0，自动销毁。</p>
<h2 id="22-tcpserver">22. TcpServer</h2>
<p>TcpServer中融合了前面讲过的几乎所有东西，通过TcpServer 提供了三个成员函数来注册三个回调函数，连接成功和断开用了同一个回调函数。</p>
<p><img loading="lazy" src="../../imgs/muduo/TcpServer.png" srcset="../../imgs/muduo/TcpServer.png, ../../imgs/muduo/TcpServer.png 1.5x, ../../imgs/muduo/TcpServer.png 2x" sizes="auto" data-title="TcpServer" data-alt="TcpServer" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h3 id="221-io-线程">22.1 I/O 线程</h3>
<p>TcpServer 正如其名，是一个服务器，而且是一个可以支持多线程Reactor的服务器，所以该服务器必须要有诸多IO线程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>  <span class="c1">// the acceptor loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">EventLoopThreadPool</span><span class="o">&gt;</span> <span class="n">threadPool_</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它们在构造函数中被初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">TcpServer</span><span class="o">::</span><span class="n">TcpServer</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">InetAddress</span><span class="o">&amp;</span> <span class="n">listenAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">nameArg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">loop</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">threadPool_</span><span class="p">(</span><span class="k">new</span> <span class="n">EventLoopThreadPool</span><span class="p">(</span><span class="n">loop</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">nextConnId_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可通过该函数来创建多少个IO线程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpServer</span><span class="o">::</span><span class="n">setThreadNum</span><span class="p">(</span><span class="kt">int</span> <span class="n">numThreads</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">numThreads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">threadPool_</span><span class="o">-&gt;</span><span class="n">setThreadNum</span><span class="p">(</span><span class="n">numThreads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="222-acceptor">22.2 Acceptor</h3>
<p>TcpServer使用Acceptor来操作监听套接字，而且需要一个监听套接字地址和端口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">TcpServer</span><span class="o">::</span><span class="n">TcpServer</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">InetAddress</span><span class="o">&amp;</span> <span class="n">listenAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">nameArg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">loop</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">hostport_</span><span class="p">(</span><span class="n">listenAddr</span><span class="p">.</span><span class="n">toIpPort</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">acceptor_</span><span class="p">(</span><span class="k">new</span> <span class="n">Acceptor</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">listenAddr</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Acceptor::handleRead函数中会回调用TcpServer::newConnection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// _1对应的是socket文件描述符，_2对应的是对等方的地址(InetAddress)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">acceptor_</span><span class="o">-&gt;</span><span class="n">setNewConnectionCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpServer</span><span class="o">::</span><span class="n">newConnection</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时的Acceptor还没有加入事件监听中，也就是没有调用Acceptor::listen()方法。Acceptor需要TcpServer传入一个函数来处理连接事件，因为Acceptor只负责处理连接，所以只关注读事件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">acceptChannel_</span><span class="p">.</span><span class="n">setReadCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Acceptor</span><span class="o">::</span><span class="n">handleRead</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Acceptor</span><span class="o">::</span><span class="n">handleRead</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">connfd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">newConnectionCallback_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">newConnectionCallback_</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">peerAddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而这个函数便是TcpServer::newConnection，该函数在下面详细介绍。</p>
<h3 id="223-启动服务器">22.3 启动服务器</h3>
<p>调用该函数即可启动服务器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 该函数多次调用是无害的
</span></span></span><span class="line"><span class="cl"><span class="c1">// 该函数可以跨线程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">TcpServer</span><span class="o">::</span><span class="n">start</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">started_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">started_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">threadPool_</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">threadInitCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acceptor_</span><span class="o">-&gt;</span><span class="n">listenning</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// get_pointer：返回原生指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Acceptor</span><span class="o">::</span><span class="n">listen</span><span class="p">,</span> <span class="n">get_pointer</span><span class="p">(</span><span class="n">acceptor_</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数首先启动了IO线程池，并传入线程初始化函数，TcpServer中threadInitCallback_定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ThreadInitCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ThreadInitCallback</span> <span class="n">threadInitCallback_</span><span class="p">;</span> <span class="c1">// IO线程池中的线程在进入事件循环前，会回调用此函数
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可通过该函数设置这一回调函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setThreadInitCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">ThreadInitCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">threadInitCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在初始化IO后便启动了Acceptor，Acceptor加入了事件循环。值得一提的是，如果IO线程池设置线程数量为0，那么全局只有一个EventLoop，threadPool_中的EventLoop也是指向TcpServer中的EventLoop。</p>
<h3 id="224-处理客户端连接">22.4 处理客户端连接</h3>
<p>Acceptor 绑定的&quot;读事件&quot;回调函数是newConnection，当有客户端连接时该函数将会被调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpServer</span><span class="o">::</span><span class="n">newConnection</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">peerAddr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 按照轮叫的方式选择一个EventLoop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">EventLoop</span> <span class="o">*</span><span class="n">ioLoop</span> <span class="o">=</span> <span class="n">threadPool_</span><span class="o">-&gt;</span><span class="n">getNextLoop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span> <span class="s">&#34;:%s#%d&#34;</span><span class="p">,</span> <span class="n">hostport_</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">nextConnId_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">++</span><span class="n">nextConnId_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">string</span> <span class="n">connName</span> <span class="o">=</span> <span class="n">name_</span> <span class="o">+</span> <span class="n">buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">LOG_INFO</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpServer::newConnection [&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;] - new connection [&#34;</span>
</span></span><span class="line"><span class="cl">           <span class="o">&lt;&lt;</span> <span class="n">connName</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;] from &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">peerAddr</span><span class="p">.</span><span class="n">toIpPort</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="nf">localAddr</span><span class="p">(</span><span class="n">sockets</span><span class="o">::</span><span class="n">getLocalAddr</span><span class="p">(</span><span class="n">sockfd</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME poll with zero timeout to double confirm the new connection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// FIXME use make_shared if necessary
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/*TcpConnectionPtr conn(new TcpConnection(loop_,
</span></span></span><span class="line"><span class="cl"><span class="cm">                                          connName,
</span></span></span><span class="line"><span class="cl"><span class="cm">                                          sockfd,
</span></span></span><span class="line"><span class="cl"><span class="cm">                                          localAddr,
</span></span></span><span class="line"><span class="cl"><span class="cm">                                          peerAddr));*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">TcpConnectionPtr</span> <span class="nf">conn</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="k">new</span> <span class="n">TcpConnection</span><span class="p">(</span><span class="n">ioLoop</span><span class="p">,</span> <span class="n">connName</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">localAddr</span><span class="p">,</span> <span class="n">peerAddr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[1] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">connections_</span><span class="p">[</span><span class="n">connName</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[2] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setConnectionCallback</span><span class="p">(</span><span class="n">connectionCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setMessageCallback</span><span class="p">(</span><span class="n">messageCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setWriteCompleteCallback</span><span class="p">(</span><span class="n">writeCompleteCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setCloseCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpServer</span><span class="o">::</span><span class="n">removeConnection</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span> <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// conn-&gt;connectEstablished();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ioLoop</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">connectEstablished</span><span class="p">,</span> <span class="n">conn</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[5] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数调用后，TcpServer将从threadPool_轮询方式获取一个EventLoop，让该EventLoop来处理新连接客户端套接字事件。接下来会创建一个TcpConnection，然后将该TcpConnection保存到connections_中，该成员变量定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">TcpConnectionPtr</span><span class="o">&gt;</span> <span class="n">ConnectionMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ConnectionMap</span> <span class="n">connections_</span><span class="p">;</span> <span class="c1">// 连接列表
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再设置该TcpConnection的对应的三个半的回调事件，其中connectionCallback_和messageCallback_在构造函数中设置了默认处理函数，这两个默认函数里没有做任何实事：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ConnectionCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// the data has been read to (buf, len)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Buffer</span> <span class="o">*</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">)</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MessageCallback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ConnectionCallback</span> <span class="n">connectionCallback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">MessageCallback</span> <span class="n">messageCallback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">TcpServer</span><span class="o">::</span><span class="n">TcpServer</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span> <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">listenAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">nameArg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="p">...</span>
</span></span><span class="line"><span class="cl">      <span class="n">connectionCallback_</span><span class="p">(</span><span class="n">defaultConnectionCallback</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">messageCallback_</span><span class="p">(</span><span class="n">defaultMessageCallback</span><span class="p">),</span> <span class="n">started_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以通过如下函数来设置这些回调函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">/// Set connection callback.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Not thread safe.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 设置连接到来或者连接关闭回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setConnectionCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">ConnectionCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">connectionCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// Set message callback.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Not thread safe.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 设置消息到来回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setMessageCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">MessageCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">messageCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// Set write complete callback.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Not thread safe.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setWriteCompleteCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">WriteCompleteCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">writeCompleteCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// Internal use only.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setCloseCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">CloseCallback</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">)</span> <span class="p">{</span> <span class="n">closeCallback_</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是，连接关闭回调函数绑定的是TcpServer::removeConnection：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpServer</span><span class="o">::</span><span class="n">removeConnection</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span><span class="o">&amp;</span> <span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpServer</span><span class="o">::</span><span class="n">removeConnectionInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">conn</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpServer</span><span class="o">::</span><span class="n">removeConnectionInLoop</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_INFO</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpServer::removeConnectionInLoop [&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name_</span>
</span></span><span class="line"><span class="cl">           <span class="o">&lt;&lt;</span> <span class="s">&#34;] - connection &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[8] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">connections_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[9] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="o">*</span><span class="n">ioLoop</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">getLoop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">ioLoop</span><span class="o">-&gt;</span><span class="n">queueInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">connectDestroyed</span><span class="p">,</span> <span class="n">conn</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// loop_-&gt;queueInLoop(
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    boost::bind(&amp;TcpConnection::connectDestroyed, conn));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[10] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">conn</span><span class="p">.</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这一串函数将该TcpConnection从TcpServer的connections_中删除，TcpServer与该TcpConnection没有任何关系了，然后调用TcpConnection::connectDestroyed将该TcpConnection的连接套接字及其Channel与EventLoop及其Poller解除联系，这样一来就彻底除掉该TcpConnection了。</p>
<h3 id="225-释放资源">22.5 释放资源</h3>
<p>将connections_保存的所有TcpConnection全部去除，去除方法和前面TcpServer::removeConnectionInLoop去除单个TcpConnection的方法是一样的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">TcpServer</span><span class="o">::~</span><span class="n">TcpServer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpServer::~TcpServer [&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;] destructing&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">ConnectionMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">(</span><span class="n">connections_</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">       <span class="n">it</span> <span class="o">!=</span> <span class="n">connections_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">TcpConnectionPtr</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">// 释放当前所控制的对象，引用计数减一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">conn</span><span class="o">-&gt;</span><span class="n">getLoop</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpConnection</span><span class="o">::</span><span class="n">connectDestroyed</span><span class="p">,</span> <span class="n">conn</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">conn</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">// 释放当前所控制的对象，引用计数减一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="23-connector">23. Connector</h2>
<p>Connector 是为TcpClient所调用的，一个客户端需要一个套接字来与服务端通信，muduo 使用Connector 来封装这个与服务端通信的套接字(如同Acceptor 封装了监听客户端连接的套接字)。</p>
<h3 id="231-设计思想">23.1 设计思想</h3>
<p>前面说到，该Connector 封装了一个客户端用于连接服务器的套接字，本着muduo中 Every Fd is Channel 的精神，Connector也同样遵循这样的准测：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>                             <span class="c1">// 所属EventLoop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span> <span class="n">channel_</span><span class="p">;</span>          <span class="c1">// Connector所对应的Channel
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是成员变量中却没有套接字，该套接字是在建立连接时才创建的，待创建成功才与channel_绑定：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">connect</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">createNonblockingOrDie</span><span class="p">();</span> <span class="c1">// 创建非阻塞套接字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">serverAddr_</span><span class="p">.</span><span class="n">getSockAddrInet</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而且从构造函数来看，该Channel也没有和EventLoop绑定，至于为什么这样做，在后面会详细介绍。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Connector</span><span class="o">::</span><span class="n">Connector</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span> <span class="k">const</span> <span class="n">InetAddress</span><span class="o">&amp;</span> <span class="n">serverAddr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">serverAddr_</span><span class="p">(</span><span class="n">serverAddr</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">connect_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">state_</span><span class="p">(</span><span class="n">kDisconnected</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">retryDelayMs_</span><span class="p">(</span><span class="n">kInitRetryDelayMs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_DEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ctor[&#34;</span> <span class="o">&lt;&lt;</span> <span class="k">this</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;]&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>构造函数中需要传入一个EventLoop和一个服务端地址结构，至于初始化列表中的后三个变量，在本文后续会详细介绍。</p>
<h3 id="232-连接服务端">23.2 连接服务端</h3>
<p>调用Connector::start函数可启动Connector：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 可以跨线程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">start</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">connect_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Connector</span><span class="o">::</span><span class="n">startInLoop</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span> <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数又进而调用Connector::startInLoop函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">startInLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kDisconnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">connect_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">connect</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_DEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;do not connect&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于一开始构造函数对state_的设置，assert(state_ == kDisconnected)成立。在Connector::start中已经将connect_设置为true，所以直接调用connect()函数，该函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">connect</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">createNonblockingOrDie</span><span class="p">();</span> <span class="c1">// 创建非阻塞套接字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">serverAddr_</span><span class="p">.</span><span class="n">getSockAddrInet</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">savedErrno</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">savedErrno</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EINPROGRESS</span><span class="p">:</span> <span class="c1">// 非阻塞套接字，未连接成功返回码是EINPROGRESS表示正在连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">case</span> <span class="nl">EINTR</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EISCONN</span><span class="p">:</span> <span class="c1">// 连接成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">connecting</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EAGAIN</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EADDRINUSE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EADDRNOTAVAIL</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">ECONNREFUSED</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">ENETUNREACH</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">retry</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span> <span class="c1">// 重连
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EACCES</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EPERM</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EAFNOSUPPORT</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EALREADY</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EBADF</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">EFAULT</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">ENOTSOCK</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;connect error in Connector::startInLoop &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">savedErrno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span> <span class="c1">// 不能重连，关闭sockfd
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_SYSERR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Unexpected error in Connector::startInLoop &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">savedErrno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// connectErrorCallback_();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该函数中会创建一个非阻塞的套接字，并调用sockets::connect函数，如果连接成功则调用connecting函数，如果是连接超时，非阻塞套接字返回，那么调用retry函数，其他情况下都是出现错误，直接关闭该套接字。retry这种情况会在下一节内容中介绍，这部分主要关注connecting函数的调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">connecting</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">setState</span><span class="p">(</span><span class="n">kConnecting</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">channel_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Channel与sockfd关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Channel</span><span class="p">(</span><span class="n">loop_</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置可写回调函数，这时候如果socket没有错误，sockfd就处于可写状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setWriteCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Connector</span><span class="o">::</span><span class="n">handleWrite</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span> <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 设置错误回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">setErrorCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Connector</span><span class="o">::</span><span class="n">handleError</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span> <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// channel_-&gt;tie(shared_from_this()); is not working,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// as channel_ is not managed by shared_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">enableWriting</span><span class="p">();</span> <span class="c1">// 让Poller关注可写事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数将state_设置为kConnecting状态，重置channel_的值，绑定EventLoop和连接成功的套接字sockfd，设置Channel的&quot;写&quot;和&quot;错误&quot;回调函数，并使能&quot;写&quot;，这样一来，Channel及其连接套接字就在EventLoop的Poller中了。</p>
<p>Connector::handleWrite和Connector::handleError两个函数会在下几节介绍。</p>
<h3 id="233-错误处理与重连">23.3 错误处理与重连</h3>
<p>当连接套接字上出现错误时将调用该函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">handleError</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_ERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Connector::handleError&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnecting</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">removeAndResetChannel</span><span class="p">();</span> <span class="c1">// 从poller中移除关注，并将channel置空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">getSocketError</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;SO_ERROR = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">strerror_tl</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">retry</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该函数中会调用removeAndResetChannel函数，removeAndResetChannel会清除该连接套接字Channel和EventLoop的Poller绑定，释放channel_智能指针所管理的内存，并将该连接套接字返回：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Connector</span><span class="o">::</span><span class="n">removeAndResetChannel</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">disableAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">();</span> <span class="c1">// 从poller移除关注
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Can&#39;t reset channel_ here, because we are inside Channel::handleEvent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 不能在这里重置channel_，因为正在调用Channel::handleEvent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">queueInLoop</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Connector</span><span class="o">::</span><span class="n">resetChannel</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span> <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">resetChannel</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">// channel_ 置空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>回到Connector::handleError函数，在清理资源并获取到产生错误的sockfd后，该函数会再调用retry函数尝试连接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 采用back-off策略重连，即重连时间逐渐延长，0.5s, 1s, 2s, ...直至30s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">retry</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">setState</span><span class="p">(</span><span class="n">kDisconnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">connect_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_INFO</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Connector::retry - Retry connecting to &#34;</span>
</span></span><span class="line"><span class="cl">             <span class="o">&lt;&lt;</span> <span class="n">serverAddr_</span><span class="p">.</span><span class="n">toIpPort</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; in &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">retryDelayMs_</span>
</span></span><span class="line"><span class="cl">             <span class="o">&lt;&lt;</span> <span class="s">&#34; milliseconds. &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注册一个定时操作，重连
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">runAfter</span><span class="p">(</span><span class="n">retryDelayMs_</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Connector</span><span class="o">::</span><span class="n">startInLoop</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">    <span class="n">retryDelayMs_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">retryDelayMs_</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kMaxRetryDelayMs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOG_DEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;do not connect&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在介绍retry函数之前需要了解这两个常量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kMaxRetryDelayMs</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// 30秒，最大重连延迟时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kInitRetryDelayMs</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>      <span class="c1">// 0.5秒，初始状态，连接不上，0.5秒后重连
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>kInitRetryDelayMs指的是过500ms便发动一次连接，尝试连接到服务器；kMaxRetryDelayMs指的是尝试超时连接总时间为30*1000ms。在retry函数中调用了runAfter定时函数来尝试连接。</p>
<h3 id="234-处理写事件">23.4 处理&quot;写&quot;事件</h3>
<p>如果socket没有错误，sockfd就处于可写状态，函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">handleWrite</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Connector::handleWrite &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnecting</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">removeAndResetChannel</span><span class="p">();</span> <span class="c1">// 从poller中移除关注，并将channel置空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// socket可写并不意味着连接一定建立成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 还需要用getsockopt(sockfd, SOL_SOCKET, SO_ERROR, ...)再次确认一下。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">sockets</span><span class="o">::</span><span class="n">getSocketError</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="c1">// 有错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_WARN</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Connector::handleWrite - SO_ERROR = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span>
</span></span><span class="line"><span class="cl">               <span class="o">&lt;&lt;</span> <span class="n">strerror_tl</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">retry</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>                           <span class="c1">// 重连
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">sockets</span><span class="o">::</span><span class="n">isSelfConnect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">))</span> <span class="c1">// 自连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LOG_WARN</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Connector::handleWrite - Self connect&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">retry</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span> <span class="c1">// 重连
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span>           <span class="c1">// 连接成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">setState</span><span class="p">(</span><span class="n">kConnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">connect_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">newConnectionCallback_</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span> <span class="c1">// 回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// what happened?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kDisconnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该函数中只是获取到连接成功套接字的文件描述符sockfd，并且将Channel清除，然后调用newConnectionCallback_函数，该函数在TcpClient中传入。为什么要将该连接Channel移除是有原因的，客户端连接套接字只有一个，而Connector中已经将该套接字与自己的Channel绑定了，只是负责连接而已，connect函数调用成功该套接字则变得可写，这时的Connector已经完成任务了，需要将该套接字的所有权转让给TcpClient，所以调用了newConnectionCallback_函数，而该函数在TcpClient中给该套接字绑定了一个新的Channel，该Channel和Connector中的Channel同属于一个EventLoop，所以转移所有权需要彻底，Connector中的Channel必须要被移除，否则将导致&quot;串台&quot;。</p>
<h3 id="235-重置连接">23.5 重置连接</h3>
<p>&ldquo;断线重连&quot;和&quot;重置连接&quot;是两个概念，&ldquo;断线重连&quot;指的是在已经连接成功的情况下又断开连接，再多次尝试连接；&ldquo;重置连接&quot;指的是放弃之前的连接，从零开始连接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 不能跨线程调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Connector</span><span class="o">::</span><span class="n">restart</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">setState</span><span class="p">(</span><span class="n">kDisconnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">retryDelayMs_</span> <span class="o">=</span> <span class="n">kInitRetryDelayMs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">connect_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">startInLoop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="24-tcpclient">24. TcpClient</h2>
<p>在Connector中说到&quot;在该函数中只是获取到连接成功套接字的文件描述符sockfd，并且将Channel清除，然后调用newConnectionCallback_函数，该函数在TcpClient中传入&rdquo;，Connector::handleWrite函数是被TcpClient调用的，那么我们先一窥newConnectionCallback_函数究竟。</p>
<p>在此之前，先看看TcpClient中的Connector：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Connector</span><span class="o">&gt;</span> <span class="n">ConnectorPtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ConnectorPtr</span> <span class="n">connector_</span><span class="p">;</span>                      <span class="c1">// 用于主动发起连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">TcpClient</span><span class="o">::</span><span class="n">TcpClient</span><span class="p">(</span><span class="n">EventLoop</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">InetAddress</span><span class="o">&amp;</span> <span class="n">serverAddr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">loop</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">connector_</span><span class="p">(</span><span class="k">new</span> <span class="n">Connector</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">serverAddr</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">    <span class="n">name_</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置连接成功回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">connector_</span><span class="o">-&gt;</span><span class="n">setNewConnectionCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpClient</span><span class="o">::</span><span class="n">newConnection</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME setConnectFailedCallback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LOG_INFO</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;TcpClient::TcpClient[&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name_</span>
</span></span><span class="line"><span class="cl">           <span class="o">&lt;&lt;</span> <span class="s">&#34;] - connector &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">get_pointer</span><span class="p">(</span><span class="n">connector_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在构造函数中，Connector被设置了新连接回调函数TcpClient::newConnection，也就是前面的newConnectionCallback_，该函数定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpClient</span><span class="o">::</span><span class="n">newConnection</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="nf">peerAddr</span><span class="p">(</span><span class="n">sockets</span><span class="o">::</span><span class="n">getPeerAddr</span><span class="p">(</span><span class="n">sockfd</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span> <span class="s">&#34;:%s#%d&#34;</span><span class="p">,</span> <span class="n">peerAddr</span><span class="p">.</span><span class="n">toIpPort</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">nextConnId_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">++</span><span class="n">nextConnId_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">string</span> <span class="n">connName</span> <span class="o">=</span> <span class="n">name_</span> <span class="o">+</span> <span class="n">buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="nf">localAddr</span><span class="p">(</span><span class="n">sockets</span><span class="o">::</span><span class="n">getLocalAddr</span><span class="p">(</span><span class="n">sockfd</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// FIXME poll with zero timeout to double confirm the new connection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// FIXME use make_shared if necessary
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">TcpConnectionPtr</span> <span class="nf">conn</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="k">new</span> <span class="n">TcpConnection</span><span class="p">(</span><span class="n">loop_</span><span class="p">,</span> <span class="n">connName</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">localAddr</span><span class="p">,</span> <span class="n">peerAddr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setConnectionCallback</span><span class="p">(</span><span class="n">connectionCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setMessageCallback</span><span class="p">(</span><span class="n">messageCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setWriteCompleteCallback</span><span class="p">(</span><span class="n">writeCompleteCallback_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setCloseCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TcpClient</span><span class="o">::</span><span class="n">removeConnection</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span> <span class="c1">// FIXME: unsafe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MutexLockGuard</span> <span class="nf">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">connection_</span> <span class="o">=</span> <span class="n">conn</span><span class="p">;</span> <span class="c1">// 保存TcpConnection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">connectEstablished</span><span class="p">();</span> <span class="c1">// 这里回调connectionCallback_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数将连接成功的socfd封装为一个TcpConnection，并设置&quot;三个半&quot;回调事件函数。好的，到了这里就解释了前面Connector为什么不自己持有一个sockfd、为什么要在连接成功时清空Channel等诸多问题。拿到连接成功套接字后，创建TcpConnection与服务器进行数据交换。</p>
<h2 id="25-tcp网络编程本质">25 TCP网络编程本质</h2>
<p>TCP网络编程最本质是的处理三个半事件：</p>
<ul>
<li>连接建立：服务器accept(被动)接受连接，客户端connect(主动)发起连接</li>
<li>连接断开：主动断开(close、shutdown)，被动断开(read返回0)</li>
<li>消息到达：文件描述符可读</li>
<li>消息发送完毕：这算半个。对于低流量的服务，可不必关心这个事件;这里的发送完毕是指数据写入操作系统缓冲区，将由TCP协议栈负责数据的发送与重传，不代表对方已经接收到数据。</li>
</ul>
<p>一个套接字有两个缓冲区，一个接收缓冲区一个发送缓冲区，当一个套接字到来的时候先被内核缓冲区接收。</p>
<p><img loading="lazy" src="../../imgs/muduo/buf.png" srcset="../../imgs/muduo/buf.png, ../../imgs/muduo/buf.png 1.5x, ../../imgs/muduo/buf.png 2x" sizes="auto" data-title="缓冲区" data-alt="缓冲区" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>当网络库事件循环中的可读事件触发，会将数据从内核缓冲区移动到应用缓冲区中。并且网络库会回调函数，如：OnMessage。由于TCP接收到的数据可能是宕包，OnMessage这个函数会根据协议判断这个数据包是否是完整的数据包，如果不是完整的数据OnMessage立刻返回，直到内核当中又有数据接收，进行下一次循环操作；如果读到完整的数据，将进行常规处理(read-&gt;decode-&gt;compute-&gt;encode-&gt;write-&gt;进行下一次事件循环)。</p>
<p>调用write(buf,..)函数：如果数据全部填充到了内核缓冲区，网络库回调一个函数，如：OnWriteComplete函数。如果内核缓冲区的不足以容纳buf数据，就会将buf部分的数据放入进来，不足以容纳的数据存放到应用层的发送缓冲区当中。内核的发送缓冲区的数据发送完成后会触发可写事件，继续下一次的事件循环。</p>
<h3 id="251-连接建立">25.1 连接建立</h3>
<p><img loading="lazy" src="../../imgs/muduo/Connection.jpg" srcset="../../imgs/muduo/Connection.jpg, ../../imgs/muduo/Connection.jpg 1.5x, ../../imgs/muduo/Connection.jpg 2x" sizes="auto" data-title="连接建立的代码逻辑" data-alt="连接建立的代码逻辑" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<ol>
<li>当我们创建一个TcpServer对象，构造函数将实例化了一个Acceptor对象，并往这个Acceptor对象注册了一个回调函数TcpServer::newConnection()。</li>
<li>Acceptor的构造函数会实例化一个Channel对象，即acceptChannel_，该Channel对象封装了服务器监听套接字文件描述符（尚未注册到main EventLoop的事件监听器上）。</li>
<li>接着Acceptor构造函数将Acceptor::handleRead()方法注册进acceptChannel_中，这也意味着，以后如果事件监听器监听到acceptChannel_发生可读事件，将会调用Acceptor::handleRead()函数。</li>
<li>至此，TcpServer对象创建完毕，用户调用TcpServer::start()方法，启动TcpServer。</li>
<li>cpServer::start()方法主要是调用Acceptor::listen()函数（底层是调用了linux的函数listen()）监听服务器套接字，以及将acceptChannel_注册到main EventLoop的事件监听器上监听它的可读事件（新用户连接事件）。</li>
<li>接着用户调用loop.loop()，即调用了EventLoop::loop()函数，该函数就会循环的获取事件监听器的监听结果，并且根据监听结果调用注册在事件监听器上的Channel对象的事件处理函数。</li>
<li>当回调Acceptor::handleRead()函数，说明acceptChannel_发生可读事件，程序处理新客户连接请求。该函数首先调用了Linux的函数accept()接受新客户连接。接着调用了TcpServer::newConnection()函数，这个函数是TcpServer注册给Acceptor，并由TcpServer成员变量newConnectionCallback_保存。</li>
<li>TcpServer::newConnection()函数的主要功能就是将建立好的连接进行封装（封装成TcpConnection对象），并使用轮询的方式选择一个sub EventLoop，并调用TcpConnection::connectEstablished()将TcpConnection::channel_注册到刚刚选择的sub EventLoop上。</li>
</ol>
<h3 id="252-消息到达">25.2 消息到达</h3>
<p><img loading="lazy" src="../../imgs/muduo/TcpConnection.jpg" srcset="../../imgs/muduo/TcpConnection.jpg, ../../imgs/muduo/TcpConnection.jpg 1.5x, ../../imgs/muduo/TcpConnection.jpg 2x" sizes="auto" data-title="TcpConnection对象" data-alt="TcpConnection对象" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>在main EventLoop中接受新连接请求之后，将这条Tcp连接封装成TcpConnection对象。其主要封装了连接套接字的fd(socket_)、连接套接字的channel_等。在TcpConnection的构造函数中会将TcpConnection::handleRead()、TcpConnection::handleWrite()、TcpConnection::handleClose()、TcpConnection::handleError()这个四个方法注册进这个channel_内。当TcpConnection对象建立完毕之后，main EventLoop的Acceptor会将这个TcpConnection对象中的channel_注册到某一个SubEventLoop中。</p>
<p><img loading="lazy" src="../../imgs/muduo/Message.jpg" srcset="../../imgs/muduo/Message.jpg, ../../imgs/muduo/Message.jpg 1.5x, ../../imgs/muduo/Message.jpg 2x" sizes="auto" data-title="消息读取逻辑" data-alt="消息读取逻辑" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>如上图所示，SubEventLoop中的EventLoop::loop()函数内部会循环的执行上图中的步骤1和步骤2。</p>
<ul>
<li>步骤1就是调用Poller::poll()方法获取事件监听结果，这个事件监听结果是一个Channel集合，每一个Channel封装着一个fd及fd感兴趣的事件和事件监听器监听到该fd实际发生的事件。</li>
<li>步骤2就是调用每一个Channel的Channel::HandlerEvent方法。该方法会根据每一个Channel的感兴趣事件以及实际发生的事件调用提前注册在Channel内的对应的事件处理函数（readCallback_、writeCallback_、closeCallback_、errorCallback_)。readCallback_保存的函数其实是TcpConnection::handleRead()，消息读取的处理逻辑也就是由这个函数提供的。</li>
</ul>
<p>TcpConnection::handleRead()函数首先调用Buffer_.readFd(channel_-&gt;fd(), &amp;saveErrno)，该函数底层调用Linux的函数readv()，将Tcp接收缓冲区数据拷贝到用户定义的缓冲区中（inputBuffer_）。如果在读取拷贝的过程中发生了什么错误，这个错误信息就会保存在savedErrno中。</p>
<ul>
<li>当readFd()返回值大于0，说明从接收缓冲区中读取到了数据，那么会接着调用messageCallback_中保存的用户自定义的读取消息后的处理函数。</li>
<li>当readFd()返回值等于0，说明客户端连接关闭，这时候应该调用TcpConnection::handleClose()来处理连接关闭事件。</li>
<li>当readFd()返回值等于-1，说明发生了错误，调用TcpConnection::handleError()来处理savedErrno的错误事件。</li>
</ul>
<p>Moduo库只支持LT模式，所以读事件不会出现EAGAIN的错误，所以一旦出现错误，说明肯定是比较不好的非正常错误了。而EAGAIN错误只不过是非阻塞IO调用时的一种常见错误而已。</p>
<h3 id="253-消息发送完毕">25.3 消息发送完毕</h3>
<p>当用户调用了TcpConnetion::send(buf)函数时，相当于要求muduo库把数据buf发送给该Tcp连接的客户端。此时该TcpConnection注册在事件监听器上的感兴趣事件中是没有可写事件的。TcpConnection::send(buf)函数内部，对持有的Channel设置&quot;写行为&rdquo;，当内核发送缓冲区有空间了，回调TcpConnection::handleWrite()，其内部就会调用了Linux的函数write()。如果TCP发送缓冲区能一次性容纳buf，那这个write()函数将buf全部拷贝到发送缓冲区中，就停止&quot;写行为&rdquo;，否则等到下一次事件循环再次回调TcpConnection::handleWrite()函数，直至清空发送缓冲区。</p>
<h3 id="254-连接断开">25.4 连接断开</h3>
<p>连接断开分为：主动断开(close、shutdown)和被动断开(read返回0)。</p>
<h4 id="2541-被动断开">25.4.1 被动断开</h4>
<p>服务端TcpConnection::handleRead()中read返回0感知到客户端把连接断开了。TcpConnection::handleRead()函数内部调用了Linux的函数readv()，当readv()返回0的时候，服务端就知道客户端断开连接了。然后就接着调用TcpConnection::handleClose()。</p>
<p><img loading="lazy" src="../../imgs/muduo/passive_disconnect.jpg" srcset="../../imgs/muduo/passive_disconnect.jpg, ../../imgs/muduo/passive_disconnect.jpg 1.5x, ../../imgs/muduo/passive_disconnect.jpg 2x" sizes="auto" data-title="被动断开" data-alt="被动断开" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<ol>
<li>在执行TcpConnection::handleClose()的时候，该函数还是在sub EventLoop线程中运行的，接着调用closeCallback_(const TcpConnectionPtr &amp;connPtr)回调函数，该函数保存的其实是TcpServer::removeConnection()函数。</li>
<li>TcpServer::removeConnection()函数调用了removeConnectionInLoop()函数，该函数的运行是在main EventLoop线程中执行的。</li>
<li>removeConnectionInLoop()函数：TcpServer对象中有一个connections_成员变量，这是一个unordered_map，负责保存string &ndash;&gt; TcpConnection的映射，其实就是保存着Tcp连接的名字到TcpConnection对象的映射。因为这个Tcp连接要关闭了，所以也要把这个TcpConnection对象从connections_中删掉。然后再调用TcpConnection::connectDestroyed函数。</li>
</ol>
<blockquote>
<p>为什么removeConnectionInLoop()要在main EventLoop中运行，因为该函数需要从TcpServer对象中删除某条数据。而TcpServer对象是属于main EventLoop的。这也是贯彻了One Loop Per Thread的理念。</p>
</blockquote>
<ol start="4">
<li>TcpConnection::connectDestroyed()函数的执行是又跳回到了sub EventLoop线程中。该函数就是将Tcp连接的监听描述符从事件监听器中移除。另外sub EventLoop中的Poller类对象还保存着这条Tcp连接的channel_，所以调用channel_.remove()将这个Tcp连接的channel对象从Poller内的数据结构中删除。</li>
</ol>
<h4 id="2542-主动断开">25.4.2 主动断开</h4>
<p>当服务器主动关闭时，调用TcpServer::~TcpServer()析构函数。</p>
<p>在创建TcpConnection对象时，Acceptor都要将这个对象分发给一个sub EventLoop来管理。这个TcpConnection对象的一切函数执行都要在其管理的sub EventLoop线程中运行。再一次贯彻One Loop Per Thread的设计模式。比如要想彻底删除一个TcpConnection对象，就必须要调用这个对象的connecDestroyed()方法，<strong>这个方法执行完后才能释放这个对象的堆内存</strong>。每个TcpConnection对象的connectDestroyed()方法都必须在这个TcpConnection对象所属的SubEventLoop绑定的线程中执行。</p>
<p><img loading="lazy" src="../../imgs/muduo/Destruction_TcpConnection.jpg" srcset="../../imgs/muduo/Destruction_TcpConnection.jpg, ../../imgs/muduo/Destruction_TcpConnection.jpg 1.5x, ../../imgs/muduo/Destruction_TcpConnection.jpg 2x" sizes="auto" data-title="析构TcpConnection" data-alt="析构TcpConnection" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>不断循环的让这个TcpConnection对象所属的SubEventLoop线程执行TcpConnection::connectDestroyed()函数，同时在MainEventLoop的TcpServer::~TcpServer()函数中调用item.second.reset()释放保管TcpConnection对象的共享智能指针，以达到释放TcpConnection对象的堆内存空间的目的。</p>
<p>TcpConnection::connectDestroyed()函数的执行以及这个TcpConnection对象的堆内存释放操作不在同一个线程中运行，所以要考虑怎么保证一个TcpConnectino对象的堆内存释放操作是在TcpConnection::connectDestroyed()调用完后。这个析构函数巧妙利用了共享智能指针的特点，当没有共享智能指针指向这个TcpConnection对象时（引用计数为0），这个TcpConnection对象就会被析构删除（堆内存释放）。</p>
<p>TcpServer::~TcpServer()中的代码逻辑：</p>
<ol>
<li>首先TcpServer::connections_是一个unordered_map&lt;string, TcpConnectionPtr&gt;，其中TcpConnectionPtr的含义是指向TcpConnection的shared_ptr。</li>
<li>在一开始，每一个TcpConnection对象都被一个共享智能指针TcpConnetionPtr持有，当执行了TcpConnectionPtr conn = it-&gt;second;时，这个TcpConnetion对象就被conn和这个item.second共同持有，但是这个conn的生存周期很短，只要离开了当前的这一次for循环，conn就会被释放。</li>
<li>紧接着调用it-&gt;second.reset()释放掉TcpServer中保存的该TcpConnectino对象的智能指针。此时在当前情况下，只剩下conn还持有这个TcpConnection对象，因此当前TcpConnection对象还不会被析构。</li>
<li>接着调用了conn-&gt;getLoop()-&gt;runInLoop(bind(&amp;TcpConnection::connectDestroyed, conn));，是让sub EventLoop线程去执行TcpConnection::connectDestroyed()函数。当你把这个conn的成员函数传进去的时候，conn所指向的资源的引用计数会加1。因为传给runInLoop的不只有函数，还有这个函数所属的对象conn。</li>
<li>sub EventLoop线程开始运行TcpConnection::connectDestroyed()</li>
<li>main EventLoop线程当前这一轮for循环跑完，共享智能指针conn离开代码块，因此被析构，但是TcpConnection对象还不会被释放，因为还有一个共享智能指针指向这个TcpConnection对象，而且这个智能指针在TcpConnection::connectDestroyed()中，只不过这个智能指针你看不到，它在这个函数中是一个隐式的this的存在。当这个函数执行完后，智能指针就真的被释放了。到此，就没有任何智能指针指向这个TcpConnection对象了。TcpConnection对象就彻底被析构删除了。</li>
</ol>
<p>如果TcpConnection中有正在发送的数据，怎么保证在触发TcpConnection关闭机制后，能先让TcpConnection先把数据发送完再释放TcpConnection对象的资源？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">TcpConnection</span><span class="o">::</span><span class="n">connectEstablished</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop_</span><span class="o">-&gt;</span><span class="n">assertInLoopThread</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">state_</span> <span class="o">==</span> <span class="n">kConnecting</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">setState</span><span class="p">(</span><span class="n">kConnected</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[3] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">shared_from_this</span><span class="p">().</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// enable_shared_from_this是一个以其派生类为模板类型参数的基类模板，继承它，派生类的this指针就能变成一个shared_ptr。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">tie</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel_</span><span class="o">-&gt;</span><span class="n">enableReading</span><span class="p">();</span> <span class="c1">// TcpConnection所对应的通道加入到Poller关注
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">connectionCallback_</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">LOG_TRACE</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[4] usecount=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">shared_from_this</span><span class="p">().</span><span class="n">use_count</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>TcpConnection类继承了一个类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TcpConnection</span> <span class="o">:</span><span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">TcpConnection</span><span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们在TcpConnection对象中的成员函数中调用了shared_from_this()，该函数可以返回一个shared_ptr，并且这个shared_ptr指向的对象是TcpConnection本身。
接着这个shared_ptr就作为channel_的Channel::tie()函数的函数参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//Channel.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">tie_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Channel</span><span class="o">::</span><span class="n">handleEvent</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">tied_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">guard</span> <span class="o">=</span> <span class="n">tie_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// 确定shared_ptr指针还存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">guard</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">handleEventWithGuard</span><span class="p">(</span><span class="n">receiveTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">handleEventWithGuard</span><span class="p">(</span><span class="n">receiveTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当事件监听器返回监听结果，就要对每一个发生事件的Channel对象调用它们的handleEvent()函数。在这个handleEvent函数中，会先把tie_这个weak_ptr提升为强共享智能指针。这个强共享智能指针会指向当前的TcpConnection对象。就算你外面调用删除析构了其他所有的指向该TcpConnection对象的智能指针。你只要handleEventWithGuard()函数没执行完，你这个TcpConnetion对象都不会被析构释放堆内存。而handleEventWithGuard()函数里面就有负责处理消息发送事件的逻辑。当handleEventWithGuard()函数调用完毕，这个guard智能指针就会被释放。</p>
<h2 id="26-阶段性总结">26. 阶段性总结</h2>
<p><code>multiple reactors + threadpool (one loop per thread + threadpool)</code>：Reactor 最核心的事件就是事件分发机制，即将IO multiplexing 拿到的IO事件分发给各个文件描述符(fd)的事件处理函数(handle)。</p>
<p>EventLoop起到一个驱动循环的功能，Poller负责从事件监听器上获取监听结果。而Channel类则在其中起到了将fd及其相关属性封装的作用，将fd及其感兴趣事件和发生的事件以及不同事件对应的回调函数封装在一起，这样在各个模块中传递更加方便。</p>
<p><img loading="lazy" src="../../imgs/muduo/Multi-Reactor.jpg" srcset="../../imgs/muduo/Multi-Reactor.jpg, ../../imgs/muduo/Multi-Reactor.jpg 1.5x, ../../imgs/muduo/Multi-Reactor.jpg 2x" sizes="auto" data-title="Muduo" data-alt="Muduo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>Muduo库是基于Reactor模式实现的TCP网络编程库。Multi-Reactor模型如下所示：</p>
<p><img loading="lazy" src="../../imgs/muduo/Multi-Reactor.png" srcset="../../imgs/muduo/Multi-Reactor.png, ../../imgs/muduo/Multi-Reactor.png 1.5x, ../../imgs/muduo/Multi-Reactor.png 2x" sizes="auto" data-title="Muduo" data-alt="Muduo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>一张图总结服务/客户端调用关系：</p>
<p><img loading="lazy" src="../../imgs/muduo/muduo.jpg" srcset="../../imgs/muduo/muduo.jpg, ../../imgs/muduo/muduo.jpg 1.5x, ../../imgs/muduo/muduo.jpg 2x" sizes="auto" data-title="Muduo" data-alt="Muduo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<blockquote>
<p>白色部分是外部类，对外可见的。灰色部分是内部类，对外不可见。黑色尖头是组合关系，负责生命周期。白色是聚合关系不负责生命周期。</p>
</blockquote>
<ul>
<li>EventLoop是对事件的抽象。一个EventLoop的Poller对象包含多个Channel，也就是说可以扑捉多个Channel的多个可读、可写事件。</li>
<li>Poller 是对IO 复用的抽象，有两个派生类：PollPoller 对poll 的封装，EPollPoller对epoll的封装。这个地方是muduo 唯一使用面向对象封装的。</li>
<li>Channel 是对IO事件的注册和响应的封装。Channel 的Update成员函数负责注册和更新IO的可读可写等事件。Channel 的handleEvent()成员函数是对所发生的IO事件进行处理。</li>
<li>Channel是selectable IO channel，负责注册与响应IO 事件，它不拥有file descriptor。</li>
<li>Channel是Acceptor、Connector、EventLoop、TimerQueue、TcpConnection的成员，生命期由后者控制。EventLoop 有一个特殊的Channel 用来唤醒loop实现跨线程调用，这个特殊的Channel的生命期由EventLoop负责。</li>
<li>TcpConnection负责一个客户端连接成功套接字，一旦被动连接(Acceptor)或主动连接(Connector)建立，就会得到一个已连接的套接字。</li>
<li>Acceptor负责一个服务器listen套接字，Accept被动连接，连接成功后都会创建一个TcpConnection对象。</li>
<li>Connector负责一个客户端connect套接字，Connector主动连接，连接成功后会创建一个TcpConnection对象。</li>
<li>TcpServer中持有Acceptor，通过Acceptor获取新的连接套接字，然后TcpServer会为该连接套接字建立一个TcpConnection，然后往该TcpConnection中传递用户需要TcpServer相应事件对应的函数，用户传入的函数其实是和TcpConnection中的Channel间接绑定，然后在事件触发后被Channel间接执行。</li>
<li>TcpClient中持有Connector，通过Connector里的Channel绑定一个连接套接字，在连接成功后，Connector会将该套接字转让给TcpClient，TcpClient中会为该连接套接字建立一个TcpConnection，然后往该TcpConnection中传递用户需要TcpClient相应事件对应的函数，用户传入的函数其实是和TcpConnection中的Channel间接绑定，然后在事件触发后被Channel间接执行。</li>
</ul>
<p>  EventLoop与Poller的关系是组合，一个EventLoop包含一个Poller，并且Poller的生命周期由EventLoop控制，EventLoop::loop()函数实际是通过Poller::poll()函数来实现的。</p>
<p>  Channel是对I/O事件的注册与响应的封装，Channel::update()函数负责注册或更新I/O的可读和可写事件，同时会调用到EventLoop::updateChannel()函数，这个函数又会调用Poller::updateChannel()函数，相当于将这个Channle这个对象注册到Poller对象中，或者说将Channel对象中的fd(文件描述符)的可读、可写事件注册到Poller对象中；Channel::handleEvent()函数负责对所发生的I/O事件进行处理。一个EventLoop对象包含多个Channel对象，也就是说EventLoop可捕获多个Channel(通道)的可读、可写事件。一对多，且是聚合的关系。也就是说EventLoop不负责Channel的生命周期。Channel的生命周期由TcpConnection、Acceptor、Connector等等这些类来控制。Channel对象不拥有fd(文件描述符)，也就是说当Channel对象销毁的时候不关闭文件描述符。Channel对象和文件描述符是关联关系，一个Chanel有一个fd，一个EventLoop有多个fd，而这个fd是被套接字(Socket)所拥有的。也就是说fd的生命周期由套接字来控制，当套接字对象销毁时，文件描述符对象就会销毁(Socket::close)。</p>
<p>  Chanel对象又是TcpConnection、Acceptor、Connector类的成员，它们与Channel对象之间也是组合关系，Channel的生命周期由它们来控制。</p>
<p>  Acceptor是对被动连接的抽象，它关心的是监听事件的可读事件，监听事件的可读事件是由Channel来注册，触发事件调用Channel::handleEvent()函数，这个函数通过回调从而调用Acceptor::handleRead()函数来响应事件。这样的手法是基于对象的编程思想。</p>
<p>  TcpConnection是对已连接套接字的抽象。</p>
<p>  一旦被动连接(Acceptor)或主动连接(Connector)建立，就会得到一个已连接的套接字。即获得TcpConnection。</p>
<p>  TcpServer和Acceptor是组合关系，TcpServer控制着Acceptor的生命周期。</p>
<p>  TcpClient和Connector是组合关系，TcpClient控制着Connector的生命周期。</p>
<p>  TcpServer与TcpConnection是聚合关系，一个TcpServer包含多个TcpConnection，但不控制TcpConnection的生命周期。</p>
<h2 id="test">Test</h2>
<h3 id="eventloop">EventLoop</h3>
<p>启动两个事件循环：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;threadFunc(): pid = %d, tid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main(): pid = %d, tid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Thread</span> <span class="n">t</span><span class="p">(</span><span class="n">threadFunc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个EventLoop存在共享于两个线程中将会触发assertInLoopThread断言：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">g_loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> <span class="p">{</span> <span class="n">g_loop</span><span class="o">-&gt;</span><span class="n">loop</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">g_loop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Thread</span> <span class="n">t</span><span class="p">(</span><span class="n">threadFunc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>runInLoop实现跨线程安全调用的测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">g_loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">g_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">run4</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;run4(): pid = %d, flag = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">g_flag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">g_loop</span><span class="o">-&gt;</span><span class="n">quit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">run3</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;run3(): pid = %d, flag = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">g_flag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">g_loop</span><span class="o">-&gt;</span><span class="n">runAfter</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">run4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">g_flag</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">run2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;run2(): pid = %d, flag = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">g_flag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">g_loop</span><span class="o">-&gt;</span><span class="n">queueInLoop</span><span class="p">(</span><span class="n">run3</span><span class="p">);</span> <span class="c1">// 异步地将run3方法添加到任务队列中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">run1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">g_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;run1(): pid = %d, flag = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">g_flag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">g_loop</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">run2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">g_flag</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main(): pid = %d, flag = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">g_flag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">g_loop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="p">.</span><span class="n">runAfter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">run1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main(): pid = %d, flag = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">g_flag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="timerqueue">TimerQueue</h3>
<p>定时器的初步构思：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;Channel.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;boost/bind.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/timerfd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">g_loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">timerfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">timeout</span><span class="p">(</span><span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Timeout!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">uint64_t</span> <span class="n">howmany</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">timerfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">howmany</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">howmany</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">g_loop</span><span class="o">-&gt;</span><span class="n">quit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">g_loop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">timerfd</span> <span class="o">=</span> <span class="o">::</span><span class="n">timerfd_create</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">TFD_NONBLOCK</span> <span class="o">|</span> <span class="n">TFD_CLOEXEC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Channel</span> <span class="n">channel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="p">,</span> <span class="n">timerfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel</span><span class="p">.</span><span class="n">setReadCallback</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">channel</span><span class="p">.</span><span class="n">enableReading</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">itimerspec</span> <span class="n">howlong</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">howlong</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">howlong</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">howlong</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">timerfd_settime</span><span class="p">(</span><span class="n">timerfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">howlong</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">timerfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>TimerQueue测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoopThread.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;Thread.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;boost/bind.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">EventLoop</span> <span class="o">*</span><span class="n">g_loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">printTid</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;pid = %d, tid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;now %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">().</span><span class="n">toString</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;msg %s %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">().</span><span class="n">toString</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">g_loop</span><span class="o">-&gt;</span><span class="n">quit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">cancel</span><span class="p">(</span><span class="n">TimerId</span> <span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">g_loop</span><span class="o">-&gt;</span><span class="n">cancel</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;cancelled at %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">Timestamp</span><span class="o">::</span><span class="n">now</span><span class="p">().</span><span class="n">toString</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printTid</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">g_loop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">print</span><span class="p">(</span><span class="s">&#34;main&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="p">.</span><span class="n">runAfter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">print</span><span class="p">,</span> <span class="s">&#34;once1&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="p">.</span><span class="n">runAfter</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">print</span><span class="p">,</span> <span class="s">&#34;once1.5&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="p">.</span><span class="n">runAfter</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">print</span><span class="p">,</span> <span class="s">&#34;once2.5&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="p">.</span><span class="n">runAfter</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">print</span><span class="p">,</span> <span class="s">&#34;once3.5&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">TimerId</span> <span class="n">t45</span> <span class="o">=</span> <span class="n">loop</span><span class="p">.</span><span class="n">runAfter</span><span class="p">(</span><span class="mf">4.5</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">print</span><span class="p">,</span> <span class="s">&#34;once4.5&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="p">.</span><span class="n">runAfter</span><span class="p">(</span><span class="mf">4.2</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">cancel</span><span class="p">,</span> <span class="n">t45</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="p">.</span><span class="n">runAfter</span><span class="p">(</span><span class="mf">4.8</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">cancel</span><span class="p">,</span> <span class="n">t45</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="p">.</span><span class="n">runEvery</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">print</span><span class="p">,</span> <span class="s">&#34;every2&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">TimerId</span> <span class="n">t3</span> <span class="o">=</span> <span class="n">loop</span><span class="p">.</span><span class="n">runEvery</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">print</span><span class="p">,</span> <span class="s">&#34;every3&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="p">.</span><span class="n">runAfter</span><span class="p">(</span><span class="mf">9.001</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">cancel</span><span class="p">,</span> <span class="n">t3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">print</span><span class="p">(</span><span class="s">&#34;main loop exits&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">EventLoopThread</span> <span class="n">loopThread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loopThread</span><span class="p">.</span><span class="n">startLoop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="o">-&gt;</span><span class="n">runAfter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">printTid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">print</span><span class="p">(</span><span class="s">&#34;thread loop exits&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="eventloopthread">EventLoopThread</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoopThread.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">runInThread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;runInThread(): pid = %d, tid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main(): pid = %d, tid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">CurrentThread</span><span class="o">::</span><span class="n">tid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">EventLoopThread</span> <span class="n">loopThread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loopThread</span><span class="p">.</span><span class="n">startLoop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 异步调用runInThread，即将runInThread添加到loop对象所在IO线程，让该IO线程执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">loop</span><span class="o">-&gt;</span><span class="n">runInLoop</span><span class="p">(</span><span class="n">runInThread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// runAfter内部也调用了runInLoop，所以这里也是异步调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">loop</span><span class="o">-&gt;</span><span class="n">runAfter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">runInThread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="o">-&gt;</span><span class="n">quit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;exit main().</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="acceptor">Acceptor</h3>
<p>服务启动后，模拟客户端连接<code>telnet 127.0.0.1 8888</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;Acceptor.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;InetAddress.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;SocketsOps.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">newConnection</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">peerAddr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;newConnection(): accepted a new connection from %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="n">peerAddr</span><span class="p">.</span><span class="n">toIpPort</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="s">&#34;How are you?</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">sockets</span><span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main(): pid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="n">listenAddr</span><span class="p">(</span><span class="mi">8888</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Acceptor</span> <span class="n">acceptor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="p">,</span> <span class="n">listenAddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">acceptor</span><span class="p">.</span><span class="n">setNewConnectionCallback</span><span class="p">(</span><span class="n">newConnection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">acceptor</span><span class="p">.</span><span class="n">listen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="tcpserver">TcpServer</h3>
<p>服务启动后，模拟客户端连接<code>telnet 127.0.0.1 8888</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;InetAddress.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;TcpServer.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">onConnection</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;onConnection(): new connection [%s] from %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">peerAddress</span><span class="p">().</span><span class="n">toIpPort</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;onConnection(): connection [%s] is down</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">onMessage</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">,</span> <span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">string</span> <span class="n">msg</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">retrieveAllAsString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;onMessage(): received %zd bytes from connection [%s] at %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="n">msg</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">         <span class="n">receiveTime</span><span class="p">.</span><span class="n">toFormattedString</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">conn</span><span class="o">-&gt;</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main(): pid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="n">listenAddr</span><span class="p">(</span><span class="mi">8888</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">TcpServer</span> <span class="n">server</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="p">,</span> <span class="n">listenAddr</span><span class="p">,</span> <span class="s">&#34;TestServer&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">server</span><span class="p">.</span><span class="n">setConnectionCallback</span><span class="p">(</span><span class="n">onConnection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">server</span><span class="p">.</span><span class="n">setMessageCallback</span><span class="p">(</span><span class="n">onMessage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">server</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;InetAddress.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;TcpServer.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;boost/bind.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TestServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">TestServer</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span> <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">listenAddr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span> <span class="n">server_</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">listenAddr</span><span class="p">,</span> <span class="s">&#34;TestServer&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_</span><span class="p">.</span><span class="n">setConnectionCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TestServer</span><span class="o">::</span><span class="n">onConnection</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_</span><span class="p">.</span><span class="n">setMessageCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TestServer</span><span class="o">::</span><span class="n">onMessage</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">_3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span> <span class="n">server_</span><span class="p">.</span><span class="n">start</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">onConnection</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;onConnection(): new connection [%s] from %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">             <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">peerAddress</span><span class="p">().</span><span class="n">toIpPort</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;onConnection(): connection [%s] is down</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">onMessage</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">,</span> <span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">msg</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">retrieveAllAsString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;onMessage(): received %zd bytes from connection [%s] at %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">msg</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">           <span class="n">receiveTime</span><span class="p">.</span><span class="n">toFormattedString</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">conn</span><span class="o">-&gt;</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">TcpServer</span> <span class="n">server_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main(): pid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="n">listenAddr</span><span class="p">(</span><span class="mi">8888</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">TestServer</span> <span class="n">server</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="p">,</span> <span class="n">listenAddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">server</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;InetAddress.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;TcpServer.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;boost/bind.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TestServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">TestServer</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span> <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">listenAddr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span> <span class="n">server_</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">listenAddr</span><span class="p">,</span> <span class="s">&#34;TestServer&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_</span><span class="p">.</span><span class="n">setConnectionCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TestServer</span><span class="o">::</span><span class="n">onConnection</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_</span><span class="p">.</span><span class="n">setMessageCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TestServer</span><span class="o">::</span><span class="n">onMessage</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">_3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">message1_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">message2_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">message1_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">message1_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="sc">&#39;A&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">message2_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">message2_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="sc">&#39;B&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span> <span class="n">server_</span><span class="p">.</span><span class="n">start</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">onConnection</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;onConnection(): new connection [%s] from %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">             <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">peerAddress</span><span class="p">().</span><span class="n">toIpPort</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">conn</span><span class="o">-&gt;</span><span class="n">send</span><span class="p">(</span><span class="n">message1_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">conn</span><span class="o">-&gt;</span><span class="n">send</span><span class="p">(</span><span class="n">message2_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">conn</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;onConnection(): connection [%s] is down</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">onMessage</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">,</span> <span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">muduo</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">retrieveAllAsString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;onMessage(): received %zd bytes from connection [%s] at %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">msg</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">           <span class="n">receiveTime</span><span class="p">.</span><span class="n">toFormattedString</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">conn</span><span class="o">-&gt;</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">TcpServer</span> <span class="n">server_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">muduo</span><span class="o">::</span><span class="n">string</span> <span class="n">message1_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">muduo</span><span class="o">::</span><span class="n">string</span> <span class="n">message2_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main(): pid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="n">listenAddr</span><span class="p">(</span><span class="mi">8888</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">TestServer</span> <span class="n">server</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="p">,</span> <span class="n">listenAddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">server</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;EventLoop.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;InetAddress.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;TcpServer.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;boost/bind.hpp&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">muduo</span><span class="o">::</span><span class="n">net</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TestServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">TestServer</span><span class="p">(</span><span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop</span><span class="p">,</span> <span class="k">const</span> <span class="n">InetAddress</span> <span class="o">&amp;</span><span class="n">listenAddr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">loop_</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span> <span class="n">server_</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">listenAddr</span><span class="p">,</span> <span class="s">&#34;TestServer&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_</span><span class="p">.</span><span class="n">setConnectionCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TestServer</span><span class="o">::</span><span class="n">onConnection</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_</span><span class="p">.</span><span class="n">setMessageCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TestServer</span><span class="o">::</span><span class="n">onMessage</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">_3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_</span><span class="p">.</span><span class="n">setWriteCompleteCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TestServer</span><span class="o">::</span><span class="n">onWriteComplete</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 生成数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">string</span> <span class="n">line</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">33</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">127</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">line</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="kt">char</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">line</span> <span class="o">+=</span> <span class="n">line</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">127</span> <span class="o">-</span> <span class="mi">33</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">message_</span> <span class="o">+=</span> <span class="n">line</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">72</span><span class="p">)</span> <span class="o">+</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span> <span class="n">server_</span><span class="p">.</span><span class="n">start</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">onConnection</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;onConnection(): new connection [%s] from %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">             <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">peerAddress</span><span class="p">().</span><span class="n">toIpPort</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">conn</span><span class="o">-&gt;</span><span class="n">setTcpNoDelay</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">conn</span><span class="o">-&gt;</span><span class="n">send</span><span class="p">(</span><span class="n">message_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;onConnection(): connection [%s] is down</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">onMessage</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">,</span> <span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="n">Timestamp</span> <span class="n">receiveTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">muduo</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">retrieveAllAsString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;onMessage(): received %zd bytes from connection [%s] at %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">msg</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">           <span class="n">receiveTime</span><span class="p">.</span><span class="n">toFormattedString</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">conn</span><span class="o">-&gt;</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">onWriteComplete</span><span class="p">(</span><span class="k">const</span> <span class="n">TcpConnectionPtr</span> <span class="o">&amp;</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">send</span><span class="p">(</span><span class="n">message_</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="o">*</span><span class="n">loop_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">TcpServer</span> <span class="n">server_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">muduo</span><span class="o">::</span><span class="n">string</span> <span class="n">message_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main(): pid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">InetAddress</span> <span class="n">listenAddr</span><span class="p">(</span><span class="mi">8888</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">EventLoop</span> <span class="n">loop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">TestServer</span> <span class="n">server</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="p">,</span> <span class="n">listenAddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">server</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">loop</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="Updated on 2022-12-18 00:00:00">Updated on 2022-12-18&nbsp;</span>
      </div><div class="post-info-license">
          <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
        </div></div>
    <div class="post-info-line">
      <div class="post-info-md"></div>
      <div class="post-info-share">
        <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" data-title="muduo网络库源码学习" data-hashtags="muduo"><i class="fa-brands fa-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" data-hashtag="muduo"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://cui-jiang-tao.github.io/posts/muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" data-title="muduo网络库源码学习"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
      </div>
    </div>
  </div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/tags/muduo/' class="post-tag">muduo</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/c&#43;&#43;_primer_5th/" class="post-nav-item" rel="prev" title="c&#43;&#43; primer 5th 要点记录"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>c&#43;&#43; primer 5th 要点记录</a>
      <a href="/posts/hugo%E6%90%AD%E5%BB%BA/" class="post-nav-item" rel="next" title="Hugo的安装和FixIt 主题">Hugo的安装和FixIt 主题<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></main><footer class="footer">
    <div class="footer-container"><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2022 - 2023</span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="Back to Top"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><noscript>
    <div class="noscript-warning">Theme FixIt works best with JavaScript enabled.</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/typeit/index.umd.js" defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":-1},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"data":{"typeit-header-desktop":"Home","typeit-header-title-mobile":"Home"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"typeit-header-desktop":["typeit-header-desktop"],"typeit-header-title-mobile":["typeit-header-title-mobile"]},"duration":-1,"loop":false,"speed":100}};</script><script src="/js/theme.min.js" defer></script></body>
</html>
